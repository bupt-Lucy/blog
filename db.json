{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-stellar/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/copycode.js","path":"js/plugins/copycode.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/download-file.js","path":"js/plugins/download-file.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/video.js","path":"js/plugins/video.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/voice.js","path":"js/plugins/voice.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/artalk_latest_comment.js","path":"js/services/artalk_latest_comment.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/fcircle.js","path":"js/services/fcircle.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/friends.js","path":"js/services/friends.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/search/algolia-search.js","path":"js/search/algolia-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/ghinfo.js","path":"js/services/ghinfo.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/giscus_latest_comment.js","path":"js/services/giscus_latest_comment.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/mdrender.js","path":"js/services/mdrender.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/memos.js","path":"js/services/memos.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/siteinfo.js","path":"js/services/siteinfo.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/sites.js","path":"js/services/sites.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/timeline.js","path":"js/services/timeline.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/twikoo_latest_comment.js","path":"js/services/twikoo_latest_comment.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/waline_latest_comment.js","path":"js/services/waline_latest_comment.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/weibo.js","path":"js/services/weibo.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_data/widgets.yml","hash":"63a55470e5cffe94890ddfb7eb3ac008c824f9d0","modified":1759325044624},{"_id":"source/explore/index.md","hash":"1359af70cc476f02a20abbc3fcb1f089b4965d45","modified":1759470716777},{"_id":"source/_data/wiki.yml","hash":"78985c22e3aac7a926f63b30f308b0dfab132ca4","modified":1759240440296},{"_id":"source/_posts/1-秒杀项目1.0-丢失更新和锁失效.md","hash":"44ecd7ded98277512cd74c8efbec9197a4f0c2b5","modified":1759463714182},{"_id":"source/_posts/1-秒杀项目1.1-读写分离.md","hash":"6122d26e5a8c2215b0dcc3cd381e453f9c23be3b","modified":1759318716755},{"_id":"source/_posts/1-秒杀项目1.3-异步处理和优化.md","hash":"99a38abd88f517e96dbe5671c86022be267b9333","modified":1759500597498},{"_id":"source/_posts/1-秒杀项目1.2-流量控制.md","hash":"d0271adcd0ba65c0c389952e829c427174c1234f","modified":1759470071847},{"_id":"source/_posts/1-秒杀项目2.0-Redis机制.md","hash":"d9fae92148e3353ed8a77480d2b42c3888c6ceb1","modified":1759664648779},{"_id":"source/_posts/从零开始搭建个人博客.md","hash":"d927b24ac06a476614575cd0607a938a5b68b27d","modified":1758762554444},{"_id":"source/_posts/论文阅读-1.md","hash":"9ff25eb00341bfd26192601c6cfe34110faf98d4","modified":1757660711214},{"_id":"source/friends/index.md","hash":"e2afe3585bf3598eefabdde8763bd8380b31ba3f","modified":1759237867169},{"_id":"source/wiki/index.md","hash":"65d8a5173e3b5272d4b0988b8472e0146ff2a027","modified":1759238110569},{"_id":"source/wiki/Seckill/1-秒杀项目1.0-丢失更新和锁失效.md","hash":"8dfbe2ec221ca7621020e75886ee31515a0818b3","modified":1759496328478},{"_id":"source/_data/wiki/Seckill.yml","hash":"c624ace2aa1ac248ea6b2ee401649a994a14a4d2","modified":1759664893624},{"_id":"source/wiki/Seckill/1-秒杀项目1.1-读写分离.md","hash":"5e4e485631d5210fcc6ef3c0e174f35f5cb2f48f","modified":1759496324957},{"_id":"source/wiki/Seckill/1-秒杀项目1.2-流量控制.md","hash":"b52a793f0245e5b30ffcc0eb851901c5d992442c","modified":1759470683308},{"_id":"source/wiki/Seckill/1-秒杀项目1.3-异步处理和优化.md","hash":"3dffaf5fd7a674798823d954e4bd52857d7b9ee4","modified":1759500560838},{"_id":"source/wiki/Seckill/1-秒杀项目2.0-Redis机制.md","hash":"fb0de5fcbe6f8185b304923e95902946c26eeccb","modified":1759664874059},{"_id":"node_modules/hexo-theme-stellar/_data/chat_users.yml","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1748507942881},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/search.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1748507942969},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/tree.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1748507943154},{"_id":"node_modules/hexo-theme-stellar/LICENSE","hash":"7fdfdb5dbc7d672fa28a2a3c9efa03ff8df5917d","modified":1748507942877},{"_id":"node_modules/hexo-theme-stellar/README.md","hash":"d474d9b14cafda27ab291336cbdb4ac91bfec756","modified":1748507942878},{"_id":"node_modules/hexo-theme-stellar/package.json","hash":"da28416772e618a0740cf898a767f719eacbfcee","modified":1748507942880},{"_id":"node_modules/hexo-theme-stellar/languages/en.yml","hash":"5397b48828cceb50a071ee0f3b1432e304cad8ae","modified":1748507942892},{"_id":"node_modules/hexo-theme-stellar/languages/zh-TW.yml","hash":"fa911ea00c326a1b261cc3e5f1770b27e0238ccf","modified":1748507942894},{"_id":"node_modules/hexo-theme-stellar/_config.yml","hash":"a12bc5253bcfa95f221dad326318a5bc64dfecd9","modified":1748507942879},{"_id":"node_modules/hexo-theme-stellar/languages/zh-CN.yml","hash":"faaf9f9e0728f4fff885f9591cd4daef0b195f25","modified":1748507942893},{"_id":"node_modules/hexo-theme-stellar/layout/404.ejs","hash":"d84f01256feb3c0bc0b280031fb78ae9f0d86f26","modified":1748507942895},{"_id":"node_modules/hexo-theme-stellar/layout/archive.ejs","hash":"af072e9b75e8d5371771237e71a1f1381078526a","modified":1748507942896},{"_id":"node_modules/hexo-theme-stellar/_data/icons.yml","hash":"1ba122dcac1ed8fa1443b0baa0c9b9f1d007b7fe","modified":1748507942889},{"_id":"node_modules/hexo-theme-stellar/layout/categories.ejs","hash":"eaf71831abd6780690f26fa1a7cf83bc6f08d7e9","modified":1748507942897},{"_id":"node_modules/hexo-theme-stellar/layout/index_topic.ejs","hash":"6bffb1488ce9c2c4b04386cb7fe61792ae5491f2","modified":1748507942898},{"_id":"node_modules/hexo-theme-stellar/_data/widgets.yml","hash":"52f5bd010f5ca20bcb0b880218f2b1e9e159210b","modified":1748507942890},{"_id":"node_modules/hexo-theme-stellar/layout/index.ejs","hash":"ea5fa65b2049bc1c4c8c247972a79310468e3c68","modified":1748507942897},{"_id":"node_modules/hexo-theme-stellar/layout/index_wiki.ejs","hash":"9e7dc6941c5205ed60fa7abfb1f36ae19e2f3834","modified":1748507942899},{"_id":"node_modules/hexo-theme-stellar/layout/layout.ejs","hash":"f653ed0550864c3d8fc1253a3b521451558fa557","modified":1748507942900},{"_id":"node_modules/hexo-theme-stellar/layout/notebooks.ejs","hash":"7519887f825bc9ae1ca842e02bc5b2ad909e77a9","modified":1748507942901},{"_id":"node_modules/hexo-theme-stellar/layout/notes.ejs","hash":"242f663e983fc496c51aab9531ccfe46b0d1b05e","modified":1748507942901},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/head.ejs","hash":"aed85b0e59be222d385f92b27c3a26c7f6af7d4b","modified":1748507942904},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/menubtn.ejs","hash":"36775d16431301a6ac02858f32a8ee470ef8332f","modified":1748507942905},{"_id":"node_modules/hexo-theme-stellar/layout/page.ejs","hash":"af600622274600941309fb7c06ebe860ceca24f2","modified":1748507942902},{"_id":"node_modules/hexo-theme-stellar/layout/tags.ejs","hash":"4ff8ccff9a9c8d373df788fbc0bebdc87302056e","modified":1748507942902},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/copycode.ejs","hash":"7cedd8eced00f6813f7d772334ec92acbc8bd982","modified":1748507942907},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts.ejs","hash":"a20f3ec0c27972a27b075917ce24363c080b2e30","modified":1748507942906},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/fancybox.ejs","hash":"dcb638d9320eea6c9a6b7b0212e6167341bec05b","modified":1748507942908},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/heti.ejs","hash":"c3956c8fd5fabd4ec8cea05dc076bf7a03eb012a","modified":1748507942909},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/index.ejs","hash":"29407e95f14d4d50c1f8a8b9a5af242927676432","modified":1748507942910},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/lazyload.ejs","hash":"e2b07b0c97d531c82cc02a80610fe0c1a39bc837","modified":1748507942910},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/mathjax.ejs","hash":"c1621e718747a6eb34734e7e4a8364f5a78dc714","modified":1748507942912},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/mermaid.ejs","hash":"5ad208b430071ed4ee84af4ae69356219ec586f0","modified":1748507942914},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/preload.ejs","hash":"f25523da5633b249da8cebe7c866265bf7825697","modified":1748507942914},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/scrollreveal.ejs","hash":"15fb2ef3de2121360c3cb5a4dfba0a50bafd608e","modified":1748507942915},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/swiper.ejs","hash":"b80d6185c0263375df82498705a98ad32238b12f","modified":1748507942916},{"_id":"node_modules/hexo-theme-stellar/scripts/events/index.js","hash":"01a8d06a48af2f20aacfac76962bde5edd83dd3f","modified":1748507942918},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/tianli_gpt.ejs","hash":"c63f65df336bd10b2c5f068830c3086f3f13f3a3","modified":1748507942916},{"_id":"node_modules/hexo-theme-stellar/scripts/filters/index.js","hash":"1fca6cadef00b661f1ef4fc27c2dffc5d97bebdd","modified":1748507942920},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/404.js","hash":"66b53d2b35b18d5f3835b47467c23f31eb322553","modified":1748507942922},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/author.js","hash":"0de0824fdbc4f67c84910267901095504b253751","modified":1748507942922},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/categories.js","hash":"936d4d406fd401359bab1e5f74c6e1e097e8f092","modified":1748507942923},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/notebooks.js","hash":"ee48a2fa3d03d0fa60f36c4c6d3ca6b192bc6f50","modified":1748507942924},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/tags.js","hash":"ed29755154d8e7a9346019ba4ac8782a8649b177","modified":1748507942927},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/search.js","hash":"8a59c0923c2a4a11c09ce87fccf98c090c73a0e4","modified":1748507942926},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/wiki.js","hash":"61efe22787c3fea9d935df4b088a9dd2d1af0868","modified":1748507942928},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/topic.js","hash":"88c0f2990365fb0ce751682815e07f36cf333d3f","modified":1748507942927},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/category_color.js","hash":"20b19d6b6307cdeb0b0832bf4931366abe972490","modified":1748507942929},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/dynamic_color.js","hash":"507acbb7445ec172e10ab03c8917a4d8132e264a","modified":1748507942930},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/icon.js","hash":"b7c84be7f08abc1725f351ed8718791a861466c3","modified":1748507942930},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/parse_config.js","hash":"1251d82318972f22283dc7a089b77a3f0135b1b6","modified":1748507942931},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/related_posts.js","hash":"6763a97fa25669fa1d1aa8e5291919deb5dc7f67","modified":1748507942932},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/index.js","hash":"aa9828b105feb930755df6715fe4a4c210635e5b","modified":1748507942935},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/scrollreveal.js","hash":"57e3da4a3dd751b3ebd384a674e26f08f69da018","modified":1748507942932},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/stellar_info.js","hash":"5b7a10c8b09237a467767f5467749c7d9378c2c1","modified":1748507942933},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/utils.js","hash":"05c127baa250b192c9c673355bf90d7134e1ea11","modified":1748507942934},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/inline-labels.js","hash":"a9cb7520af8a95f467c048128c036cbb3167fb8d","modified":1748507942937},{"_id":"node_modules/hexo-theme-stellar/source/js/main.js","hash":"41ddd41a9f1896ad548a8eaa8610da2f823009ba","modified":1748507942941},{"_id":"node_modules/hexo-theme-stellar/source/css/_custom.styl","hash":"f3068b24285214090860a4aa146cc64bc3662a84","modified":1748507942939},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/layout.ejs","hash":"3dbdb141d295d25b4f67fd0e299c40baa38241a8","modified":1748507942943},{"_id":"node_modules/hexo-theme-stellar/source/css/main.styl","hash":"44b5008a50682b442f38f1cc2ffd117e4dfc9ec5","modified":1748507942940},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/script.ejs","hash":"62be59ef634ceee342c81ecc4e23cb664cdbf620","modified":1748507942943},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/cover/index.ejs","hash":"4b317700640749b1e04e6d51a542a2bcd28c8b72","modified":1748507942944},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/cover/post_cover.ejs","hash":"59e6ae6726ded33e3d84208fd4a4872a6431fcc7","modified":1748507942945},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/footer.ejs","hash":"50f38f094dbbba887632fb3104c78b8be9eb39c7","modified":1748507942947},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/cover/wiki_cover.ejs","hash":"8374cf58d5cc52799b8e1c8af95dd84c65372173","modified":1748507942946},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/defines.ejs","hash":"cc4c6668be39e6a03279a5ac7cfd7eb364d705cd","modified":1748507942948},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/services.ejs","hash":"9dec23072ebbdf96d164bc698a11f3a09ea26d1a","modified":1748507942950},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/sidebar.ejs","hash":"403b6986bfc54177a7ee3ddba9e0a55e7b79e3a1","modified":1748507942950},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/sidebar/index_leftbar.ejs","hash":"3ce47de8a4e832454da10e271e4855b15cb3d9e7","modified":1748507942956},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/tagtree.ejs","hash":"c16031694fee3e0c305139136126dee88e1e88cf","modified":1748507942951},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/utils.ejs","hash":"4cf7b1cd5815e5594a92428694f3bc2470287138","modified":1748507942954},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/theme.ejs","hash":"9124e925cfe74f4af5f37530994f3af9bc6f470d","modified":1748507942952},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/author.ejs","hash":"4c7eab461e45a7a5863333e9904dadbed6c8ca0c","modified":1748507942961},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/sidebar/index_rightbar.ejs","hash":"a16ecd6d9421c30ffe2ca1a44cc9597309b5b70c","modified":1748507942957},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/sidebar/logo.ejs","hash":"cd08385b0026953cd9adf5c22af528b9c3e924e7","modified":1748507942958},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/ghissues.ejs","hash":"410f56e6da87e7a1476d033c6939a0241658a598","modified":1748507942962},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/sidebar/search.ejs","hash":"770056e023a00b22d2853c4fa65bb48035ade3b2","modified":1748507942959},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/sidebar/menu.ejs","hash":"59d579a0eaec7572485d8d4d22341de79a890d00","modified":1748507942959},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/ghuser.ejs","hash":"5d8cf68b091f8bf4b88ac230495bc2dec561ad6a","modified":1748507942963},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/linklist.ejs","hash":"813336cbbe4505e9be42d5682fd7b720dba25194","modified":1748507942964},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/ghrepo.ejs","hash":"e7d23ff8f8c96f77685e441c7f6040430d07a21a","modified":1748507942962},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/markdown.ejs","hash":"7ce0ce941c55e42c545c1fffa77a3db07e1989b1","modified":1748507942966},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/recent.ejs","hash":"3962a8b6f3c1adc80ecc846e6ad0888722ec5464","modified":1748507942968},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/related.ejs","hash":"ac6040f2067c799836d5dc4abacf0b879a156d88","modified":1748507942969},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/tagcloud.ejs","hash":"d95c26f84c7d9061ba3ef6188d58fa14f1c63bf3","modified":1748507942971},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/tagtree.ejs","hash":"9941285c0af5d5fbdf5e8e5b1c73f67304d9afed","modified":1748507942972},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/authors.js","hash":"eedefb5430fc4176bdc2814c8a88295f0e524d10","modified":1748507942976},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/config.js","hash":"a5eae5fd9c841692c1d26fcd2e2fc54ba622fcd0","modified":1748507942977},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/tree.ejs","hash":"2a7d37a843e32d073be4637bc17980e368a16003","modified":1748507942974},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/search/algolia_search.ejs","hash":"1d720e4b0308a0818f45a9a4b63df1e9f6521737","modified":1748507942975},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/timeline.ejs","hash":"745b384871291e0cf2f6ceb4a0c12989b4e8cd62","modified":1748507942972},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/search/local_search.ejs","hash":"38a3641bb532583b699fda42175cb14242f07575","modified":1748507942975},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/toc.ejs","hash":"fd0be7f0f60cea0e0e637d122af47a601f56010c","modified":1748507942973},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/doc_tree.js","hash":"f7d6b86a442afabf885566adfc02d42dc5eaf46e","modified":1748507942979},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/links.js","hash":"881cac75e4071d219a18156738e18eb397d83c00","modified":1748507942979},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/merge_posts.js","hash":"4e45b8dc5317f7d66bc14879ae6b5f972123ce5d","modified":1748507942980},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/notebooks.js","hash":"ad5eae17a77a92100c748fd668c73e1b09f7a21f","modified":1748507942981},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/topic_tree.js","hash":"7f735f2573c87d202e2d4b845307d0725d619e8e","modified":1748507942982},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/utils.js","hash":"271ba6c8cc997e4f55b2e146a99bde8301818400","modified":1748507942982},{"_id":"node_modules/hexo-theme-stellar/scripts/filters/lib/img_onerror.js","hash":"d44a8e20d4d537c0cf85b980e1fc3bc84865a2d3","modified":1748507942984},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/about.js","hash":"c9778c35c1ccd9f2018174bafbd37b23dd52cf62","modified":1748507942986},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/albums.js","hash":"9fd16a8ceffd1806c25582062af7a72eca0e5c56","modified":1748507942987},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/audio.js","hash":"9b094b16dce131a5c09373661c88a1de9b5326f7","modified":1748507942988},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/button.js","hash":"e0890a759335b1c5ad09db084bcf62073b2557cb","modified":1748507942991},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/banner.js","hash":"1fceb77a37ecaddf38c03aa655eec878701427c0","modified":1748507942989},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/box.js","hash":"66bed2e303468a8fd9c664ce3e697ceb4e3eb931","modified":1748507942990},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/checkbox.js","hash":"69caf7488b6c92cb2524df81ece6f33a46a89fe0","modified":1748507942996},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/emoji.js","hash":"e10f68f69206fc6e9d0c478630be2b4514d328d7","modified":1748507942999},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/copy.js","hash":"d22a82b6fd9c96c7ac49677b427e6c629fa889d7","modified":1748507942998},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/folders.js","hash":"4ca5470285541033b8272ba7cc3bd5860504169e","modified":1748507942999},{"_id":"node_modules/hexo-theme-stellar/scripts/filters/lib/img_lazyload.js","hash":"b3dedcc1fc4189589e63d4fa6f169a70e9d63cd1","modified":1748507942984},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/frame.js","hash":"1251a8622260af8efc55c2f0aac8ee5cf79d9043","modified":1748507943001},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/folding.js","hash":"9f51610fc62067a16a9c27884864f69e4200843c","modified":1748507943000},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/friends.js","hash":"da08a75ad3579464debe8da2dd57314bd641dbb2","modified":1748507943002},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/gallery.js","hash":"56a9309b096cbe1876a1e8c2b7c3f692325135e1","modified":1748507943003},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/ghcard.js","hash":"039ee39d8dba7c0aa0e267de38f9064b30855a55","modified":1748507943004},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/icon.js","hash":"273898ae29a07c1baccb432efa0d33ccfabe7db9","modified":1748507943007},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/grid.js","hash":"dad59b638c2fd30538e3a69bf0c8d76d34cf3ece","modified":1748507943005},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/hashtag.js","hash":"f38ce98fff40ed35be9b1f1be3194bc4c5d44dc3","modified":1748507943006},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/mark.js","hash":"cfd8198f349dba60fbdf53042b6ebd9a0ba521c7","modified":1748507943010},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/image.js","hash":"aa10441f0ec79b2f33829e5b1b8b4b4c21d865e9","modified":1748507943009},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/link.js","hash":"8a1297c324749f98e24036d3aa91ad374ad1d930","modified":1748507943010},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/md.js","hash":"6ed5db6d055dbfe01ecaeddbd0ead13a20ba7e74","modified":1748507943011},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/note.js","hash":"a70d1fcb440ad029ddddb72b053a59b1ed3bfef8","modified":1748507943013},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/navbar.js","hash":"e78ca3469c44362c7d8c3ad8899f49a119b326ff","modified":1748507943012},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/poetry.js","hash":"c36321caeec845ed131bdd0922bff25eb59f086a","modified":1748507943014},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/okr.js","hash":"8e7a7d912e4f5e1fe1feb6125e4762c378b11ba3","modified":1748507943014},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/posters.js","hash":"713e1367f3a60e5903954a8fab15b0d9d9cfd89a","modified":1748507943016},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/sites.js","hash":"cb4b81d6e91f3903f8ee3e944571dfba21cd24b4","modified":1748507943016},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/quot.js","hash":"f15aa5c0fc87114a98e51baefb048b22302f7474","modified":1748507943016},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/base.styl","hash":"2986c5771652c353a320f4404ceeb1c6b257a6ed","modified":1748507943022},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/swiper.js","hash":"dc025c79b190d233383fec001ddbe478f2675cc8","modified":1748507943017},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/tabs.js","hash":"1b3d7b6b962293b44430e7b40560b8d1fa5c618d","modified":1748507943018},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/toc.js","hash":"d7b51b66d7b83a77e501930e735092a9967d5d18","modified":1748507943020},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/timeline.js","hash":"f1defeed67e56c055f37ee7fab8a597a9d14f89e","modified":1748507943019},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/video.js","hash":"071cde27216306c6821c0e692c3904274a985213","modified":1748507943021},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/blockquote.styl","hash":"f107e6f399382a6663722bc2e823986c257da9a3","modified":1748507943023},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/blur.styl","hash":"43441caaee7b7ab011a26016362b023263cd64a8","modified":1748507943024},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/device.styl","hash":"fa135f5d93f8a333cc77f7dd4f6b8bf88e0f43bd","modified":1748507943027},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/button.styl","hash":"9afb3e566294f95f404a608b666367081a691e6b","modified":1748507943025},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/cap.styl","hash":"c99286644d4a44dc76e1fe9a3af1815112f65acc","modified":1748507943025},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/control.styl","hash":"75081ca9d522a76ec4acffb8111c918b2297650a","modified":1748507943026},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/highlight.styl","hash":"2e1191dbfa6e77a53ea9e95cecf66dc5b3d63b81","modified":1748507943028},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/html.styl","hash":"e7f596ff7294517096f5cb27f5af53b1a797e047","modified":1748507943028},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/image.styl","hash":"cca1103a9185202b13be49e16d77d259e9ffb482","modified":1748507943029},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/input.styl","hash":"953fc87072cd760d92dfef55310addbb17bb2b51","modified":1748507943029},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/loading.styl","hash":"6962fd568ad9779146742b8b8928cec107972e8e","modified":1748507943031},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/layout.styl","hash":"c7d0d3c70087e14bd1f6d8d50d56762d8c5ad44d","modified":1748507943030},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/media.styl","hash":"fa7dbcaa31089fe547acb01a767af97fb019bba6","modified":1748507943031},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/pre.styl","hash":"be7ecc0a1cdd2e6f1594c4cc238734b2dc3a2c4e","modified":1748507943032},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/span.styl","hash":"86462ffaf1603b5d5ab6534c0f7fe0eb495aad2d","modified":1748507943033},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/index.styl","hash":"7a7ab293e065116646102546c6bab01166836059","modified":1748507943037},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/svg.styl","hash":"aa2ae391db2ea028b9221740b24fca7f7e9ff16c","modified":1748507943033},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/toast.styl","hash":"f2930874174763da2338fa95087c345bf5c41800","modified":1748507943035},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/title.styl","hash":"c9009b6c52a1ea4dfb6c2f56b1c3fc6de8a2c63a","modified":1748507943034},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/layout.styl","hash":"b7eb188db92bb9a32ae180969838f6eda2ec9640","modified":1748507943038},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/aplayer.styl","hash":"00b6e9209638eef9f70e75a24a5a90b05f7b5347","modified":1748507943044},{"_id":"node_modules/hexo-theme-stellar/source/css/_defines/theme.styl","hash":"e38e0061b92a01f2c05c08da1093ef503fb972df","modified":1748507943043},{"_id":"node_modules/hexo-theme-stellar/source/css/_defines/const.styl","hash":"c62a434f1eef895d343cb8255a19c6f1a6c73195","modified":1748507943042},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/main.styl","hash":"41040b445d23ff4e56656ce3ca4e0fd7fd67d67b","modified":1748507943040},{"_id":"node_modules/hexo-theme-stellar/source/css/_defines/func.styl","hash":"30a7500aef3a75ebd2b193e8999101631a12611f","modified":1748507943042},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/list.styl","hash":"326015062dd68c7ee8272416cf4f7732d20482cb","modified":1748507943039},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/md.styl","hash":"5cc0379fd0d4abf7a34944ccff1cf0b7dafdf091","modified":1748507943040},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/copycode.styl","hash":"a9f27136143eb779d1aeb903e863c94a98b82aac","modified":1748507943045},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/fancybox.styl","hash":"f4a709dcac4e21ca0fbeca552a8dde2ac2bf8d97","modified":1748507943046},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/katex.styl","hash":"f58016799f7a534d453625fab4cd66a13063e4b8","modified":1748507943047},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/index.styl","hash":"f96caf6f1d582973bc71199eee478cfc9fe88085","modified":1748507943047},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/lazyload.styl","hash":"6cd216067594d07c097a66e2403df36a1abbe6d6","modified":1748507943048},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/mermaid.styl","hash":"b01f298bb006abfe00bf68566bcc53c3cad4a6e7","modified":1748507943049},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/scrollreveal.styl","hash":"21b9125c1bae3e5348547e85500ceb992de21923","modified":1748507943050},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/swiper.styl","hash":"46179e1e9ca273f4e095388d981acdc9fce5bdb8","modified":1748507943050},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/tianli_gpt.styl","hash":"6cc2d27b8ec0296de09ce38d15abdd966702b79a","modified":1748507943051},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/download-file.js","hash":"dd0cb9ea1bc6464567a96ee47c35b43d7eb086e8","modified":1748507943054},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/copycode.js","hash":"af017eeaaf12e78b1700d78b199b4368d001a193","modified":1748507943053},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/video.js","hash":"e87d271175dfb4763c9c017046f7d857c7a3ba56","modified":1748507943055},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/voice.js","hash":"4c865125754c98dd61de28ad88c831be3d673a35","modified":1748507943056},{"_id":"node_modules/hexo-theme-stellar/source/js/services/artalk_latest_comment.js","hash":"29a6ca87b9dac4708164f31d0f99a1c6bebd38ea","modified":1748507943059},{"_id":"node_modules/hexo-theme-stellar/source/js/search/local-search.js","hash":"cf710d711fcbc21122cdc01edd43d9b4087f1b9d","modified":1748507943058},{"_id":"node_modules/hexo-theme-stellar/source/js/search/algolia-search.js","hash":"94dae768b275b12753553553b3338fca4973a1e3","modified":1748507943057},{"_id":"node_modules/hexo-theme-stellar/source/js/services/fcircle.js","hash":"add550bfb204a2057661d4d6630d78ebf485754d","modified":1748507943060},{"_id":"node_modules/hexo-theme-stellar/source/js/services/friends.js","hash":"91e408da632efe630a2c2048868c70c425e284da","modified":1748507943062},{"_id":"node_modules/hexo-theme-stellar/source/js/services/ghinfo.js","hash":"94b86ce42dd765e9a4c1befa72ee9648d7ec6f88","modified":1748507943062},{"_id":"node_modules/hexo-theme-stellar/source/js/services/giscus_latest_comment.js","hash":"2c9c9176f4d35b5c036c6723627d693345cbbf38","modified":1748507943063},{"_id":"node_modules/hexo-theme-stellar/source/js/services/mdrender.js","hash":"947f476e6dd8ca6a75f87f6ac6f2fbb2b0861e82","modified":1748507943063},{"_id":"node_modules/hexo-theme-stellar/source/js/services/memos.js","hash":"2d430c7ae4d9f3a44653eda0214d18fb60bcfed1","modified":1748507943064},{"_id":"node_modules/hexo-theme-stellar/source/js/services/siteinfo.js","hash":"74da788f29862604cd53f6b82b036ff56c715d21","modified":1748507943065},{"_id":"node_modules/hexo-theme-stellar/source/js/services/sites.js","hash":"b68ad17f1f8ae64819374824f29fe6ab29ddfb9a","modified":1748507943066},{"_id":"node_modules/hexo-theme-stellar/source/js/services/timeline.js","hash":"41cde82427726c3366b64b1f54f1aed9bc20fcf1","modified":1748507943066},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/artalk/layout.ejs","hash":"14b26d696ba6644ef9d5854e1b4a8fda028bddb9","modified":1748507943070},{"_id":"node_modules/hexo-theme-stellar/source/js/services/twikoo_latest_comment.js","hash":"d5c7bb0b9888333c2e10dedea8bfc19df5454d58","modified":1748507943067},{"_id":"node_modules/hexo-theme-stellar/source/js/services/waline_latest_comment.js","hash":"7520f62dcf3b991b99e37b8c33a7d6a89e7f2da5","modified":1748507943068},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/artalk/script.ejs","hash":"beee3759c0501f1ed5266fc6725332b1e1d54dce","modified":1748507943071},{"_id":"node_modules/hexo-theme-stellar/source/js/services/weibo.js","hash":"437e631539f3a50cf8b46ff17008404609c1c481","modified":1748507943069},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/giscus/script.ejs","hash":"49fd68b7752d0ca06d80a52bf800cf03845909e0","modified":1748507943077},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/giscus/layout.ejs","hash":"144e313ab45889c715ea1cfff3976b1f1322469e","modified":1748507943076},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/beaudar/script.ejs","hash":"69a2582d4e9e3203368196f4806adab2274e41fb","modified":1748507943075},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/beaudar/layout.ejs","hash":"431848ce38c18589ddb54d5e705bd7792872c199","modified":1748507943073},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/twikoo/layout.ejs","hash":"a3d429f4eafc582f739dd48865b39afd7c22ed56","modified":1748507943078},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/twikoo/script.ejs","hash":"3c93fe825769cd70027281c28980021b3ff8c4b0","modified":1748507943078},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/utterances/script.ejs","hash":"0c54bbd610c1b31d7f45b9b4ded65690b673482c","modified":1748507943080},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/waline/script.ejs","hash":"ef4b59476f4edf03cb25bdffe449b5da161d1d8e","modified":1748507943082},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/waline/layout.ejs","hash":"2abe764ffeab5603645b0e5148a17e9373de5eb4","modified":1748507943081},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/utterances/layout.ejs","hash":"431848ce38c18589ddb54d5e705bd7792872c199","modified":1748507943080},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/article/read_next.ejs","hash":"30c9e20e6835fa92a528de61041742ff42cc2af0","modified":1748507943085},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/article/article_footer.ejs","hash":"e93326cdd00f97d363c4830a81d7adb4dcae507c","modified":1748507943084},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/article_banner.ejs","hash":"1651576216695b49980cf4531a0020ab82fb65c7","modified":1748507943087},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/article/related_posts.ejs","hash":"ef485a4dc2db40bd68b35128f2140520db859b45","modified":1748507943085},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/dateinfo.ejs","hash":"f0ce9221931e9113de3df27eac39313eb0df217b","modified":1748507943087},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/notebook/note_card.ejs","hash":"f9b87418fbecf9e7e3a5d074ee9e9a26f5cc1788","modified":1748507943091},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/notebook/note_tags.ejs","hash":"6103372e1d17396550da909aed9de1f26e483962","modified":1748507943091},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/ghinfo.ejs","hash":"f5177430efd994b7c2d9d3104a58b0f1f60f4a00","modified":1748507943088},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/nav_tabs_blog.ejs","hash":"9a37405585fdabb01aca7b367ebb3ca4ed20d1ff","modified":1748507943089},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/nav_tabs_wiki.ejs","hash":"bb8644df466868a879fc97bc364f1aba6b1137cf","modified":1748507943090},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/notebook/notebook_card.ejs","hash":"999b9c8895d84db707b1654c42326dfbb5fbe0fa","modified":1748507943092},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/notebook/paginator.ejs","hash":"3c2f797fd3cf7e6e8c1b1dac168db26e92430b60","modified":1748507943093},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/post_list/paginator.ejs","hash":"1a4b3bc64325ec7d5932ea78c36f2ec4978c09eb","modified":1748507943094},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/post_list/post_card.ejs","hash":"dab8decf3ebf7a2d4d829a534af76e8500fbffbb","modified":1748507943095},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/post_list/wiki_card.ejs","hash":"d2676c1817f09be21008fbf1c2a25e3c9dc1793f","modified":1748507943096},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/post_list/topic_card.ejs","hash":"9f100016e7cfa07c8728f9c3cf9543ed3ed43cfe","modified":1748507943095},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/components/edit.ejs","hash":"9d976ca956c73128f72f39ca7641ceb5240b15a1","modified":1748507943097},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/components/link.ejs","hash":"eee3e54cca066643d973f7bc1e2af6230121e634","modified":1748507943098},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/components/linklist.ejs","hash":"91f3a83ff54284200951637c0cfcd3e4e613942e","modified":1748507943099},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/pages/archives.styl","hash":"a99f09f4cc948588d071f8cd95362f2d70ec4c40","modified":1748507943102},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/read/paper.js","hash":"e87bbcf10f743e1fcfadc03cf6281aee87c255f5","modified":1748507943101},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/read/reel.js","hash":"3a833a0c7d29f98972d6141103d62d5abfd913e4","modified":1748507943101},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/pages/notebook.styl","hash":"2f9199575a7a58490d5faf023511781066370dae","modified":1748507943104},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/sidebar/logo.styl","hash":"f81eb3d7a49c71f728d8bf42081bde30c6ff596e","modified":1748507943112},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/pages/error.styl","hash":"91f9df285a87bc7b7e9da19d547ea4b1dc392828","modified":1748507943103},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/sidebar/footer.styl","hash":"ac3423d488259ea467e95325e12f57476a9bdc9c","modified":1748507943112},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/article-banner.styl","hash":"325a1398d84e50cfae13b70f01aeaaf037ef54c1","modified":1748507943105},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/sidebar/menu.styl","hash":"57f772066edaa2cbe560622de28035780ad9000b","modified":1748507943113},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/sidebar/nav-area.styl","hash":"5302a72d15f7c35b391da723e84592f1129fca57","modified":1748507943114},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/sidebar/search.styl","hash":"ea880602a99ed8cb9b87f410e1f340b4d23d38e8","modified":1748507943115},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/sidebar/sidebar.styl","hash":"aaac0bc311badd146a11d3276ce89a4361c52ad4","modified":1748507943115},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/article-footer.styl","hash":"762c38e63aebbd028b5aed264349fa1d2a14e8af","modified":1748507943106},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/footer.styl","hash":"363fd4daf060fbf7de56fe5df787bc325565791b","modified":1748507943108},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/navbar.styl","hash":"282291ee0f876ea14cff671555ab9defe8fc2318","modified":1748507943109},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/cover.styl","hash":"ef44c47d0a70feb84d69cf8bb2bc6977f61b94f2","modified":1748507943108},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/paginator.styl","hash":"d5a64f3820ffc0913086c9fa35b26391eb023e61","modified":1748507943110},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/related.styl","hash":"b413ab434cfb778384fbac64d43da41437435aa0","modified":1748507943110},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/components.styl","hash":"34280561524a535342da3f246443b2a94fef074d","modified":1748507943147},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/ghrepo.styl","hash":"73d5baa3dfcc9e73fc7470e1ebe244857ffd75c1","modified":1748507943148},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/ghuser.styl","hash":"16c62c701f9cf6a253c6390d43eaa01cfd7600b1","modified":1748507943148},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/list.styl","hash":"176281f5ccc64f87da4bbd4e34316e32017bc3b4","modified":1748507943149},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/bread-nav.styl","hash":"daf58b32af0b5dfea6cbfa1c3cab695976e57164","modified":1748507943107},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/related.styl","hash":"8464b5adb8ffcd086d0e748849d907871d149223","modified":1748507943151},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/markdown.styl","hash":"f5a431cd88fca7f328634e13eff50a55b34b734b","modified":1748507943150},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/tagcloud.styl","hash":"c452b18f1242c634c0e124a46414cbc7c65da494","modified":1748507943152},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/timeline.styl","hash":"ab1901de4acfe89b642cd721d7d08b1b0009661b","modified":1748507943153},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/toc.styl","hash":"f290d98a4d721b523b0c972b7de61a86b05b1086","modified":1748507943153},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/banner.styl","hash":"f49a123a61cb02c65eebb79adefae9a6f8b8e2fc","modified":1748507943117},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/widgets.styl","hash":"7d383e58d54bf40806027fa22ab0ba70b5ab4fde","modified":1748507943155},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/about.styl","hash":"cdaf1ccd782db961cecda0802c94dabe27656731","modified":1748507943117},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/button.styl","hash":"19469c881d8798916ea45ec11ecd5348146e7927","modified":1748507943118},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/chat.styl","hash":"6bbb0fbec4dc12c7dbdf13c4a1b79cb1da1dc5e3","modified":1748507943122},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/checkbox.styl","hash":"1cd33e27fd539ed2a6cb41d4fc59294f1dd315b4","modified":1748507943123},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/copy.styl","hash":"2e00b4923bf8a4cf1b742d19cf26165cc65fcffe","modified":1748507943125},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/common.styl","hash":"a0a0e36d7672271147853bae34eb15b1ad2f0eef","modified":1748507943124},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/emoji.styl","hash":"100d2e0c43496464dd97fa83fa3e603e68bf30e9","modified":1748507943125},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/folding.styl","hash":"84eb11a5a5808f3a4bd0985d97a7b108a36fd044","modified":1748507943127},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/frame.styl","hash":"f8621b5a155ea78c5828e7ccbd1dfe6a72c9733c","modified":1748507943127},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/folders.styl","hash":"2eae18b521a613a19dd6399dcb5504f843dcbb88","modified":1748507943126},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/gallery.styl","hash":"52be8d049ce7533084aa3a6f361b4f365086af02","modified":1748507943129},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/friends.styl","hash":"4a3ac25b18e21c39f2921a40a727e457383c14c8","modified":1748507943128},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/ghcard.styl","hash":"98a50d3fab79ce03dd7f161fe3442d803712c284","modified":1748507943130},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/grid.styl","hash":"606311fa8326152f99fc721284a09e06490d0cca","modified":1748507943130},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/icon.styl","hash":"ea5372d1042db221f6c3ce5a31e18153c5e00d39","modified":1748507943132},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/hashtag.styl","hash":"0e2e74fcff5c30be9533e451a1c06ed1477dc9aa","modified":1748507943131},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/image.styl","hash":"beb0eb953d11489d4eaf16282784625062c81d9f","modified":1748507943132},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/index.styl","hash":"d76245514a5a0aecb65120b7117cd125a70617fb","modified":1748507943133},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/inline-labels.styl","hash":"96aad4c7710ed7097842fab77473b66a298b6e3f","modified":1748507943135},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/link.styl","hash":"b91bb69a2f84567f87c2665c3dbaeb8831487185","modified":1748507943136},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/mark.styl","hash":"1227da0705c294abab7030439d1e505c6b304ccf","modified":1748507943137},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/media.styl","hash":"61541156e59cd946b86626b4b2af0a2f24546f25","modified":1748507943137},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/navbar.styl","hash":"c2c3da16355f2dfd316edd11d9f2f2c50bc5299c","modified":1748507943138},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/note.styl","hash":"5e59f5ab728c2ad5b5e4e06b0dd694407bb14096","modified":1748507943139},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/okr.styl","hash":"0c2d281e90c8cb1a0de5ff516dca0e08ae7db141","modified":1748507943139},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/override.styl","hash":"6a31ef8c4dc7caa655ed7d852100abb2711ab5ac","modified":1748507943140},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/poetry.styl","hash":"6d15463121a741b69249318cadabf4bd06b4b3c6","modified":1748507943142},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/quot.styl","hash":"15c6726b2ea1d5ff7a12a310766145dffde4e778","modified":1748507943142},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/tabs.styl","hash":"70c1c2898e48473c66bad024235a6e62620d4efa","modified":1748507943143},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/sites.styl","hash":"512c15c37b43df4c7046a033b44171b5e61303b6","modified":1748507943142},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/comments/artalk.styl","hash":"279d7185e0ea65a8f5e1f783eaa3f83bc7bf3555","modified":1748507943156},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/timeline.styl","hash":"a5ef35db9c54905770c0ab68471ec054b0a83d9e","modified":1748507943144},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/toc.styl","hash":"18577b1c775f14da4b70cf3a8db56aa229f733c8","modified":1748507943145},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/comments/utterances.styl","hash":"be43f728d9515acaf050fbb3eed83cfefa2fe702","modified":1748507943159},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/comments/beaudar.styl","hash":"e9800f67a650f1c022aee494768e05da76e6a6b7","modified":1748507943157},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/comments/twikoo.styl","hash":"c30662f7635bbfd7b4ecde949fdec40aee4b6bce","modified":1748507943158},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/comments/waline.styl","hash":"9efd82d46da9bb4adb09f7ad1eea31a599608163","modified":1748507943160},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/breadcrumb/blog.ejs","hash":"0e3ff0a54e75acf562fd06d3d2c3ea03e0df7e81","modified":1748507943161},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/read/paper.styl","hash":"e35b61ab74124a019f8a4c06f8611ddd671df35c","modified":1748507943164},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/breadcrumb/page.ejs","hash":"66fca0ad5ae3ceaa8fa1f698713c4882fc0341c3","modified":1748507943162},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/breadcrumb/wiki.ejs","hash":"c878619b0e8835e9a53a3b460ab5c707e9a3fb61","modified":1748507943163},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/breadcrumb/note.ejs","hash":"815962a80cbcfe242339e1461707455a776b11dd","modified":1748507943161},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/read/reel.styl","hash":"2f129dd75e98406bbcc0b94d5bca448f6531aaf3","modified":1748507943165},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/chat.js","hash":"94b3510f16da7f27fd9cceb99ba9c61f314ddc74","modified":1748507942994},{"_id":"public/search.json","hash":"866766a3b7b583d2b2f26d2fa3baff657f880f1a","modified":1759665087048},{"_id":"public/explore/index.html","hash":"6b231ea2eb18a8cf04513457177e0b672a633d8d","modified":1759665087048},{"_id":"public/wiki/index.html","hash":"58a11771f059fbf24542b4c6bdadcee22e1ef18d","modified":1759665087048},{"_id":"public/404.html","hash":"ca39e609ce8134354251eac459c85a6398cceb80","modified":1759665087048},{"_id":"public/wiki/Seckill/1-秒杀项目1.0-丢失更新和锁失效.html","hash":"275d90b4e43bd3614eca2c8ab05080ef1452b551","modified":1759665087048},{"_id":"public/friends/index.html","hash":"6c94801d40f3ff2942fc095ec91e8e5d36df8d25","modified":1759665087048},{"_id":"public/wiki/Seckill/1-秒杀项目1.2-流量控制.html","hash":"d734f10e7049801e8ee2f3110543680920946860","modified":1759665087048},{"_id":"public/wiki/Seckill/1-秒杀项目1.1-读写分离.html","hash":"9d8a9d85dbaaa1b2242a0b9ac60bd056dbb0e54e","modified":1759665087048},{"_id":"public/wiki/Seckill/1-秒杀项目1.3-异步处理和优化.html","hash":"3dc9b8a584fee80c93900fa1347499f93b0d9bb5","modified":1759665087048},{"_id":"public/wiki/Seckill/1-秒杀项目2.0-Redis机制.html","hash":"f59f09bb43188212e8d71de5d674c17c5649697d","modified":1759665087048},{"_id":"public/2025/10/05/1-秒杀项目2.0-Redis机制/index.html","hash":"6865cc783295113d6582c3e51a58de8cb92acf93","modified":1759665087048},{"_id":"public/2025/10/03/1-秒杀项目1.3-异步处理和优化/index.html","hash":"229aaf84ebb97a2900b5477ebc1ec3b8ad2bbb9b","modified":1759665087048},{"_id":"public/2025/10/03/1-秒杀项目1.2-流量控制/index.html","hash":"179fdc165601e4155496b1edc76604105cc17f35","modified":1759665087048},{"_id":"public/2025/10/01/1-秒杀项目1.1-读写分离/index.html","hash":"d62b5d9f8a338cea374e1d2e14cdbd10e2de602f","modified":1759665087048},{"_id":"public/2025/09/25/1-秒杀项目1.0-丢失更新和锁失效/index.html","hash":"a79f93d7afab553ca529214dde5a50e8a5bea52d","modified":1759665087048},{"_id":"public/2025/09/12/论文阅读-1/index.html","hash":"a6d509e50a8537cb1d913c08c953d0fec47b4784","modified":1759665087048},{"_id":"public/2025/05/31/从零开始搭建个人博客/index.html","hash":"aabb2b8e75ccca20fb3f1290cf80db89e59dc458","modified":1759665087048},{"_id":"public/archives/index.html","hash":"a807dee1872f0477ff7e0eb507e321d7b832b2f0","modified":1759665087048},{"_id":"public/archives/2025/index.html","hash":"f1b15a1316216166d4acc47a29d39c9ca825497f","modified":1759665087048},{"_id":"public/archives/2025/05/index.html","hash":"1d571e08ca89e214e83bcadcfbedffd906b945f7","modified":1759665087048},{"_id":"public/archives/2025/09/index.html","hash":"b378e73b71fa54965b3237e7325238b8539a1721","modified":1759665087048},{"_id":"public/archives/2025/10/index.html","hash":"50dd6d530e0efe4e6c6417f948c0fb3437d4f647","modified":1759665087048},{"_id":"public/tags/Spring-Boot/index.html","hash":"fa28a217f3a78fb97a1acc1db57052b9b567c93a","modified":1759665087048},{"_id":"public/tags/高并发/index.html","hash":"6e3c3e258d4e3d04b0e5b76f9b366ba2124f6294","modified":1759665087048},{"_id":"public/tags/JUC/index.html","hash":"0be636a1dd64c67a7e2731ee3af0e9f6390a5554","modified":1759665087048},{"_id":"public/index.html","hash":"762868ce6e6c5ff057083d6dd14ed4cd312d7feb","modified":1759665087048},{"_id":"public/tags/hexo/index.html","hash":"1e7735306b0ea9ea0ebbf9720679516fde33cfde","modified":1759665087048},{"_id":"public/tags/vercel/index.html","hash":"d47ea4b5eb837ec1e6005298dbffadb63e8359cf","modified":1759665087048},{"_id":"public/tags/stellar/index.html","hash":"5f4648a48c0b743d23220db394d6e7d78d3250d6","modified":1759665087048},{"_id":"public/tags/thesis/index.html","hash":"9019ad90739f6a2bc3fddf6c2c59b3457c10b356","modified":1759665087048},{"_id":"public/tags/academic/index.html","hash":"577a3816e16d28527197e064d8d4ffd11e2471dc","modified":1759665087048},{"_id":"public/categories/项目实战/index.html","hash":"96589b1839fcf4f1047ceaca80dd86c5e34d979c","modified":1759665087048},{"_id":"public/categories/blog搭建/index.html","hash":"014f6851d404a504373b0ca0ce295dadb5bd6e72","modified":1759665087048},{"_id":"public/categories/index.html","hash":"80db11fe9a5beb528ebb7a5bd7cba18fc892fddd","modified":1759665087048},{"_id":"public/tags/index.html","hash":"bea518ff75c7857e4cb871e4e7e42056fe8a2357","modified":1759665087048},{"_id":"public/categories/论文阅读/index.html","hash":"ff98f9484ad485f83d5b366507d2374e01639549","modified":1759665087048},{"_id":"public/wiki/tags/秒杀系统/index.html","hash":"39075923f4df2a6a81aeddca228d34cfc362de23","modified":1759665087048},{"_id":"public/js/main.js","hash":"41ddd41a9f1896ad548a8eaa8610da2f823009ba","modified":1759665087048},{"_id":"public/css/main.css","hash":"8f123131c44dcb8fb173a593b8a1be1b13d331d0","modified":1759665087048},{"_id":"public/js/services/artalk_latest_comment.js","hash":"29a6ca87b9dac4708164f31d0f99a1c6bebd38ea","modified":1759665087048},{"_id":"public/js/plugins/download-file.js","hash":"dd0cb9ea1bc6464567a96ee47c35b43d7eb086e8","modified":1759665087048},{"_id":"public/js/plugins/copycode.js","hash":"af017eeaaf12e78b1700d78b199b4368d001a193","modified":1759665087048},{"_id":"public/js/plugins/video.js","hash":"e87d271175dfb4763c9c017046f7d857c7a3ba56","modified":1759665087048},{"_id":"public/js/plugins/voice.js","hash":"4c865125754c98dd61de28ad88c831be3d673a35","modified":1759665087048},{"_id":"public/js/services/friends.js","hash":"91e408da632efe630a2c2048868c70c425e284da","modified":1759665087048},{"_id":"public/js/services/fcircle.js","hash":"add550bfb204a2057661d4d6630d78ebf485754d","modified":1759665087048},{"_id":"public/js/services/ghinfo.js","hash":"94b86ce42dd765e9a4c1befa72ee9648d7ec6f88","modified":1759665087048},{"_id":"public/js/services/giscus_latest_comment.js","hash":"2c9c9176f4d35b5c036c6723627d693345cbbf38","modified":1759665087048},{"_id":"public/js/search/local-search.js","hash":"cf710d711fcbc21122cdc01edd43d9b4087f1b9d","modified":1759665087048},{"_id":"public/js/search/algolia-search.js","hash":"94dae768b275b12753553553b3338fca4973a1e3","modified":1759665087048},{"_id":"public/js/services/mdrender.js","hash":"947f476e6dd8ca6a75f87f6ac6f2fbb2b0861e82","modified":1759665087048},{"_id":"public/js/services/siteinfo.js","hash":"74da788f29862604cd53f6b82b036ff56c715d21","modified":1759665087048},{"_id":"public/js/services/sites.js","hash":"b68ad17f1f8ae64819374824f29fe6ab29ddfb9a","modified":1759665087048},{"_id":"public/js/services/memos.js","hash":"2d430c7ae4d9f3a44653eda0214d18fb60bcfed1","modified":1759665087048},{"_id":"public/js/services/timeline.js","hash":"41cde82427726c3366b64b1f54f1aed9bc20fcf1","modified":1759665087048},{"_id":"public/js/services/waline_latest_comment.js","hash":"7520f62dcf3b991b99e37b8c33a7d6a89e7f2da5","modified":1759665087048},{"_id":"public/js/services/weibo.js","hash":"437e631539f3a50cf8b46ff17008404609c1c481","modified":1759665087048},{"_id":"public/js/services/twikoo_latest_comment.js","hash":"d5c7bb0b9888333c2e10dedea8bfc19df5454d58","modified":1759665087048}],"Category":[{"name":"项目实战","_id":"cmgdn5rh000040wuzg0p0cgre"},{"name":"blog搭建","_id":"cmgdn5rh7000o0wuzc36k90tm"},{"name":"论文阅读","_id":"cmgdn5rh8000t0wuz3v3b4ktb"}],"Data":[{"_id":"widgets","data":{"timeline":{"layout":"timeline","title":"近期动态","api":"https://api.github.com/repos/xaoxuu/blog-timeline/issues","user":"xaoxuu"},"timeline_seckill_more":{"layout":"timeline","title":"Seckill System 近期动态","api":"https://api.github.com/repos/bupt-Lucy/seckill-system/issues","user":"bupt-Lucy","hide":"footer"}}},{"_id":"wiki/Seckill","data":{"name":"Seckill System","title":"Seckill System - ing","subtitle":"Seckill System | 进化中","tags":"秒杀系统","icon":"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509302201141.jpg","description":"Seckill System 进化中。","repo":"bupt-Lucy/seckill-system","search":{"filter":"/wiki/Seckill/","placeholder":"在 Seckill System 中搜索..."},"leftbar":["tree","related"],"base_dir":"/wiki/Seckill/","tree":["1-秒杀项目1.0-丢失更新和锁失效","1-秒杀项目1.1-读写分离","1-秒杀项目1.2-流量控制","1-秒杀项目1.3-异步处理和优化","1-秒杀项目2.0-Redis机制"]}},{"_id":"wiki","data":["Seckill"]}],"Page":[{"title":"explore","date":"2025-09-30T13:10:35.000Z","_content":"\n{% timeline %}\n<!-- node 2025 年 10 月 1 日 -->\n秒杀系统的第二篇博客，并且探索了博客的很多新玩法。\n<!-- node 2025 年 9 月 25 日 -->\n发布秒杀系统的第一篇博客，希望可以坚持下去，一个新的开始！\n{% endtimeline %}\n\n\n{% okr o1 %}\n\n2025年的小目标：项目线、八股线、算法线推进到90%\n剩下10%在研一下学期找实习之前（1月、2月）完成\n\n<!-- okr kr1 percent:0.03 -->\n项目线\n{% tabs align:left %}\n<!-- tab 秒杀系统 -->\n{% checkbox V1.0 初始版本，无并发控制 %}\n{% checkbox V1.1+ 结合JUC进行优化 %}\n{% checkbox ... %}\n<!-- tab 项目2 -->\n初步计划，在项目2中融合agent内容。\n{% endtabs %}\n\n<!-- okr kr2 percent:0.01  -->\n八股线\n- 结合秒杀系统这个项目推进Java八股的学习\n\n<!-- okr kr3 percent:0.01  -->\n算法线\n{% checkbox 数组/链表 %}\n{% checkbox 哈希表/字符串 %}\n{% checkbox 双指针法/栈与队列 %}\n{% checkbox 二叉树 %}\n{% checkbox 回溯算法 %}\n{% checkbox 贪心算法 %}\n{% checkbox 动态规划 %}\n{% checkbox 单调栈 %}\n{% checkbox 图论 %}\n\n<!-- okr kr-4 percent:0.01 -->\n科研线\n- AIGC视频检测系统（暂时课题）\n  - 前沿论文阅读\n- 基础理论书\n\n<!-- okr kr-4 percent:0.1 -->\n生活线\n- 健康\n  - 作息\n  - 精神\n- hobby\n\n{% endokr %}\n\n","source":"explore/index.md","raw":"---\ntitle: explore\ndate: 2025-09-30 21:10:35\n---\n\n{% timeline %}\n<!-- node 2025 年 10 月 1 日 -->\n秒杀系统的第二篇博客，并且探索了博客的很多新玩法。\n<!-- node 2025 年 9 月 25 日 -->\n发布秒杀系统的第一篇博客，希望可以坚持下去，一个新的开始！\n{% endtimeline %}\n\n\n{% okr o1 %}\n\n2025年的小目标：项目线、八股线、算法线推进到90%\n剩下10%在研一下学期找实习之前（1月、2月）完成\n\n<!-- okr kr1 percent:0.03 -->\n项目线\n{% tabs align:left %}\n<!-- tab 秒杀系统 -->\n{% checkbox V1.0 初始版本，无并发控制 %}\n{% checkbox V1.1+ 结合JUC进行优化 %}\n{% checkbox ... %}\n<!-- tab 项目2 -->\n初步计划，在项目2中融合agent内容。\n{% endtabs %}\n\n<!-- okr kr2 percent:0.01  -->\n八股线\n- 结合秒杀系统这个项目推进Java八股的学习\n\n<!-- okr kr3 percent:0.01  -->\n算法线\n{% checkbox 数组/链表 %}\n{% checkbox 哈希表/字符串 %}\n{% checkbox 双指针法/栈与队列 %}\n{% checkbox 二叉树 %}\n{% checkbox 回溯算法 %}\n{% checkbox 贪心算法 %}\n{% checkbox 动态规划 %}\n{% checkbox 单调栈 %}\n{% checkbox 图论 %}\n\n<!-- okr kr-4 percent:0.01 -->\n科研线\n- AIGC视频检测系统（暂时课题）\n  - 前沿论文阅读\n- 基础理论书\n\n<!-- okr kr-4 percent:0.1 -->\n生活线\n- 健康\n  - 作息\n  - 精神\n- hobby\n\n{% endokr %}\n\n","updated":"2025-10-03T05:51:56.777Z","path":"explore/index.html","comments":1,"layout":"page","_id":"cmgdn5rgt00000wuz90d30zd2","content":"<div class=\"tag-plugin timeline\"><div class=\"timenode\" index=\"0\"><div class=\"header\">2025 年 10 月 1 日</div><div class=\"body fs14\"><p>秒杀系统的第二篇博客，并且探索了博客的很多新玩法。</p></div></div><div class=\"timenode\" index=\"1\"><div class=\"header\">2025 年 9 月 25 日</div><div class=\"body fs14\"><p>发布秒杀系统的第一篇博客，希望可以坚持下去，一个新的开始！</p></div></div></div>\n\n\n<div class=\"tag-plugin colorful okr\" >\n  <div class=\"okr-item o\" id=\"okr-o1\">\n    <div class=\"okr-left\">\n      <span class=\"title\">O1</span>\n    </div>\n    <div class=\"okr-center\">\n      <span class=\"title\">2025年的小目标：项目线、八股线、算法线推进到90%</span>\n      <div class=\"note\"><p>剩下10%在研一下学期找实习之前（1月、2月）完成</p></div>\n    </div>\n    <div class=\"okr-right colorful\" color=\"blue\">\n      <div class=\"labels\">\n        <span class=\"status label\">正常</span>\n        <span class=\"status percent\">3%</span>\n      </div>\n      <div class=\"progress\">\n        <div class=\"fill\" style=\"width:3%;\"></div>\n      </div>\n    </div>\n  </div>\n  \n  <div class=\"okr-item kr\" id=\"okr-kr1\">\n    <div class=\"okr-left\">\n      <span class=\"title\">KR1</span>\n    </div>\n    <div class=\"okr-center\">\n      <span class=\"title\">项目线</span>\n      <div class=\"note\"><div class=\"tag-plugin tabs\" align=\"left\"id=\"tab_1\"><div class=\"nav-tabs\"><div class=\"tab active\"><a href=\"#tab_1-1\">秒杀系统</a></div><div class=\"tab\"><a href=\"#tab_1-2\">项目2</a></div></div><div class=\"tab-content\"><div class=\"tab-pane active\" id=\"tab_1-1\"><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>V1.0 初始版本，无并发控制</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>V1.1+ 结合JUC进行优化</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>...</span></div></div><div class=\"tab-pane\" id=\"tab_1-2\"><p>初步计划，在项目2中融合agent内容。</p></div></div></div></div>\n    </div>\n    <div class=\"okr-right colorful\" color=\"blue\">\n      <div class=\"labels\">\n        <span class=\"status label\">正常</span>\n        <span class=\"status percent\">3%</span>\n      </div>\n      <div class=\"progress\">\n        <div class=\"fill\" style=\"width:3%;\"></div>\n      </div>\n    </div>\n  </div>\n  \n  <div class=\"okr-item kr\" id=\"okr-kr2\">\n    <div class=\"okr-left\">\n      <span class=\"title\">KR2</span>\n    </div>\n    <div class=\"okr-center\">\n      <span class=\"title\">八股线</span>\n      <div class=\"note\"><ul><li>结合秒杀系统这个项目推进Java八股的学习</li></ul></div>\n    </div>\n    <div class=\"okr-right colorful\" color=\"blue\">\n      <div class=\"labels\">\n        <span class=\"status label\">正常</span>\n        <span class=\"status percent\">1%</span>\n      </div>\n      <div class=\"progress\">\n        <div class=\"fill\" style=\"width:1%;\"></div>\n      </div>\n    </div>\n  </div>\n  \n  <div class=\"okr-item kr\" id=\"okr-kr3\">\n    <div class=\"okr-left\">\n      <span class=\"title\">KR3</span>\n    </div>\n    <div class=\"okr-center\">\n      <span class=\"title\">算法线</span>\n      <div class=\"note\"><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>数组/链表</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>哈希表/字符串</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>双指针法/栈与队列</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>二叉树</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>回溯算法</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>贪心算法</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>动态规划</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>单调栈</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>图论</span></div></div>\n    </div>\n    <div class=\"okr-right colorful\" color=\"blue\">\n      <div class=\"labels\">\n        <span class=\"status label\">正常</span>\n        <span class=\"status percent\">1%</span>\n      </div>\n      <div class=\"progress\">\n        <div class=\"fill\" style=\"width:1%;\"></div>\n      </div>\n    </div>\n  </div>\n  \n  <div class=\"okr-item kr\" id=\"okr-kr-4\">\n    <div class=\"okr-left\">\n      <span class=\"title\">KR-4</span>\n    </div>\n    <div class=\"okr-center\">\n      <span class=\"title\">科研线</span>\n      <div class=\"note\"><ul><li>AIGC视频检测系统（暂时课题）<ul><li>前沿论文阅读</li></ul></li><li>基础理论书</li></ul></div>\n    </div>\n    <div class=\"okr-right colorful\" color=\"blue\">\n      <div class=\"labels\">\n        <span class=\"status label\">正常</span>\n        <span class=\"status percent\">1%</span>\n      </div>\n      <div class=\"progress\">\n        <div class=\"fill\" style=\"width:1%;\"></div>\n      </div>\n    </div>\n  </div>\n  \n  <div class=\"okr-item kr\" id=\"okr-kr-4\">\n    <div class=\"okr-left\">\n      <span class=\"title\">KR-4</span>\n    </div>\n    <div class=\"okr-center\">\n      <span class=\"title\">生活线</span>\n      <div class=\"note\"><ul><li>健康<ul><li>作息</li><li>精神</li></ul></li><li>hobby</li></ul></div>\n    </div>\n    <div class=\"okr-right colorful\" color=\"blue\">\n      <div class=\"labels\">\n        <span class=\"status label\">正常</span>\n        <span class=\"status percent\">10%</span>\n      </div>\n      <div class=\"progress\">\n        <div class=\"fill\" style=\"width:10%;\"></div>\n      </div>\n    </div>\n  </div>\n  </div>\n\n","excerpt":"","more":"<div class=\"tag-plugin timeline\"><div class=\"timenode\" index=\"0\"><div class=\"header\">2025 年 10 月 1 日</div><div class=\"body fs14\"><p>秒杀系统的第二篇博客，并且探索了博客的很多新玩法。</p></div></div><div class=\"timenode\" index=\"1\"><div class=\"header\">2025 年 9 月 25 日</div><div class=\"body fs14\"><p>发布秒杀系统的第一篇博客，希望可以坚持下去，一个新的开始！</p></div></div></div>\n\n\n<div class=\"tag-plugin colorful okr\" >\n  <div class=\"okr-item o\" id=\"okr-o1\">\n    <div class=\"okr-left\">\n      <span class=\"title\">O1</span>\n    </div>\n    <div class=\"okr-center\">\n      <span class=\"title\">2025年的小目标：项目线、八股线、算法线推进到90%</span>\n      <div class=\"note\"><p>剩下10%在研一下学期找实习之前（1月、2月）完成</p></div>\n    </div>\n    <div class=\"okr-right colorful\" color=\"blue\">\n      <div class=\"labels\">\n        <span class=\"status label\">正常</span>\n        <span class=\"status percent\">3%</span>\n      </div>\n      <div class=\"progress\">\n        <div class=\"fill\" style=\"width:3%;\"></div>\n      </div>\n    </div>\n  </div>\n  \n  <div class=\"okr-item kr\" id=\"okr-kr1\">\n    <div class=\"okr-left\">\n      <span class=\"title\">KR1</span>\n    </div>\n    <div class=\"okr-center\">\n      <span class=\"title\">项目线</span>\n      <div class=\"note\"><div class=\"tag-plugin tabs\" align=\"left\"id=\"tab_1\"><div class=\"nav-tabs\"><div class=\"tab active\"><a href=\"#tab_1-1\">秒杀系统</a></div><div class=\"tab\"><a href=\"#tab_1-2\">项目2</a></div></div><div class=\"tab-content\"><div class=\"tab-pane active\" id=\"tab_1-1\"><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>V1.0 初始版本，无并发控制</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>V1.1+ 结合JUC进行优化</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>...</span></div></div><div class=\"tab-pane\" id=\"tab_1-2\"><p>初步计划，在项目2中融合agent内容。</p></div></div></div></div>\n    </div>\n    <div class=\"okr-right colorful\" color=\"blue\">\n      <div class=\"labels\">\n        <span class=\"status label\">正常</span>\n        <span class=\"status percent\">3%</span>\n      </div>\n      <div class=\"progress\">\n        <div class=\"fill\" style=\"width:3%;\"></div>\n      </div>\n    </div>\n  </div>\n  \n  <div class=\"okr-item kr\" id=\"okr-kr2\">\n    <div class=\"okr-left\">\n      <span class=\"title\">KR2</span>\n    </div>\n    <div class=\"okr-center\">\n      <span class=\"title\">八股线</span>\n      <div class=\"note\"><ul><li>结合秒杀系统这个项目推进Java八股的学习</li></ul></div>\n    </div>\n    <div class=\"okr-right colorful\" color=\"blue\">\n      <div class=\"labels\">\n        <span class=\"status label\">正常</span>\n        <span class=\"status percent\">1%</span>\n      </div>\n      <div class=\"progress\">\n        <div class=\"fill\" style=\"width:1%;\"></div>\n      </div>\n    </div>\n  </div>\n  \n  <div class=\"okr-item kr\" id=\"okr-kr3\">\n    <div class=\"okr-left\">\n      <span class=\"title\">KR3</span>\n    </div>\n    <div class=\"okr-center\">\n      <span class=\"title\">算法线</span>\n      <div class=\"note\"><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>数组/链表</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>哈希表/字符串</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>双指针法/栈与队列</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>二叉树</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>回溯算法</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>贪心算法</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>动态规划</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>单调栈</span></div><div class=\"tag-plugin colorful checkbox\" ><input type=\"checkbox\"/><span>图论</span></div></div>\n    </div>\n    <div class=\"okr-right colorful\" color=\"blue\">\n      <div class=\"labels\">\n        <span class=\"status label\">正常</span>\n        <span class=\"status percent\">1%</span>\n      </div>\n      <div class=\"progress\">\n        <div class=\"fill\" style=\"width:1%;\"></div>\n      </div>\n    </div>\n  </div>\n  \n  <div class=\"okr-item kr\" id=\"okr-kr-4\">\n    <div class=\"okr-left\">\n      <span class=\"title\">KR-4</span>\n    </div>\n    <div class=\"okr-center\">\n      <span class=\"title\">科研线</span>\n      <div class=\"note\"><ul><li>AIGC视频检测系统（暂时课题）<ul><li>前沿论文阅读</li></ul></li><li>基础理论书</li></ul></div>\n    </div>\n    <div class=\"okr-right colorful\" color=\"blue\">\n      <div class=\"labels\">\n        <span class=\"status label\">正常</span>\n        <span class=\"status percent\">1%</span>\n      </div>\n      <div class=\"progress\">\n        <div class=\"fill\" style=\"width:1%;\"></div>\n      </div>\n    </div>\n  </div>\n  \n  <div class=\"okr-item kr\" id=\"okr-kr-4\">\n    <div class=\"okr-left\">\n      <span class=\"title\">KR-4</span>\n    </div>\n    <div class=\"okr-center\">\n      <span class=\"title\">生活线</span>\n      <div class=\"note\"><ul><li>健康<ul><li>作息</li><li>精神</li></ul></li><li>hobby</li></ul></div>\n    </div>\n    <div class=\"okr-right colorful\" color=\"blue\">\n      <div class=\"labels\">\n        <span class=\"status label\">正常</span>\n        <span class=\"status percent\">10%</span>\n      </div>\n      <div class=\"progress\">\n        <div class=\"fill\" style=\"width:10%;\"></div>\n      </div>\n    </div>\n  </div>\n  </div>\n\n"},{"title":"wiki","date":"2025-09-30T13:10:28.000Z","_content":"","source":"wiki/index.md","raw":"---\ntitle: wiki\ndate: 2025-09-30 21:10:28\n---\n","updated":"2025-09-30T13:15:10.569Z","path":"wiki/index.html","comments":1,"layout":"page","_id":"cmgdn5rgy00020wuz1o0whwdu","content":"","excerpt":"","more":""},{"wiki":"Seckill","title":"1-秒杀项目1.0-丢失更新和锁失效","tags":["Spring Boot","高并发"],"categories":["项目实战"],"poster":{"topic":"标题上方的小字","headline":"大标题","caption":"标题下方的小字","color":"标题颜色"},"date":"2025-09-25T01:11:57.000Z","description":"重新起航版","cover":null,"banner":null,"sticky":null,"mermaid":null,"katex":null,"mathjax":null,"topic":null,"author":null,"references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n\n### 一、项目概述\n  - 项目名称：高并发-秒杀系统（1.0 单体应用原型）\n  - 项目目标：从零开始设计并实现一个功能完备的秒-杀业务原型，旨在深入理解高并发场景下常见的技术挑战，如数据一致性（超卖、重复下单）、性能瓶颈等，并通过多种技术手段进行分析和优化。\n  - 技术栈：\n    - 后端框架：Spring Boot\n    - 数据持久层：Spring Data JPA,Hibernate\n    - 数据库：MYSQL\n    - 构建工具：Maven\n    - 测试工具：JMeter\n\n### 二、项目搭建\n  #### 1. 环境搭建和初始化\n  - 使用 Spring Initializr 快速搭建了项目骨架，并集成 Spring Web、Spring Data JPA、MySQL Driver 等核心依赖。\n    > Spring Web:是构建Web应用程序的核心模块。内嵌Web服务器，提供Spring MVC框架，用于HTTP报文处理能力。负责监听网络接口，接受所有外来的HTTP请求，然后根据请求的URL和方法，精准的转接给后台相应的Controller去处理。\n    > Spring Data JPA：是一个用来极大简化数据库访问的框架。可以自动化SQL，进行对象-关系映射（ORM），并进行简化的自定义查询。\n  - 在 application.properties 中完成了数据库连接池的基础配置。\n  #### 2. 核心业务\n  - 设计核心数据表\n    - 商品表\n    ```SQL\n    CREATE TABLE `product` (\n    `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '商品ID',\n    `name` VARCHAR(100) NOT NULL COMMENT '商品名称',\n    `title` VARCHAR(255) NOT NULL COMMENT '商品标题',\n    `image` VARCHAR(255) DEFAULT '' COMMENT '商品图片URL',\n    `price` DECIMAL(10, 2) NOT NULL COMMENT '秒杀价格',\n    `stock` INT NOT NULL COMMENT '库存数量',\n    `start_time` DATETIME NOT NULL COMMENT '秒杀开始时间',\n    `end_time` DATETIME NOT NULL COMMENT '秒杀结束时间',\n    PRIMARY KEY (`id`)\n    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n    ```\n    - 订单表\n    在订单表的设计中加入了 (user_id, product_id)的唯一索引，即每个用户只能下一单。\n    ```SQL\n    CREATE TABLE `seckill_order` (\n    `id` BIGINT NOT NULL AUTO_INCREMENT,\n    `user_id` BIGINT NOT NULL COMMENT '用户ID',\n    `product_id` BIGINT NOT NULL COMMENT '商品ID',\n    `order_price` DECIMAL(10, 2) NOT NULL COMMENT '订单成交价格',\n    `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    PRIMARY KEY (`id`),\n    UNIQUE KEY `idx_user_product` (`user_id`, `product_id`) COMMENT '唯一索引，防止同一用户重复秒杀同一商品'\n    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n     ```\n\n#### 3. 基础功能实现\n- 采用标准的MVC分层架构，创建Controller, Service, Repository 层。\n  > Controller：作为应用的入口，直接处理外部的HTTP请求。\n  > Service：实现应用的核心业务逻辑。\n  > DAO：负责与数据库进行直接交互，完成数据的持久化操作。\n  > Model/Entity：数据的载体，定义了应用中的核心领域对象。\n\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251103013.png 请求过程 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251103013.png%}\n\n- 实现秒杀接口的核心业务逻辑。\n\n```Java\n@Transactional\npublic String processSeckill(Long productId, Long userId) {\n// 1. 从数据库读取 Product 对象到内存\nOptional<Product> productOpt = productRepository.findById(productId);\nProduct product = productOpt.get(); // 假设此时读到的 stock 是 100\n\n// ... 其他检查 ...\n\n// 2. 在内存中计算新库存\nproduct.setStock(product.getStock() - 1); // 内存中的 stock 变为 99\n\n// 3. 将内存中的 Product 对象保存回数据库\nproductRepository.save(product); \n\n// 4. 创建订单\nSeckillOrder order = new SeckillOrder();\n// ...\norderRepository.save(order);\n\nreturn \"秒杀成功！\";\n}\n```\n- 在初始版本中不加入任何的并发控制，后续会通过压力测试来暴露和分析最原始的并发问题。\n\n### 三、并发问题的分析与演进\n  #### 1. 库存设置与JMeter设置\n  - stock设置为100\n  - JMeter\n    - 线程数：200\n    - 1秒内同时发出200个并发请求\n    - 计数器自增UserId\n  #### 2. 实验结果\n  - 订单数增加了200个但是库存数只减少了20个\n    {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251245658.png 订单数 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251245658.png%}\n    {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251246389.png 库存数 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251246389.png%}\n\n  - 分析原因：事务和内存状态————Spring的@Transaction注解和JPA的工作机制\n    - 一级缓存：当第一个请求通过findById加载了ID为1的商品后，这个product对象会被放入当前事务的一级缓存中。\n    - 事务提交时才真正更新：productRepository.save(product)这个操作，并不是立即向数据库发送UPDATE语句，而要等到整个processSeckill方法执行完毕、事务准备提交时，才会生成并发送给数据库。\n  - 丢失的更新（stock=80）：前十个线程有可能都加载到了还没有提交的product，即此时读到的stock依然是100，后面的九次更新覆盖了第一次更新，所以最终结果和只更新一次是完全一样的（stock变成了99）。每次都有一批线程在竞争，但最后只有一个线程的更新“活”到了最后，导致库存最终只减少了大约20次。\n  - 订单的正常建立（新增order数=200）：orderRepository.save(order)这个操作，因为每个订单的主键都是自增的，并且（user_id,product_id）的组合也是唯一的，所以每一次订单的插入都能成功。\n  #### 3. 改进\n  ##### 第一次尝试-在 processSeckill 方法上加 synchronized 锁\n    \n  - 预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。\n\n  ```Java\n    @Transactional\n    public synchronized  String processSeckill(Long productId, Long userId) {\n    // 1. 从数据库读取 Product 对象到内存\n    Optional<Product> productOpt = productRepository.findById(productId);\n    Product product = productOpt.get(); // 假设此时读到的 stock 是 100\n\n    // ... 其他检查 ...\n\n    // 2. 在内存中计算新库存\n    product.setStock(product.getStock() - 1); // 内存中的 stock 变为 99\n\n    // 3. 将内存中的 Product 对象保存回数据库\n    productRepository.save(product); \n\n    // 4. 创建订单\n    SeckillOrder order = new SeckillOrder();\n    // ...\n    orderRepository.save(order);\n\n    return \"秒杀成功！\";\n    }\n  ```\n  - 结果：数据依然错误，订单数为200，库存数为79,而吞吐量和平均响应时间没有发生明显变化。\n  - 分析：@Transaction 与 synchronized 的冲突\n    - 当给一个方法加上@Transaction注解时，Spring为了能够控制事务的开启、提交和回滚，并不会让你直接调用这个方法，相反，Spring会在运行时创建一个该类的代理对象proxy。\n    - 事务先生效：即代理对象的同名方法会被触发，代理对象会先开启一个事务\n    - synchronized被绕过：它是Java原生关键字，作用于对象实例的锁，但Spring的代理机制在调用目标方法时，可能会导致锁机制失效，因为代理方法本身没有synchronized，调用父类（本身SeckillService）的方法时，锁的上下文可能已经丢失或不准确。\n  即，Spring的AOP代理与Java原生的锁关键字之间存在冲突，代理绕过了锁，导致synchronized锁机制未生效。\n\n  ##### 第二次尝试-在事务内使用ReentrantLock\n  - 预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。\n  ```Java\n    @Transactional\n    public String processSeckill(Long productId, Long userId) {  // 1. 事务由代理对象在这里开启\n        // 2. 在方法开始时手动加锁\n        lock.lock();\n        try {\n            // 所有业务逻辑都放在 try 块中\n            // 其他检查\n\n            product.setStock(product.getStock() - 1);\n            productRepository.save(product);\n\n            SeckillOrder order = new SeckillOrder();\n            // ...\n            orderRepository.save(order);\n\n            return \"秒杀成功！订单创建中...\";\n        } finally {\n            // 3. 【至关重要】在 finally 块中解锁，确保即使发生异常也能释放锁\n            lock.unlock();\n        }\n    }      // 4. 事务由代理对象在这里提交\n  ```\n  - 显示控制：lock.lock()是代码逻辑的一部分，在代理调用了实际方法之后，业务逻辑执行之前被调用。任何线程进入这个方法后，都必须先获取到这个锁才能继续执行。\n  - 安全释放：使用try...finally结构，确保无论业务逻辑是否成功，锁最终都会被释放，避免了“死锁”的风险。\n\n  - 结果：数据依然错误，订单数为200，库存数为79,而吞吐量和平均响应时间没有发生明显变化。\n  - 分析：锁的范围 VS 事务的范围\n    - 锁释放在前，事务提交在后，所以当线程A解锁后，UPDATE语句还没有提交进入数据库，而此时线程B立即取锁进入了方法，此时B读取到的库存数还是旧值。重演丢失更新问题。\n\n  ##### 第三次尝试-ReentrantLock + 手动事务\n  - 预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。\n\n  - 解决方案：将事务控制移入锁内\n    - 放弃@Transaction注解，因为这个注解无法精细控制提交时机，改用最经典、最原始的手动事务管理。\n    - 使用PlatformTransactionManager 来手动控制事务的开始、提交和回滚。将整个生命周期包裹在锁内。\n  ```Java\n    @Autowired\n    private PlatformTransactionManager transactionManager;\n\n    private final Lock lock = new ReentrantLock();\n\n    public String processSeckill(Long productId, Long userId) {\n        // 1. 上锁\n        lock.lock();\n        \n        DefaultTransactionDefinition def = new DefaultTransactionDefinition();\n        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n        // 2. 开启事务\n        TransactionStatus status = transactionManager.getTransaction(def);\n\n        try {\n            // ...所有业务逻辑，和之前一样\n            // 3. 【关键】在锁释放前，手动提交事务\n            transactionManager.commit(status);\n\n            return \"秒杀成功！订单创建中...\";\n        } catch (Exception e) {\n            //  如果发生任何异常，手动回滚事务\n            transactionManager.rollback(status);\n            // 将异常信息返回或记录日志\n            return e.getMessage(); \n        } finally {\n            // 4. 最后，释放锁\n            lock.unlock();\n        }\n    }\n  ```\n  - 结果:数据正确，库存为0，订单数为100，吞吐量没有下降，甚至比没有并发控制的1.0 版本还要高。\n  - 分析: 在高并发场景下，无序的并发混乱，有时远比有序的串行执行要慢。下表为初始版本和三次尝试版本的压测数据。\n\n| Label                                  | 样本 | 平均值 | 中位数 | 90% 百分位 | 95% 百分位 | 99% 百分位 | 最小值 | 最大值 | 异常 % | 吞吐量 | 接收 KB/sec | 发送 KB/sec |\n| -------------------------------------- | ---- | ------ | ------ | ---------- | ---------- | ---------- | ------ | ------ | ------ | ------ | ----------- | ----------- |\n| 1.0秒杀系统                            | 200  | 740    | 810    | 1044       | 1078       | 1083       | 254    | 1084   | 0.00%  | 95.92  | 18.27       | 20.51       |\n| 2.0秒杀系统_添加关键字synchronized     | 200  | 578    | 598    | 744        | 763        | 767        | 79     | 831    | 0.00%  | 113.38 | 21.59       | 24.24       |\n| 2.0秒杀系统_手动添加锁ReentrantLock    | 200  | 638    | 663    | 819        | 837        | 879        | 237    | 891    | 0.00%  | 105.76 | 20.14       | 22.62       |\n| 2.0秒杀系统_不使用@Transaction手动加锁 | 200  | 905    | 1024   | 1148       | 1160       | 1175       | 203    | 1178   | 0.00%  | 100.45 | 18.25       | 21.48       |\n  \n  - 无锁版虽然看似并行，但造成了数据库层面大量的行锁竞争、唯一键冲突错误、事务回滚，这些“无效”的数据库操作成为了真正的性能瓶颈。而加锁后的版本，虽然在应用层是串行的，但它保护了数据库，向数据库发送的是一连串干净、有效的请求，避免了数据库的内部冲突和错误处理开销，因此整体系统的有效吞吐量反而更高。\n\n### 学学八股\n  \n#### @Transaction注解 & 一个请求的生命周期\n- Controller接受请求，调用Service方法，但此时Service引用的是Spring的代理对象，而不是原始实例。代理对象的方法被触发，检查到方法上有@Transaction注解，代理对象向事务管理器（platformTransactionManager）请求开启一个新的事务。从数据库连接池中获取一个数据库连接，向MySQL服务器发送指令。此时一个数据库事务的“上下文”已经建立，但还没有任何实际的业务SQL被执行。在开启事务后，代理对象才会调用原始实例的方法，开始执行业务逻辑。但需要注意的是，这个阶段中是没有发生任何数据库操作的，只是告诉JPA的持久化上下文，标记了该对象，后续需要“留意”。\n- 所有代码都执行完毕后，到达return语句，准备将结果返回。此时代理对象接收到真实方法的返回值，因为没有捕获到任何异常，代理对象判断这次业务执行是成功的，通知事务管理器可以提交事务了。事务管理器执行数据库同步，在真正COMMIT之前，JPA会执行一次Flush，生成SQL语句，发送到MYSQL服务器并执行，直到COMMIT被成功执行了，这次更新才被永久地鞋屋数据库磁盘。\n- 代理对象将你方法的返回值传递给Controller，Controller再将其封装成HTTP响应返回给用户。\n\n\n#### 锁-初步\n1. Synchronized：Keyword、JVM内置的同步原语，简单、隐式的加锁和解锁机制。\n  - 使用方法：修饰实例方法、修饰静态方法、修饰代码块。\n  - 实现依赖于每个Java对象头部的Mark Word和JVM内部的Monitor对象监视器（当线程尝试获取锁时，JVM会执行Monitorenter字节码指令，尝试获得对象Monitor所有权。释放锁时即执行monitorexit）。\n  - 锁升级机制：偏向锁--->轻量级锁(当有第二个线程竞争时升级，竞争的线程通过自旋和CAS来尝试获取锁，不进入阻塞状态)--->重量级锁（竞争加剧，自旋失败，升级，未获取到锁的线程会被阻塞，由内核进行调度，性能开销最大）\n\n2. ReentrantLock：是JUC工具包的核心成员，显式加锁和解锁机制。\n  - 使用方法：标准的使用范式\n  ```Java\n    // 1. 在类中声明一个 Lock 实例\n    private final ReentrantLock lock = new ReentrantLock();\n         \n    public void someMethod() {\n    // 2. 在 try...finally 结构中进行加锁和解锁\n    lock.lock(); // 获取锁\n    try {\n    // 3. 保护的同步代码\n    } finally {\n    // 4. 必须在 finally 块中释放锁\n    lock.unlock();\n    }\n    }\n  ```\n  - 实现依赖于JUC的核心框架AQS，所有获取锁失败的线程，会被封装成节点放入一个CLH虚拟双向队列中进行排队等待。当锁被释放时，会从队列头部唤醒下一个等待的线程。整个过程都在用户态完成，避免了频繁的内核态切换。\n    > AQS 内部通过一个 `volatile` 的 `int` 类型的 `state` 变量来表示同步状态（0表示未锁定，>0表示已锁定），并使用 **CAS** 操作来原子性地修改这个 `state` 值。\n  - 功能丰富：等待可中断（等待锁的线程可被中断）、可实现公平锁（按线程请求的顺序获取锁）、可实现非公平锁（允许插队、吞吐量更高）、可尝试获取锁（可在指定时间内尝试获取锁，失败则返回）、可绑定多个条件（可分组唤醒等待的线程，实现更精细的线程通信）\n    \n选择问题：在绝大多数情况下，当并发冲突不激烈、同步逻辑简单时，优先选择Synchronized关键字，在特定的场景下，比如需要使用Synchronized不具备的高级功能时，或者是在我的秒杀项目中，需要将事务提交的完整过程都包裹在锁内，即手动控制锁时。","source":"wiki/Seckill/1-秒杀项目1.0-丢失更新和锁失效.md","raw":"---\nwiki: Seckill # 这是项目id，对应 /data/wiki/hexo-stellar.yml\ntitle: 1-秒杀项目1.0-丢失更新和锁失效\ntags: [Spring Boot,高并发]\ncategories: [项目实战]\nposter:\n  topic: 标题上方的小字\n  headline: 大标题\n  caption: 标题下方的小字\n  color: 标题颜色\ndate: 2025-09-25 09:11:57\ndescription: 重新起航版\ncover:\nbanner:\nsticky:\nmermaid:\nkatex:\nmathjax:\ntopic:\nauthor:\nreferences:\ncomments:\nindexing:\nbreadcrumb:\nleftbar: \nrightbar:\nh1:\ntype: tech\n---\n\n\n### 一、项目概述\n  - 项目名称：高并发-秒杀系统（1.0 单体应用原型）\n  - 项目目标：从零开始设计并实现一个功能完备的秒-杀业务原型，旨在深入理解高并发场景下常见的技术挑战，如数据一致性（超卖、重复下单）、性能瓶颈等，并通过多种技术手段进行分析和优化。\n  - 技术栈：\n    - 后端框架：Spring Boot\n    - 数据持久层：Spring Data JPA,Hibernate\n    - 数据库：MYSQL\n    - 构建工具：Maven\n    - 测试工具：JMeter\n\n### 二、项目搭建\n  #### 1. 环境搭建和初始化\n  - 使用 Spring Initializr 快速搭建了项目骨架，并集成 Spring Web、Spring Data JPA、MySQL Driver 等核心依赖。\n    > Spring Web:是构建Web应用程序的核心模块。内嵌Web服务器，提供Spring MVC框架，用于HTTP报文处理能力。负责监听网络接口，接受所有外来的HTTP请求，然后根据请求的URL和方法，精准的转接给后台相应的Controller去处理。\n    > Spring Data JPA：是一个用来极大简化数据库访问的框架。可以自动化SQL，进行对象-关系映射（ORM），并进行简化的自定义查询。\n  - 在 application.properties 中完成了数据库连接池的基础配置。\n  #### 2. 核心业务\n  - 设计核心数据表\n    - 商品表\n    ```SQL\n    CREATE TABLE `product` (\n    `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '商品ID',\n    `name` VARCHAR(100) NOT NULL COMMENT '商品名称',\n    `title` VARCHAR(255) NOT NULL COMMENT '商品标题',\n    `image` VARCHAR(255) DEFAULT '' COMMENT '商品图片URL',\n    `price` DECIMAL(10, 2) NOT NULL COMMENT '秒杀价格',\n    `stock` INT NOT NULL COMMENT '库存数量',\n    `start_time` DATETIME NOT NULL COMMENT '秒杀开始时间',\n    `end_time` DATETIME NOT NULL COMMENT '秒杀结束时间',\n    PRIMARY KEY (`id`)\n    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n    ```\n    - 订单表\n    在订单表的设计中加入了 (user_id, product_id)的唯一索引，即每个用户只能下一单。\n    ```SQL\n    CREATE TABLE `seckill_order` (\n    `id` BIGINT NOT NULL AUTO_INCREMENT,\n    `user_id` BIGINT NOT NULL COMMENT '用户ID',\n    `product_id` BIGINT NOT NULL COMMENT '商品ID',\n    `order_price` DECIMAL(10, 2) NOT NULL COMMENT '订单成交价格',\n    `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    PRIMARY KEY (`id`),\n    UNIQUE KEY `idx_user_product` (`user_id`, `product_id`) COMMENT '唯一索引，防止同一用户重复秒杀同一商品'\n    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n     ```\n\n#### 3. 基础功能实现\n- 采用标准的MVC分层架构，创建Controller, Service, Repository 层。\n  > Controller：作为应用的入口，直接处理外部的HTTP请求。\n  > Service：实现应用的核心业务逻辑。\n  > DAO：负责与数据库进行直接交互，完成数据的持久化操作。\n  > Model/Entity：数据的载体，定义了应用中的核心领域对象。\n\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251103013.png 请求过程 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251103013.png%}\n\n- 实现秒杀接口的核心业务逻辑。\n\n```Java\n@Transactional\npublic String processSeckill(Long productId, Long userId) {\n// 1. 从数据库读取 Product 对象到内存\nOptional<Product> productOpt = productRepository.findById(productId);\nProduct product = productOpt.get(); // 假设此时读到的 stock 是 100\n\n// ... 其他检查 ...\n\n// 2. 在内存中计算新库存\nproduct.setStock(product.getStock() - 1); // 内存中的 stock 变为 99\n\n// 3. 将内存中的 Product 对象保存回数据库\nproductRepository.save(product); \n\n// 4. 创建订单\nSeckillOrder order = new SeckillOrder();\n// ...\norderRepository.save(order);\n\nreturn \"秒杀成功！\";\n}\n```\n- 在初始版本中不加入任何的并发控制，后续会通过压力测试来暴露和分析最原始的并发问题。\n\n### 三、并发问题的分析与演进\n  #### 1. 库存设置与JMeter设置\n  - stock设置为100\n  - JMeter\n    - 线程数：200\n    - 1秒内同时发出200个并发请求\n    - 计数器自增UserId\n  #### 2. 实验结果\n  - 订单数增加了200个但是库存数只减少了20个\n    {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251245658.png 订单数 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251245658.png%}\n    {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251246389.png 库存数 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251246389.png%}\n\n  - 分析原因：事务和内存状态————Spring的@Transaction注解和JPA的工作机制\n    - 一级缓存：当第一个请求通过findById加载了ID为1的商品后，这个product对象会被放入当前事务的一级缓存中。\n    - 事务提交时才真正更新：productRepository.save(product)这个操作，并不是立即向数据库发送UPDATE语句，而要等到整个processSeckill方法执行完毕、事务准备提交时，才会生成并发送给数据库。\n  - 丢失的更新（stock=80）：前十个线程有可能都加载到了还没有提交的product，即此时读到的stock依然是100，后面的九次更新覆盖了第一次更新，所以最终结果和只更新一次是完全一样的（stock变成了99）。每次都有一批线程在竞争，但最后只有一个线程的更新“活”到了最后，导致库存最终只减少了大约20次。\n  - 订单的正常建立（新增order数=200）：orderRepository.save(order)这个操作，因为每个订单的主键都是自增的，并且（user_id,product_id）的组合也是唯一的，所以每一次订单的插入都能成功。\n  #### 3. 改进\n  ##### 第一次尝试-在 processSeckill 方法上加 synchronized 锁\n    \n  - 预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。\n\n  ```Java\n    @Transactional\n    public synchronized  String processSeckill(Long productId, Long userId) {\n    // 1. 从数据库读取 Product 对象到内存\n    Optional<Product> productOpt = productRepository.findById(productId);\n    Product product = productOpt.get(); // 假设此时读到的 stock 是 100\n\n    // ... 其他检查 ...\n\n    // 2. 在内存中计算新库存\n    product.setStock(product.getStock() - 1); // 内存中的 stock 变为 99\n\n    // 3. 将内存中的 Product 对象保存回数据库\n    productRepository.save(product); \n\n    // 4. 创建订单\n    SeckillOrder order = new SeckillOrder();\n    // ...\n    orderRepository.save(order);\n\n    return \"秒杀成功！\";\n    }\n  ```\n  - 结果：数据依然错误，订单数为200，库存数为79,而吞吐量和平均响应时间没有发生明显变化。\n  - 分析：@Transaction 与 synchronized 的冲突\n    - 当给一个方法加上@Transaction注解时，Spring为了能够控制事务的开启、提交和回滚，并不会让你直接调用这个方法，相反，Spring会在运行时创建一个该类的代理对象proxy。\n    - 事务先生效：即代理对象的同名方法会被触发，代理对象会先开启一个事务\n    - synchronized被绕过：它是Java原生关键字，作用于对象实例的锁，但Spring的代理机制在调用目标方法时，可能会导致锁机制失效，因为代理方法本身没有synchronized，调用父类（本身SeckillService）的方法时，锁的上下文可能已经丢失或不准确。\n  即，Spring的AOP代理与Java原生的锁关键字之间存在冲突，代理绕过了锁，导致synchronized锁机制未生效。\n\n  ##### 第二次尝试-在事务内使用ReentrantLock\n  - 预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。\n  ```Java\n    @Transactional\n    public String processSeckill(Long productId, Long userId) {  // 1. 事务由代理对象在这里开启\n        // 2. 在方法开始时手动加锁\n        lock.lock();\n        try {\n            // 所有业务逻辑都放在 try 块中\n            // 其他检查\n\n            product.setStock(product.getStock() - 1);\n            productRepository.save(product);\n\n            SeckillOrder order = new SeckillOrder();\n            // ...\n            orderRepository.save(order);\n\n            return \"秒杀成功！订单创建中...\";\n        } finally {\n            // 3. 【至关重要】在 finally 块中解锁，确保即使发生异常也能释放锁\n            lock.unlock();\n        }\n    }      // 4. 事务由代理对象在这里提交\n  ```\n  - 显示控制：lock.lock()是代码逻辑的一部分，在代理调用了实际方法之后，业务逻辑执行之前被调用。任何线程进入这个方法后，都必须先获取到这个锁才能继续执行。\n  - 安全释放：使用try...finally结构，确保无论业务逻辑是否成功，锁最终都会被释放，避免了“死锁”的风险。\n\n  - 结果：数据依然错误，订单数为200，库存数为79,而吞吐量和平均响应时间没有发生明显变化。\n  - 分析：锁的范围 VS 事务的范围\n    - 锁释放在前，事务提交在后，所以当线程A解锁后，UPDATE语句还没有提交进入数据库，而此时线程B立即取锁进入了方法，此时B读取到的库存数还是旧值。重演丢失更新问题。\n\n  ##### 第三次尝试-ReentrantLock + 手动事务\n  - 预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。\n\n  - 解决方案：将事务控制移入锁内\n    - 放弃@Transaction注解，因为这个注解无法精细控制提交时机，改用最经典、最原始的手动事务管理。\n    - 使用PlatformTransactionManager 来手动控制事务的开始、提交和回滚。将整个生命周期包裹在锁内。\n  ```Java\n    @Autowired\n    private PlatformTransactionManager transactionManager;\n\n    private final Lock lock = new ReentrantLock();\n\n    public String processSeckill(Long productId, Long userId) {\n        // 1. 上锁\n        lock.lock();\n        \n        DefaultTransactionDefinition def = new DefaultTransactionDefinition();\n        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n        // 2. 开启事务\n        TransactionStatus status = transactionManager.getTransaction(def);\n\n        try {\n            // ...所有业务逻辑，和之前一样\n            // 3. 【关键】在锁释放前，手动提交事务\n            transactionManager.commit(status);\n\n            return \"秒杀成功！订单创建中...\";\n        } catch (Exception e) {\n            //  如果发生任何异常，手动回滚事务\n            transactionManager.rollback(status);\n            // 将异常信息返回或记录日志\n            return e.getMessage(); \n        } finally {\n            // 4. 最后，释放锁\n            lock.unlock();\n        }\n    }\n  ```\n  - 结果:数据正确，库存为0，订单数为100，吞吐量没有下降，甚至比没有并发控制的1.0 版本还要高。\n  - 分析: 在高并发场景下，无序的并发混乱，有时远比有序的串行执行要慢。下表为初始版本和三次尝试版本的压测数据。\n\n| Label                                  | 样本 | 平均值 | 中位数 | 90% 百分位 | 95% 百分位 | 99% 百分位 | 最小值 | 最大值 | 异常 % | 吞吐量 | 接收 KB/sec | 发送 KB/sec |\n| -------------------------------------- | ---- | ------ | ------ | ---------- | ---------- | ---------- | ------ | ------ | ------ | ------ | ----------- | ----------- |\n| 1.0秒杀系统                            | 200  | 740    | 810    | 1044       | 1078       | 1083       | 254    | 1084   | 0.00%  | 95.92  | 18.27       | 20.51       |\n| 2.0秒杀系统_添加关键字synchronized     | 200  | 578    | 598    | 744        | 763        | 767        | 79     | 831    | 0.00%  | 113.38 | 21.59       | 24.24       |\n| 2.0秒杀系统_手动添加锁ReentrantLock    | 200  | 638    | 663    | 819        | 837        | 879        | 237    | 891    | 0.00%  | 105.76 | 20.14       | 22.62       |\n| 2.0秒杀系统_不使用@Transaction手动加锁 | 200  | 905    | 1024   | 1148       | 1160       | 1175       | 203    | 1178   | 0.00%  | 100.45 | 18.25       | 21.48       |\n  \n  - 无锁版虽然看似并行，但造成了数据库层面大量的行锁竞争、唯一键冲突错误、事务回滚，这些“无效”的数据库操作成为了真正的性能瓶颈。而加锁后的版本，虽然在应用层是串行的，但它保护了数据库，向数据库发送的是一连串干净、有效的请求，避免了数据库的内部冲突和错误处理开销，因此整体系统的有效吞吐量反而更高。\n\n### 学学八股\n  \n#### @Transaction注解 & 一个请求的生命周期\n- Controller接受请求，调用Service方法，但此时Service引用的是Spring的代理对象，而不是原始实例。代理对象的方法被触发，检查到方法上有@Transaction注解，代理对象向事务管理器（platformTransactionManager）请求开启一个新的事务。从数据库连接池中获取一个数据库连接，向MySQL服务器发送指令。此时一个数据库事务的“上下文”已经建立，但还没有任何实际的业务SQL被执行。在开启事务后，代理对象才会调用原始实例的方法，开始执行业务逻辑。但需要注意的是，这个阶段中是没有发生任何数据库操作的，只是告诉JPA的持久化上下文，标记了该对象，后续需要“留意”。\n- 所有代码都执行完毕后，到达return语句，准备将结果返回。此时代理对象接收到真实方法的返回值，因为没有捕获到任何异常，代理对象判断这次业务执行是成功的，通知事务管理器可以提交事务了。事务管理器执行数据库同步，在真正COMMIT之前，JPA会执行一次Flush，生成SQL语句，发送到MYSQL服务器并执行，直到COMMIT被成功执行了，这次更新才被永久地鞋屋数据库磁盘。\n- 代理对象将你方法的返回值传递给Controller，Controller再将其封装成HTTP响应返回给用户。\n\n\n#### 锁-初步\n1. Synchronized：Keyword、JVM内置的同步原语，简单、隐式的加锁和解锁机制。\n  - 使用方法：修饰实例方法、修饰静态方法、修饰代码块。\n  - 实现依赖于每个Java对象头部的Mark Word和JVM内部的Monitor对象监视器（当线程尝试获取锁时，JVM会执行Monitorenter字节码指令，尝试获得对象Monitor所有权。释放锁时即执行monitorexit）。\n  - 锁升级机制：偏向锁--->轻量级锁(当有第二个线程竞争时升级，竞争的线程通过自旋和CAS来尝试获取锁，不进入阻塞状态)--->重量级锁（竞争加剧，自旋失败，升级，未获取到锁的线程会被阻塞，由内核进行调度，性能开销最大）\n\n2. ReentrantLock：是JUC工具包的核心成员，显式加锁和解锁机制。\n  - 使用方法：标准的使用范式\n  ```Java\n    // 1. 在类中声明一个 Lock 实例\n    private final ReentrantLock lock = new ReentrantLock();\n         \n    public void someMethod() {\n    // 2. 在 try...finally 结构中进行加锁和解锁\n    lock.lock(); // 获取锁\n    try {\n    // 3. 保护的同步代码\n    } finally {\n    // 4. 必须在 finally 块中释放锁\n    lock.unlock();\n    }\n    }\n  ```\n  - 实现依赖于JUC的核心框架AQS，所有获取锁失败的线程，会被封装成节点放入一个CLH虚拟双向队列中进行排队等待。当锁被释放时，会从队列头部唤醒下一个等待的线程。整个过程都在用户态完成，避免了频繁的内核态切换。\n    > AQS 内部通过一个 `volatile` 的 `int` 类型的 `state` 变量来表示同步状态（0表示未锁定，>0表示已锁定），并使用 **CAS** 操作来原子性地修改这个 `state` 值。\n  - 功能丰富：等待可中断（等待锁的线程可被中断）、可实现公平锁（按线程请求的顺序获取锁）、可实现非公平锁（允许插队、吞吐量更高）、可尝试获取锁（可在指定时间内尝试获取锁，失败则返回）、可绑定多个条件（可分组唤醒等待的线程，实现更精细的线程通信）\n    \n选择问题：在绝大多数情况下，当并发冲突不激烈、同步逻辑简单时，优先选择Synchronized关键字，在特定的场景下，比如需要使用Synchronized不具备的高级功能时，或者是在我的秒杀项目中，需要将事务提交的完整过程都包裹在锁内，即手动控制锁时。","updated":"2025-10-03T12:58:48.478Z","path":"wiki/Seckill/1-秒杀项目1.0-丢失更新和锁失效.html","layout":"page","_id":"cmgdn5rh100060wuz7djg5963","content":"<h3 id=\"一、项目概述\"><a href=\"#一、项目概述\" class=\"headerlink\" title=\"一、项目概述\"></a>一、项目概述</h3><ul>\n<li>项目名称：高并发-秒杀系统（1.0 单体应用原型）</li>\n<li>项目目标：从零开始设计并实现一个功能完备的秒-杀业务原型，旨在深入理解高并发场景下常见的技术挑战，如数据一致性（超卖、重复下单）、性能瓶颈等，并通过多种技术手段进行分析和优化。</li>\n<li>技术栈：<ul>\n<li>后端框架：Spring Boot</li>\n<li>数据持久层：Spring Data JPA,Hibernate</li>\n<li>数据库：MYSQL</li>\n<li>构建工具：Maven</li>\n<li>测试工具：JMeter</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、项目搭建\"><a href=\"#二、项目搭建\" class=\"headerlink\" title=\"二、项目搭建\"></a>二、项目搭建</h3><h4 id=\"1-环境搭建和初始化\"><a href=\"#1-环境搭建和初始化\" class=\"headerlink\" title=\"1. 环境搭建和初始化\"></a>1. 环境搭建和初始化</h4><ul>\n<li>使用 Spring Initializr 快速搭建了项目骨架，并集成 Spring Web、Spring Data JPA、MySQL Driver 等核心依赖。<blockquote>\n<p>Spring Web:是构建Web应用程序的核心模块。内嵌Web服务器，提供Spring MVC框架，用于HTTP报文处理能力。负责监听网络接口，接受所有外来的HTTP请求，然后根据请求的URL和方法，精准的转接给后台相应的Controller去处理。<br>Spring Data JPA：是一个用来极大简化数据库访问的框架。可以自动化SQL，进行对象-关系映射（ORM），并进行简化的自定义查询。</p>\n</blockquote>\n</li>\n<li>在 application.properties 中完成了数据库连接池的基础配置。</li>\n</ul>\n<h4 id=\"2-核心业务\"><a href=\"#2-核心业务\" class=\"headerlink\" title=\"2. 核心业务\"></a>2. 核心业务</h4><ul>\n<li>设计核心数据表<ul>\n<li>商品表<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> `product` (</span><br><span class=\"line\">`id` <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT NULL</span> AUTO_INCREMENT COMMENT <span class=\"string\">&#x27;商品ID&#x27;</span>,</span><br><span class=\"line\">`name` <span class=\"type\">VARCHAR</span>(<span class=\"number\">100</span>) <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;商品名称&#x27;</span>,</span><br><span class=\"line\">`title` <span class=\"type\">VARCHAR</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;商品标题&#x27;</span>,</span><br><span class=\"line\">`image` <span class=\"type\">VARCHAR</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;&#x27;</span> COMMENT <span class=\"string\">&#x27;商品图片URL&#x27;</span>,</span><br><span class=\"line\">`price` <span class=\"type\">DECIMAL</span>(<span class=\"number\">10</span>, <span class=\"number\">2</span>) <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;秒杀价格&#x27;</span>,</span><br><span class=\"line\">`stock` <span class=\"type\">INT</span> <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;库存数量&#x27;</span>,</span><br><span class=\"line\">`start_time` DATETIME <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;秒杀开始时间&#x27;</span>,</span><br><span class=\"line\">`end_time` DATETIME <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;秒杀结束时间&#x27;</span>,</span><br><span class=\"line\"><span class=\"keyword\">PRIMARY KEY</span> (`id`)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4;</span><br></pre></td></tr></table></figure></li>\n<li>订单表<br>在订单表的设计中加入了 (user_id, product_id)的唯一索引，即每个用户只能下一单。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> `seckill_order` (</span><br><span class=\"line\">`id` <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">`user_id` <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;用户ID&#x27;</span>,</span><br><span class=\"line\">`product_id` <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;商品ID&#x27;</span>,</span><br><span class=\"line\">`order_price` <span class=\"type\">DECIMAL</span>(<span class=\"number\">10</span>, <span class=\"number\">2</span>) <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;订单成交价格&#x27;</span>,</span><br><span class=\"line\">`create_time` DATETIME <span class=\"keyword\">DEFAULT</span> <span class=\"built_in\">CURRENT_TIMESTAMP</span> COMMENT <span class=\"string\">&#x27;创建时间&#x27;</span>,</span><br><span class=\"line\"><span class=\"keyword\">PRIMARY KEY</span> (`id`),</span><br><span class=\"line\"><span class=\"keyword\">UNIQUE</span> KEY `idx_user_product` (`user_id`, `product_id`) COMMENT <span class=\"string\">&#x27;唯一索引，防止同一用户重复秒杀同一商品&#x27;</span></span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-基础功能实现\"><a href=\"#3-基础功能实现\" class=\"headerlink\" title=\"3. 基础功能实现\"></a>3. 基础功能实现</h4><ul>\n<li>采用标准的MVC分层架构，创建Controller, Service, Repository 层。<blockquote>\n<p>Controller：作为应用的入口，直接处理外部的HTTP请求。<br>Service：实现应用的核心业务逻辑。<br>DAO：负责与数据库进行直接交互，完成数据的持久化操作。<br>Model&#x2F;Entity：数据的载体，定义了应用中的核心领域对象。</p>\n</blockquote>\n</li>\n</ul>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251103013.png\" alt=\"请求过程\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"请求过程\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251103013.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">请求过程</span></div></div>\n\n<ul>\n<li>实现秒杀接口的核心业务逻辑。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 1. 从数据库读取 Product 对象到内存</span></span><br><span class=\"line\">Optional&lt;Product&gt; productOpt = productRepository.findById(productId);</span><br><span class=\"line\"><span class=\"type\">Product</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> productOpt.get(); <span class=\"comment\">// 假设此时读到的 stock 是 100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... 其他检查 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在内存中计算新库存</span></span><br><span class=\"line\">product.setStock(product.getStock() - <span class=\"number\">1</span>); <span class=\"comment\">// 内存中的 stock 变为 99</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 将内存中的 Product 对象保存回数据库</span></span><br><span class=\"line\">productRepository.save(product); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 创建订单</span></span><br><span class=\"line\"><span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SeckillOrder</span>();</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">orderRepository.save(order);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在初始版本中不加入任何的并发控制，后续会通过压力测试来暴露和分析最原始的并发问题。</li>\n</ul>\n<h3 id=\"三、并发问题的分析与演进\"><a href=\"#三、并发问题的分析与演进\" class=\"headerlink\" title=\"三、并发问题的分析与演进\"></a>三、并发问题的分析与演进</h3><h4 id=\"1-库存设置与JMeter设置\"><a href=\"#1-库存设置与JMeter设置\" class=\"headerlink\" title=\"1. 库存设置与JMeter设置\"></a>1. 库存设置与JMeter设置</h4><ul>\n<li>stock设置为100</li>\n<li>JMeter<ul>\n<li>线程数：200</li>\n<li>1秒内同时发出200个并发请求</li>\n<li>计数器自增UserId</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-实验结果\"><a href=\"#2-实验结果\" class=\"headerlink\" title=\"2. 实验结果\"></a>2. 实验结果</h4><ul>\n<li><p>订单数增加了200个但是库存数只减少了20个</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251245658.png\" alt=\"订单数\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"订单数\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251245658.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">订单数</span></div></div>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251246389.png\" alt=\"库存数\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"库存数\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251246389.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">库存数</span></div></div>\n</li>\n<li><p>分析原因：事务和内存状态————Spring的@Transaction注解和JPA的工作机制</p>\n<ul>\n<li>一级缓存：当第一个请求通过findById加载了ID为1的商品后，这个product对象会被放入当前事务的一级缓存中。</li>\n<li>事务提交时才真正更新：productRepository.save(product)这个操作，并不是立即向数据库发送UPDATE语句，而要等到整个processSeckill方法执行完毕、事务准备提交时，才会生成并发送给数据库。</li>\n</ul>\n</li>\n<li><p>丢失的更新（stock&#x3D;80）：前十个线程有可能都加载到了还没有提交的product，即此时读到的stock依然是100，后面的九次更新覆盖了第一次更新，所以最终结果和只更新一次是完全一样的（stock变成了99）。每次都有一批线程在竞争，但最后只有一个线程的更新“活”到了最后，导致库存最终只减少了大约20次。</p>\n</li>\n<li><p>订单的正常建立（新增order数&#x3D;200）：orderRepository.save(order)这个操作，因为每个订单的主键都是自增的，并且（user_id,product_id）的组合也是唯一的，所以每一次订单的插入都能成功。</p>\n</li>\n</ul>\n<h4 id=\"3-改进\"><a href=\"#3-改进\" class=\"headerlink\" title=\"3. 改进\"></a>3. 改进</h4><h5 id=\"第一次尝试-在-processSeckill-方法上加-synchronized-锁\"><a href=\"#第一次尝试-在-processSeckill-方法上加-synchronized-锁\" class=\"headerlink\" title=\"第一次尝试-在 processSeckill 方法上加 synchronized 锁\"></a>第一次尝试-在 processSeckill 方法上加 synchronized 锁</h5><ul>\n<li>预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。</li>\n</ul>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span>  String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 1. 从数据库读取 Product 对象到内存</span></span><br><span class=\"line\">Optional&lt;Product&gt; productOpt = productRepository.findById(productId);</span><br><span class=\"line\"><span class=\"type\">Product</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> productOpt.get(); <span class=\"comment\">// 假设此时读到的 stock 是 100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... 其他检查 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在内存中计算新库存</span></span><br><span class=\"line\">product.setStock(product.getStock() - <span class=\"number\">1</span>); <span class=\"comment\">// 内存中的 stock 变为 99</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 将内存中的 Product 对象保存回数据库</span></span><br><span class=\"line\">productRepository.save(product); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 创建订单</span></span><br><span class=\"line\"><span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SeckillOrder</span>();</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">orderRepository.save(order);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>结果：数据依然错误，订单数为200，库存数为79,而吞吐量和平均响应时间没有发生明显变化。</li>\n<li>分析：@Transaction 与 synchronized 的冲突<ul>\n<li>当给一个方法加上@Transaction注解时，Spring为了能够控制事务的开启、提交和回滚，并不会让你直接调用这个方法，相反，Spring会在运行时创建一个该类的代理对象proxy。</li>\n<li>事务先生效：即代理对象的同名方法会被触发，代理对象会先开启一个事务</li>\n<li>synchronized被绕过：它是Java原生关键字，作用于对象实例的锁，但Spring的代理机制在调用目标方法时，可能会导致锁机制失效，因为代理方法本身没有synchronized，调用父类（本身SeckillService）的方法时，锁的上下文可能已经丢失或不准确。<br>即，Spring的AOP代理与Java原生的锁关键字之间存在冲突，代理绕过了锁，导致synchronized锁机制未生效。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"第二次尝试-在事务内使用ReentrantLock\"><a href=\"#第二次尝试-在事务内使用ReentrantLock\" class=\"headerlink\" title=\"第二次尝试-在事务内使用ReentrantLock\"></a>第二次尝试-在事务内使用ReentrantLock</h5><ul>\n<li><p>预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;  <span class=\"comment\">// 1. 事务由代理对象在这里开启</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 在方法开始时手动加锁</span></span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 所有业务逻辑都放在 try 块中</span></span><br><span class=\"line\">        <span class=\"comment\">// 其他检查</span></span><br><span class=\"line\"></span><br><span class=\"line\">        product.setStock(product.getStock() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        productRepository.save(product);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SeckillOrder</span>();</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        orderRepository.save(order);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！订单创建中...&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3. 【至关重要】在 finally 块中解锁，确保即使发生异常也能释放锁</span></span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;      <span class=\"comment\">// 4. 事务由代理对象在这里提交</span></span><br></pre></td></tr></table></figure></li>\n<li><p>显示控制：lock.lock()是代码逻辑的一部分，在代理调用了实际方法之后，业务逻辑执行之前被调用。任何线程进入这个方法后，都必须先获取到这个锁才能继续执行。</p>\n</li>\n<li><p>安全释放：使用try…finally结构，确保无论业务逻辑是否成功，锁最终都会被释放，避免了“死锁”的风险。</p>\n</li>\n<li><p>结果：数据依然错误，订单数为200，库存数为79,而吞吐量和平均响应时间没有发生明显变化。</p>\n</li>\n<li><p>分析：锁的范围 VS 事务的范围</p>\n<ul>\n<li>锁释放在前，事务提交在后，所以当线程A解锁后，UPDATE语句还没有提交进入数据库，而此时线程B立即取锁进入了方法，此时B读取到的库存数还是旧值。重演丢失更新问题。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"第三次尝试-ReentrantLock-手动事务\"><a href=\"#第三次尝试-ReentrantLock-手动事务\" class=\"headerlink\" title=\"第三次尝试-ReentrantLock + 手动事务\"></a>第三次尝试-ReentrantLock + 手动事务</h5><ul>\n<li><p>预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。</p>\n</li>\n<li><p>解决方案：将事务控制移入锁内</p>\n<ul>\n<li>放弃@Transaction注解，因为这个注解无法精细控制提交时机，改用最经典、最原始的手动事务管理。</li>\n<li>使用PlatformTransactionManager 来手动控制事务的开始、提交和回滚。将整个生命周期包裹在锁内。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> PlatformTransactionManager transactionManager;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 上锁</span></span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">DefaultTransactionDefinition</span> <span class=\"variable\">def</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultTransactionDefinition</span>();</span><br><span class=\"line\">    def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class=\"line\">    <span class=\"comment\">// 2. 开启事务</span></span><br><span class=\"line\">    <span class=\"type\">TransactionStatus</span> <span class=\"variable\">status</span> <span class=\"operator\">=</span> transactionManager.getTransaction(def);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...所有业务逻辑，和之前一样</span></span><br><span class=\"line\">        <span class=\"comment\">// 3. 【关键】在锁释放前，手动提交事务</span></span><br><span class=\"line\">        transactionManager.commit(status);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！订单创建中...&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//  如果发生任何异常，手动回滚事务</span></span><br><span class=\"line\">        transactionManager.rollback(status);</span><br><span class=\"line\">        <span class=\"comment\">// 将异常信息返回或记录日志</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> e.getMessage(); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 4. 最后，释放锁</span></span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>结果:数据正确，库存为0，订单数为100，吞吐量没有下降，甚至比没有并发控制的1.0 版本还要高。</p>\n</li>\n<li><p>分析: 在高并发场景下，无序的并发混乱，有时远比有序的串行执行要慢。下表为初始版本和三次尝试版本的压测数据。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Label</th>\n<th>样本</th>\n<th>平均值</th>\n<th>中位数</th>\n<th>90% 百分位</th>\n<th>95% 百分位</th>\n<th>99% 百分位</th>\n<th>最小值</th>\n<th>最大值</th>\n<th>异常 %</th>\n<th>吞吐量</th>\n<th>接收 KB&#x2F;sec</th>\n<th>发送 KB&#x2F;sec</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1.0秒杀系统</td>\n<td>200</td>\n<td>740</td>\n<td>810</td>\n<td>1044</td>\n<td>1078</td>\n<td>1083</td>\n<td>254</td>\n<td>1084</td>\n<td>0.00%</td>\n<td>95.92</td>\n<td>18.27</td>\n<td>20.51</td>\n</tr>\n<tr>\n<td>2.0秒杀系统_添加关键字synchronized</td>\n<td>200</td>\n<td>578</td>\n<td>598</td>\n<td>744</td>\n<td>763</td>\n<td>767</td>\n<td>79</td>\n<td>831</td>\n<td>0.00%</td>\n<td>113.38</td>\n<td>21.59</td>\n<td>24.24</td>\n</tr>\n<tr>\n<td>2.0秒杀系统_手动添加锁ReentrantLock</td>\n<td>200</td>\n<td>638</td>\n<td>663</td>\n<td>819</td>\n<td>837</td>\n<td>879</td>\n<td>237</td>\n<td>891</td>\n<td>0.00%</td>\n<td>105.76</td>\n<td>20.14</td>\n<td>22.62</td>\n</tr>\n<tr>\n<td>2.0秒杀系统_不使用@Transaction手动加锁</td>\n<td>200</td>\n<td>905</td>\n<td>1024</td>\n<td>1148</td>\n<td>1160</td>\n<td>1175</td>\n<td>203</td>\n<td>1178</td>\n<td>0.00%</td>\n<td>100.45</td>\n<td>18.25</td>\n<td>21.48</td>\n</tr>\n</tbody></table>\n<ul>\n<li>无锁版虽然看似并行，但造成了数据库层面大量的行锁竞争、唯一键冲突错误、事务回滚，这些“无效”的数据库操作成为了真正的性能瓶颈。而加锁后的版本，虽然在应用层是串行的，但它保护了数据库，向数据库发送的是一连串干净、有效的请求，避免了数据库的内部冲突和错误处理开销，因此整体系统的有效吞吐量反而更高。</li>\n</ul>\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"Transaction注解-一个请求的生命周期\"><a href=\"#Transaction注解-一个请求的生命周期\" class=\"headerlink\" title=\"@Transaction注解 &amp; 一个请求的生命周期\"></a>@Transaction注解 &amp; 一个请求的生命周期</h4><ul>\n<li>Controller接受请求，调用Service方法，但此时Service引用的是Spring的代理对象，而不是原始实例。代理对象的方法被触发，检查到方法上有@Transaction注解，代理对象向事务管理器（platformTransactionManager）请求开启一个新的事务。从数据库连接池中获取一个数据库连接，向MySQL服务器发送指令。此时一个数据库事务的“上下文”已经建立，但还没有任何实际的业务SQL被执行。在开启事务后，代理对象才会调用原始实例的方法，开始执行业务逻辑。但需要注意的是，这个阶段中是没有发生任何数据库操作的，只是告诉JPA的持久化上下文，标记了该对象，后续需要“留意”。</li>\n<li>所有代码都执行完毕后，到达return语句，准备将结果返回。此时代理对象接收到真实方法的返回值，因为没有捕获到任何异常，代理对象判断这次业务执行是成功的，通知事务管理器可以提交事务了。事务管理器执行数据库同步，在真正COMMIT之前，JPA会执行一次Flush，生成SQL语句，发送到MYSQL服务器并执行，直到COMMIT被成功执行了，这次更新才被永久地鞋屋数据库磁盘。</li>\n<li>代理对象将你方法的返回值传递给Controller，Controller再将其封装成HTTP响应返回给用户。</li>\n</ul>\n<h4 id=\"锁-初步\"><a href=\"#锁-初步\" class=\"headerlink\" title=\"锁-初步\"></a>锁-初步</h4><ol>\n<li>Synchronized：Keyword、JVM内置的同步原语，简单、隐式的加锁和解锁机制。</li>\n</ol>\n<ul>\n<li>使用方法：修饰实例方法、修饰静态方法、修饰代码块。</li>\n<li>实现依赖于每个Java对象头部的Mark Word和JVM内部的Monitor对象监视器（当线程尝试获取锁时，JVM会执行Monitorenter字节码指令，尝试获得对象Monitor所有权。释放锁时即执行monitorexit）。</li>\n<li>锁升级机制：偏向锁—&gt;轻量级锁(当有第二个线程竞争时升级，竞争的线程通过自旋和CAS来尝试获取锁，不进入阻塞状态)—&gt;重量级锁（竞争加剧，自旋失败，升级，未获取到锁的线程会被阻塞，由内核进行调度，性能开销最大）</li>\n</ul>\n<ol start=\"2\">\n<li>ReentrantLock：是JUC工具包的核心成员，显式加锁和解锁机制。</li>\n</ol>\n<ul>\n<li>使用方法：标准的使用范式  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 在类中声明一个 Lock 实例</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">someMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 2. 在 try...finally 结构中进行加锁和解锁</span></span><br><span class=\"line\">lock.lock(); <span class=\"comment\">// 获取锁</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 3. 保护的同步代码</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 4. 必须在 finally 块中释放锁</span></span><br><span class=\"line\">lock.unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>实现依赖于JUC的核心框架AQS，所有获取锁失败的线程，会被封装成节点放入一个CLH虚拟双向队列中进行排队等待。当锁被释放时，会从队列头部唤醒下一个等待的线程。整个过程都在用户态完成，避免了频繁的内核态切换。<blockquote>\n<p>AQS 内部通过一个 <code>volatile</code> 的 <code>int</code> 类型的 <code>state</code> 变量来表示同步状态（0表示未锁定，&gt;0表示已锁定），并使用 <strong>CAS</strong> 操作来原子性地修改这个 <code>state</code> 值。</p>\n</blockquote>\n</li>\n<li>功能丰富：等待可中断（等待锁的线程可被中断）、可实现公平锁（按线程请求的顺序获取锁）、可实现非公平锁（允许插队、吞吐量更高）、可尝试获取锁（可在指定时间内尝试获取锁，失败则返回）、可绑定多个条件（可分组唤醒等待的线程，实现更精细的线程通信）</li>\n</ul>\n<p>选择问题：在绝大多数情况下，当并发冲突不激烈、同步逻辑简单时，优先选择Synchronized关键字，在特定的场景下，比如需要使用Synchronized不具备的高级功能时，或者是在我的秒杀项目中，需要将事务提交的完整过程都包裹在锁内，即手动控制锁时。</p>\n","excerpt":"","more":"<h3 id=\"一、项目概述\"><a href=\"#一、项目概述\" class=\"headerlink\" title=\"一、项目概述\"></a>一、项目概述</h3><ul>\n<li>项目名称：高并发-秒杀系统（1.0 单体应用原型）</li>\n<li>项目目标：从零开始设计并实现一个功能完备的秒-杀业务原型，旨在深入理解高并发场景下常见的技术挑战，如数据一致性（超卖、重复下单）、性能瓶颈等，并通过多种技术手段进行分析和优化。</li>\n<li>技术栈：<ul>\n<li>后端框架：Spring Boot</li>\n<li>数据持久层：Spring Data JPA,Hibernate</li>\n<li>数据库：MYSQL</li>\n<li>构建工具：Maven</li>\n<li>测试工具：JMeter</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、项目搭建\"><a href=\"#二、项目搭建\" class=\"headerlink\" title=\"二、项目搭建\"></a>二、项目搭建</h3><h4 id=\"1-环境搭建和初始化\"><a href=\"#1-环境搭建和初始化\" class=\"headerlink\" title=\"1. 环境搭建和初始化\"></a>1. 环境搭建和初始化</h4><ul>\n<li>使用 Spring Initializr 快速搭建了项目骨架，并集成 Spring Web、Spring Data JPA、MySQL Driver 等核心依赖。<blockquote>\n<p>Spring Web:是构建Web应用程序的核心模块。内嵌Web服务器，提供Spring MVC框架，用于HTTP报文处理能力。负责监听网络接口，接受所有外来的HTTP请求，然后根据请求的URL和方法，精准的转接给后台相应的Controller去处理。<br>Spring Data JPA：是一个用来极大简化数据库访问的框架。可以自动化SQL，进行对象-关系映射（ORM），并进行简化的自定义查询。</p>\n</blockquote>\n</li>\n<li>在 application.properties 中完成了数据库连接池的基础配置。</li>\n</ul>\n<h4 id=\"2-核心业务\"><a href=\"#2-核心业务\" class=\"headerlink\" title=\"2. 核心业务\"></a>2. 核心业务</h4><ul>\n<li>设计核心数据表<ul>\n<li>商品表<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> `product` (</span><br><span class=\"line\">`id` <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT NULL</span> AUTO_INCREMENT COMMENT <span class=\"string\">&#x27;商品ID&#x27;</span>,</span><br><span class=\"line\">`name` <span class=\"type\">VARCHAR</span>(<span class=\"number\">100</span>) <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;商品名称&#x27;</span>,</span><br><span class=\"line\">`title` <span class=\"type\">VARCHAR</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;商品标题&#x27;</span>,</span><br><span class=\"line\">`image` <span class=\"type\">VARCHAR</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;&#x27;</span> COMMENT <span class=\"string\">&#x27;商品图片URL&#x27;</span>,</span><br><span class=\"line\">`price` <span class=\"type\">DECIMAL</span>(<span class=\"number\">10</span>, <span class=\"number\">2</span>) <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;秒杀价格&#x27;</span>,</span><br><span class=\"line\">`stock` <span class=\"type\">INT</span> <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;库存数量&#x27;</span>,</span><br><span class=\"line\">`start_time` DATETIME <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;秒杀开始时间&#x27;</span>,</span><br><span class=\"line\">`end_time` DATETIME <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;秒杀结束时间&#x27;</span>,</span><br><span class=\"line\"><span class=\"keyword\">PRIMARY KEY</span> (`id`)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4;</span><br></pre></td></tr></table></figure></li>\n<li>订单表<br>在订单表的设计中加入了 (user_id, product_id)的唯一索引，即每个用户只能下一单。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> `seckill_order` (</span><br><span class=\"line\">`id` <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">`user_id` <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;用户ID&#x27;</span>,</span><br><span class=\"line\">`product_id` <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;商品ID&#x27;</span>,</span><br><span class=\"line\">`order_price` <span class=\"type\">DECIMAL</span>(<span class=\"number\">10</span>, <span class=\"number\">2</span>) <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;订单成交价格&#x27;</span>,</span><br><span class=\"line\">`create_time` DATETIME <span class=\"keyword\">DEFAULT</span> <span class=\"built_in\">CURRENT_TIMESTAMP</span> COMMENT <span class=\"string\">&#x27;创建时间&#x27;</span>,</span><br><span class=\"line\"><span class=\"keyword\">PRIMARY KEY</span> (`id`),</span><br><span class=\"line\"><span class=\"keyword\">UNIQUE</span> KEY `idx_user_product` (`user_id`, `product_id`) COMMENT <span class=\"string\">&#x27;唯一索引，防止同一用户重复秒杀同一商品&#x27;</span></span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-基础功能实现\"><a href=\"#3-基础功能实现\" class=\"headerlink\" title=\"3. 基础功能实现\"></a>3. 基础功能实现</h4><ul>\n<li>采用标准的MVC分层架构，创建Controller, Service, Repository 层。<blockquote>\n<p>Controller：作为应用的入口，直接处理外部的HTTP请求。<br>Service：实现应用的核心业务逻辑。<br>DAO：负责与数据库进行直接交互，完成数据的持久化操作。<br>Model&#x2F;Entity：数据的载体，定义了应用中的核心领域对象。</p>\n</blockquote>\n</li>\n</ul>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251103013.png\" alt=\"请求过程\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"请求过程\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251103013.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">请求过程</span></div></div>\n\n<ul>\n<li>实现秒杀接口的核心业务逻辑。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 1. 从数据库读取 Product 对象到内存</span></span><br><span class=\"line\">Optional&lt;Product&gt; productOpt = productRepository.findById(productId);</span><br><span class=\"line\"><span class=\"type\">Product</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> productOpt.get(); <span class=\"comment\">// 假设此时读到的 stock 是 100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... 其他检查 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在内存中计算新库存</span></span><br><span class=\"line\">product.setStock(product.getStock() - <span class=\"number\">1</span>); <span class=\"comment\">// 内存中的 stock 变为 99</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 将内存中的 Product 对象保存回数据库</span></span><br><span class=\"line\">productRepository.save(product); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 创建订单</span></span><br><span class=\"line\"><span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SeckillOrder</span>();</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">orderRepository.save(order);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在初始版本中不加入任何的并发控制，后续会通过压力测试来暴露和分析最原始的并发问题。</li>\n</ul>\n<h3 id=\"三、并发问题的分析与演进\"><a href=\"#三、并发问题的分析与演进\" class=\"headerlink\" title=\"三、并发问题的分析与演进\"></a>三、并发问题的分析与演进</h3><h4 id=\"1-库存设置与JMeter设置\"><a href=\"#1-库存设置与JMeter设置\" class=\"headerlink\" title=\"1. 库存设置与JMeter设置\"></a>1. 库存设置与JMeter设置</h4><ul>\n<li>stock设置为100</li>\n<li>JMeter<ul>\n<li>线程数：200</li>\n<li>1秒内同时发出200个并发请求</li>\n<li>计数器自增UserId</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-实验结果\"><a href=\"#2-实验结果\" class=\"headerlink\" title=\"2. 实验结果\"></a>2. 实验结果</h4><ul>\n<li><p>订单数增加了200个但是库存数只减少了20个</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251245658.png\" alt=\"订单数\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"订单数\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251245658.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">订单数</span></div></div>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251246389.png\" alt=\"库存数\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"库存数\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251246389.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">库存数</span></div></div>\n</li>\n<li><p>分析原因：事务和内存状态————Spring的@Transaction注解和JPA的工作机制</p>\n<ul>\n<li>一级缓存：当第一个请求通过findById加载了ID为1的商品后，这个product对象会被放入当前事务的一级缓存中。</li>\n<li>事务提交时才真正更新：productRepository.save(product)这个操作，并不是立即向数据库发送UPDATE语句，而要等到整个processSeckill方法执行完毕、事务准备提交时，才会生成并发送给数据库。</li>\n</ul>\n</li>\n<li><p>丢失的更新（stock&#x3D;80）：前十个线程有可能都加载到了还没有提交的product，即此时读到的stock依然是100，后面的九次更新覆盖了第一次更新，所以最终结果和只更新一次是完全一样的（stock变成了99）。每次都有一批线程在竞争，但最后只有一个线程的更新“活”到了最后，导致库存最终只减少了大约20次。</p>\n</li>\n<li><p>订单的正常建立（新增order数&#x3D;200）：orderRepository.save(order)这个操作，因为每个订单的主键都是自增的，并且（user_id,product_id）的组合也是唯一的，所以每一次订单的插入都能成功。</p>\n</li>\n</ul>\n<h4 id=\"3-改进\"><a href=\"#3-改进\" class=\"headerlink\" title=\"3. 改进\"></a>3. 改进</h4><h5 id=\"第一次尝试-在-processSeckill-方法上加-synchronized-锁\"><a href=\"#第一次尝试-在-processSeckill-方法上加-synchronized-锁\" class=\"headerlink\" title=\"第一次尝试-在 processSeckill 方法上加 synchronized 锁\"></a>第一次尝试-在 processSeckill 方法上加 synchronized 锁</h5><ul>\n<li>预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。</li>\n</ul>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span>  String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 1. 从数据库读取 Product 对象到内存</span></span><br><span class=\"line\">Optional&lt;Product&gt; productOpt = productRepository.findById(productId);</span><br><span class=\"line\"><span class=\"type\">Product</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> productOpt.get(); <span class=\"comment\">// 假设此时读到的 stock 是 100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... 其他检查 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在内存中计算新库存</span></span><br><span class=\"line\">product.setStock(product.getStock() - <span class=\"number\">1</span>); <span class=\"comment\">// 内存中的 stock 变为 99</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 将内存中的 Product 对象保存回数据库</span></span><br><span class=\"line\">productRepository.save(product); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 创建订单</span></span><br><span class=\"line\"><span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SeckillOrder</span>();</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">orderRepository.save(order);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>结果：数据依然错误，订单数为200，库存数为79,而吞吐量和平均响应时间没有发生明显变化。</li>\n<li>分析：@Transaction 与 synchronized 的冲突<ul>\n<li>当给一个方法加上@Transaction注解时，Spring为了能够控制事务的开启、提交和回滚，并不会让你直接调用这个方法，相反，Spring会在运行时创建一个该类的代理对象proxy。</li>\n<li>事务先生效：即代理对象的同名方法会被触发，代理对象会先开启一个事务</li>\n<li>synchronized被绕过：它是Java原生关键字，作用于对象实例的锁，但Spring的代理机制在调用目标方法时，可能会导致锁机制失效，因为代理方法本身没有synchronized，调用父类（本身SeckillService）的方法时，锁的上下文可能已经丢失或不准确。<br>即，Spring的AOP代理与Java原生的锁关键字之间存在冲突，代理绕过了锁，导致synchronized锁机制未生效。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"第二次尝试-在事务内使用ReentrantLock\"><a href=\"#第二次尝试-在事务内使用ReentrantLock\" class=\"headerlink\" title=\"第二次尝试-在事务内使用ReentrantLock\"></a>第二次尝试-在事务内使用ReentrantLock</h5><ul>\n<li><p>预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;  <span class=\"comment\">// 1. 事务由代理对象在这里开启</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 在方法开始时手动加锁</span></span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 所有业务逻辑都放在 try 块中</span></span><br><span class=\"line\">        <span class=\"comment\">// 其他检查</span></span><br><span class=\"line\"></span><br><span class=\"line\">        product.setStock(product.getStock() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        productRepository.save(product);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SeckillOrder</span>();</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        orderRepository.save(order);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！订单创建中...&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3. 【至关重要】在 finally 块中解锁，确保即使发生异常也能释放锁</span></span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;      <span class=\"comment\">// 4. 事务由代理对象在这里提交</span></span><br></pre></td></tr></table></figure></li>\n<li><p>显示控制：lock.lock()是代码逻辑的一部分，在代理调用了实际方法之后，业务逻辑执行之前被调用。任何线程进入这个方法后，都必须先获取到这个锁才能继续执行。</p>\n</li>\n<li><p>安全释放：使用try…finally结构，确保无论业务逻辑是否成功，锁最终都会被释放，避免了“死锁”的风险。</p>\n</li>\n<li><p>结果：数据依然错误，订单数为200，库存数为79,而吞吐量和平均响应时间没有发生明显变化。</p>\n</li>\n<li><p>分析：锁的范围 VS 事务的范围</p>\n<ul>\n<li>锁释放在前，事务提交在后，所以当线程A解锁后，UPDATE语句还没有提交进入数据库，而此时线程B立即取锁进入了方法，此时B读取到的库存数还是旧值。重演丢失更新问题。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"第三次尝试-ReentrantLock-手动事务\"><a href=\"#第三次尝试-ReentrantLock-手动事务\" class=\"headerlink\" title=\"第三次尝试-ReentrantLock + 手动事务\"></a>第三次尝试-ReentrantLock + 手动事务</h5><ul>\n<li><p>预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。</p>\n</li>\n<li><p>解决方案：将事务控制移入锁内</p>\n<ul>\n<li>放弃@Transaction注解，因为这个注解无法精细控制提交时机，改用最经典、最原始的手动事务管理。</li>\n<li>使用PlatformTransactionManager 来手动控制事务的开始、提交和回滚。将整个生命周期包裹在锁内。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> PlatformTransactionManager transactionManager;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 上锁</span></span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">DefaultTransactionDefinition</span> <span class=\"variable\">def</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultTransactionDefinition</span>();</span><br><span class=\"line\">    def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class=\"line\">    <span class=\"comment\">// 2. 开启事务</span></span><br><span class=\"line\">    <span class=\"type\">TransactionStatus</span> <span class=\"variable\">status</span> <span class=\"operator\">=</span> transactionManager.getTransaction(def);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...所有业务逻辑，和之前一样</span></span><br><span class=\"line\">        <span class=\"comment\">// 3. 【关键】在锁释放前，手动提交事务</span></span><br><span class=\"line\">        transactionManager.commit(status);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！订单创建中...&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//  如果发生任何异常，手动回滚事务</span></span><br><span class=\"line\">        transactionManager.rollback(status);</span><br><span class=\"line\">        <span class=\"comment\">// 将异常信息返回或记录日志</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> e.getMessage(); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 4. 最后，释放锁</span></span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>结果:数据正确，库存为0，订单数为100，吞吐量没有下降，甚至比没有并发控制的1.0 版本还要高。</p>\n</li>\n<li><p>分析: 在高并发场景下，无序的并发混乱，有时远比有序的串行执行要慢。下表为初始版本和三次尝试版本的压测数据。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Label</th>\n<th>样本</th>\n<th>平均值</th>\n<th>中位数</th>\n<th>90% 百分位</th>\n<th>95% 百分位</th>\n<th>99% 百分位</th>\n<th>最小值</th>\n<th>最大值</th>\n<th>异常 %</th>\n<th>吞吐量</th>\n<th>接收 KB&#x2F;sec</th>\n<th>发送 KB&#x2F;sec</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1.0秒杀系统</td>\n<td>200</td>\n<td>740</td>\n<td>810</td>\n<td>1044</td>\n<td>1078</td>\n<td>1083</td>\n<td>254</td>\n<td>1084</td>\n<td>0.00%</td>\n<td>95.92</td>\n<td>18.27</td>\n<td>20.51</td>\n</tr>\n<tr>\n<td>2.0秒杀系统_添加关键字synchronized</td>\n<td>200</td>\n<td>578</td>\n<td>598</td>\n<td>744</td>\n<td>763</td>\n<td>767</td>\n<td>79</td>\n<td>831</td>\n<td>0.00%</td>\n<td>113.38</td>\n<td>21.59</td>\n<td>24.24</td>\n</tr>\n<tr>\n<td>2.0秒杀系统_手动添加锁ReentrantLock</td>\n<td>200</td>\n<td>638</td>\n<td>663</td>\n<td>819</td>\n<td>837</td>\n<td>879</td>\n<td>237</td>\n<td>891</td>\n<td>0.00%</td>\n<td>105.76</td>\n<td>20.14</td>\n<td>22.62</td>\n</tr>\n<tr>\n<td>2.0秒杀系统_不使用@Transaction手动加锁</td>\n<td>200</td>\n<td>905</td>\n<td>1024</td>\n<td>1148</td>\n<td>1160</td>\n<td>1175</td>\n<td>203</td>\n<td>1178</td>\n<td>0.00%</td>\n<td>100.45</td>\n<td>18.25</td>\n<td>21.48</td>\n</tr>\n</tbody></table>\n<ul>\n<li>无锁版虽然看似并行，但造成了数据库层面大量的行锁竞争、唯一键冲突错误、事务回滚，这些“无效”的数据库操作成为了真正的性能瓶颈。而加锁后的版本，虽然在应用层是串行的，但它保护了数据库，向数据库发送的是一连串干净、有效的请求，避免了数据库的内部冲突和错误处理开销，因此整体系统的有效吞吐量反而更高。</li>\n</ul>\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"Transaction注解-一个请求的生命周期\"><a href=\"#Transaction注解-一个请求的生命周期\" class=\"headerlink\" title=\"@Transaction注解 &amp; 一个请求的生命周期\"></a>@Transaction注解 &amp; 一个请求的生命周期</h4><ul>\n<li>Controller接受请求，调用Service方法，但此时Service引用的是Spring的代理对象，而不是原始实例。代理对象的方法被触发，检查到方法上有@Transaction注解，代理对象向事务管理器（platformTransactionManager）请求开启一个新的事务。从数据库连接池中获取一个数据库连接，向MySQL服务器发送指令。此时一个数据库事务的“上下文”已经建立，但还没有任何实际的业务SQL被执行。在开启事务后，代理对象才会调用原始实例的方法，开始执行业务逻辑。但需要注意的是，这个阶段中是没有发生任何数据库操作的，只是告诉JPA的持久化上下文，标记了该对象，后续需要“留意”。</li>\n<li>所有代码都执行完毕后，到达return语句，准备将结果返回。此时代理对象接收到真实方法的返回值，因为没有捕获到任何异常，代理对象判断这次业务执行是成功的，通知事务管理器可以提交事务了。事务管理器执行数据库同步，在真正COMMIT之前，JPA会执行一次Flush，生成SQL语句，发送到MYSQL服务器并执行，直到COMMIT被成功执行了，这次更新才被永久地鞋屋数据库磁盘。</li>\n<li>代理对象将你方法的返回值传递给Controller，Controller再将其封装成HTTP响应返回给用户。</li>\n</ul>\n<h4 id=\"锁-初步\"><a href=\"#锁-初步\" class=\"headerlink\" title=\"锁-初步\"></a>锁-初步</h4><ol>\n<li>Synchronized：Keyword、JVM内置的同步原语，简单、隐式的加锁和解锁机制。</li>\n</ol>\n<ul>\n<li>使用方法：修饰实例方法、修饰静态方法、修饰代码块。</li>\n<li>实现依赖于每个Java对象头部的Mark Word和JVM内部的Monitor对象监视器（当线程尝试获取锁时，JVM会执行Monitorenter字节码指令，尝试获得对象Monitor所有权。释放锁时即执行monitorexit）。</li>\n<li>锁升级机制：偏向锁—&gt;轻量级锁(当有第二个线程竞争时升级，竞争的线程通过自旋和CAS来尝试获取锁，不进入阻塞状态)—&gt;重量级锁（竞争加剧，自旋失败，升级，未获取到锁的线程会被阻塞，由内核进行调度，性能开销最大）</li>\n</ul>\n<ol start=\"2\">\n<li>ReentrantLock：是JUC工具包的核心成员，显式加锁和解锁机制。</li>\n</ol>\n<ul>\n<li>使用方法：标准的使用范式  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 在类中声明一个 Lock 实例</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">someMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 2. 在 try...finally 结构中进行加锁和解锁</span></span><br><span class=\"line\">lock.lock(); <span class=\"comment\">// 获取锁</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 3. 保护的同步代码</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 4. 必须在 finally 块中释放锁</span></span><br><span class=\"line\">lock.unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>实现依赖于JUC的核心框架AQS，所有获取锁失败的线程，会被封装成节点放入一个CLH虚拟双向队列中进行排队等待。当锁被释放时，会从队列头部唤醒下一个等待的线程。整个过程都在用户态完成，避免了频繁的内核态切换。<blockquote>\n<p>AQS 内部通过一个 <code>volatile</code> 的 <code>int</code> 类型的 <code>state</code> 变量来表示同步状态（0表示未锁定，&gt;0表示已锁定），并使用 <strong>CAS</strong> 操作来原子性地修改这个 <code>state</code> 值。</p>\n</blockquote>\n</li>\n<li>功能丰富：等待可中断（等待锁的线程可被中断）、可实现公平锁（按线程请求的顺序获取锁）、可实现非公平锁（允许插队、吞吐量更高）、可尝试获取锁（可在指定时间内尝试获取锁，失败则返回）、可绑定多个条件（可分组唤醒等待的线程，实现更精细的线程通信）</li>\n</ul>\n<p>选择问题：在绝大多数情况下，当并发冲突不激烈、同步逻辑简单时，优先选择Synchronized关键字，在特定的场景下，比如需要使用Synchronized不具备的高级功能时，或者是在我的秒杀项目中，需要将事务提交的完整过程都包裹在锁内，即手动控制锁时。</p>\n"},{"title":"friends","date":"2025-09-30T13:10:40.000Z","layout":"friends","_content":"","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2025-09-30 21:10:40\nlayout: friends # 关键！指定使用 friends 布局\n---\n","updated":"2025-09-30T13:11:07.169Z","path":"friends/index.html","comments":1,"_id":"cmgdn5rh200080wuz4ag96tr8","content":"","excerpt":"","more":""},{"wiki":"Seckill","title":"1-秒杀项目1.2-流量控制","tags":["Spring Boot","高并发","JUC"],"categories":["项目实战"],"poster":{"topic":"标题上方的小字","headline":"大标题","caption":"标题下方的小字","color":"标题颜色"},"date":"2025-10-03T03:54:25.000Z","description":"重新起航版","cover":null,"banner":null,"sticky":null,"mermaid":null,"katex":null,"mathjax":null,"topic":null,"author":null,"references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n### 场景升级：引入流量控制\n- 在V1.1中，通过读写锁优化了系统的读性能，但留下了一个隐患，如果秒杀的“写”操作本身很耗时（比如需要调用外部API、复杂的数据库操作等），那么大量的写请求会在WriteLock.lock()处排起长队。这些排队的线程会持续占用着宝贵的服务器线程资源，当数量过多时，足以耗尽资源导致整个应用崩溃。\n- V1.2的核心目标就是，在进入核心业务逻辑之前，先进行流量控制，只允许有限数量的请求进入，从而保护系统不被瞬时流量冲垮。\n#### 代码改写\n- 加入semaphore信号量\n- 加入`Thread.sleep(1000)`,模拟耗时的写操作。\n```Java\n  public String processSeckill(Long productId, Long userId) {\n    try {\n      // 带超时的尝试获取：在指定时间内获取不到，就放弃，避免无限等待\n      if (!semaphore.tryAcquire(3, TimeUnit.SECONDS)) {\n        return \"服务器繁忙，请稍后再试！\";\n      }\n      // 这模拟了这样一种场景：比如，每个秒杀请求都需要先调用一个外部、\n      // 独立的、耗时1秒的API（如风控验证），这个API调用本身是可以并行的。\n      try {\n          Thread.sleep(1000); \n      } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      writeLock.lock();\n      try {\n        // ... 之前的完整手动事务逻辑 ...\n      } finally {\n          writeLock.unlock();\n        }\n    } catch (InterruptedException e) {\n        // 线程在等待许可时被中断\n        Thread.currentThread().interrupt(); // 重新设置中断状态\n        return \"请求被中断，请重试。\";\n      } finally {\n          semaphore.release();\n        }               \n  }\n```\n- 最多10个线程可以同时获取到Semaphore许可。\n- 这十个线程同时开始执行Thread.sleep(1000)，模拟10个并行的慢操作。\n- 1秒后，这10个线程几乎同时结束sleep，然后去竞争writeLock。\n- WriteLock会确保他们一个一个地串行地完成数据库操作。\n#### JMeter设置\n- 保留写请求线程组\n- 线程数：50\n- Ramp-up Period : 1（模拟瞬时的大流量）\n- 循环次数：1\n#### 压测结果与分析\n- 预期结果：吞吐量应该为10/sec左右，即一秒钟内可以处理大约10个（由Semaphore信号量控制，而获取写锁之后的业务逻辑耗时极短）请求。\n- 结果：吞吐量为19.8/sec\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510031245633.png JMeter聚合报告%}\n- 分析：信号量泄漏-代码中的逻辑bug\n - 当其中的某一个线程获取许可失败，会`return \"服务器繁忙，请稍后再试！`，而无论try块中的代码是否正常结束，finally块中的代码都一定正常执行：`semaphore.release();`，也就是说，不管线程是否申请到了许可，都会执行finally块，即Semaphore内部的可用许可量可能会持续增加到10个以上。\n - 使最后的结果显示——吞吐量：19.8/sec。\n### 改进：代码中的逻辑bug\n#### 调整代码\n- 修复：只有在成功获取到资源后，才能进入释放资源的finally块。\n```Java\n  // 简化结构\n  public String processSeckill(...) {\n    if (semaphore.tryAcquire(...)) { // 1. 先过“信号量”这道门（10个并发名额）\n        try {\n            Thread.sleep(1000);      // 2. 执行耗时1秒的【可并行】操作\n            \n            writeLock.lock();        // 3. 再过“写锁”这道门（1个并发名额）\n            try {\n                // 4. 执行耗时极短的【串行】数据库操作\n            } finally {\n                writeLock.unlock();\n            }\n        } finally {\n            semaphore.release();\n        }\n    }\n}\n```\n#### 压测结果与分析\n- 结果：吞吐量为11.1/sec\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510031307073.png JMeter聚合报告 %}\n- 分析：\n  - 流程: 10个线程并行 sleep -> 串行 writeLock\n  - 总耗时 (处理50个请求): 50/10 批 * 1秒/批 ≈ 5秒\n  - 吞吐量: 50 / 5s ≈ 10/sec\n- 当没有Semaphore时，吞吐量为20/sec。\n  - 流程: 50个线程并行 sleep -> 串行 writeLock\n  - 总耗时 (处理50个请求): 1秒 (并行sleep) + 50 * 数据库耗时 ≈ 2~3秒\n  - 吞吐量: 50 / ~2.5s ≈ 20/sec\n\n- 证明了Semaphore流量控制的功能是生效的，它的作用不是提升性能，而是约束性能，防止过多的并发请求将系统资源耗尽，从而保证系统的稳定性。\n### 学学八股\n#### Semaphore\n- 是JUC包提供的一个并发流程控制工具，在内部维护了一组“许可”，线程在执行前必须先获取一个许可，执行完毕后再归还许可。当许可被全部分发完毕后，其他没有获取到许可的线程就必须等待，直到有线程释放许可。\n- 核心思想：通过有限的许可，来控制同一时间能够访问特定资源或执行特定代码块的线程数量。\n- 核心方法：\n  - `acquire()`:阻塞式的获取一个许可。如果当前没有可用的许可，线程将进入休眠状态并排队等待，直到有其他线程调用release()。\n  - `release()`:释放一个许可。信号量内部的许可计数会+1，如果此时有等待的线程，队列中的第一个线程将被唤醒。\n  - `tryAcquire()`:非阻塞式的尝试获取许可。立即返回，成功为true，失败为false。\n  - `tryAcquire(long timeout,TimeUnit unit)`:在指定时间内获取许可，如果超时仍未获取到，则返回false。\n- 底层原理：和ReentrantLock一样，Semaphore的底层也是基于AQS构建\n  - state：AQS内部的int state 变量，在Semaphore中代表了当前可用的许可数量。\n  - 获取许可：对应AQS的共享模式获取，线程会通过CAS操作尝试将state-1，如果减1之后state的值仍然大于等于0，则获取成功。否则获取失败，线程会被打包成节点放入等待队列中并挂起、\n  - 释放许可：对应AQS的共享模式释放，线程会通过CAS操作将state+1，释放成功后，会唤醒等待队列中的后继线程。\n- 关键特性与使用场景：\n  - Semaphore支持公平和非公平两种模式。\n  - 核心使用场景\n    - 流量控制/限流：防止瞬时大量请求冲垮下游服务。\n    - 管理有限的资源池：比如控制同时访问数据库的连接数，或者控制同时使用某个昂贵计算资源的任务数。","source":"wiki/Seckill/1-秒杀项目1.2-流量控制.md","raw":"---\nwiki: Seckill # 这是项目id，对应 /data/wiki/hexo-stellar.yml\ntitle: 1-秒杀项目1.2-流量控制\ntags: [Spring Boot,高并发,JUC]\ncategories: [项目实战]\nposter:\n  topic: 标题上方的小字\n  headline: 大标题\n  caption: 标题下方的小字\n  color: 标题颜色\ndate: 2025-10-03 11:54:25\ndescription: 重新起航版\ncover:\nbanner:\nsticky:\nmermaid:\nkatex:\nmathjax:\ntopic:\nauthor:\nreferences:\ncomments:\nindexing:\nbreadcrumb:\nleftbar:\nrightbar:\nh1:\ntype: tech\n---\n\n### 场景升级：引入流量控制\n- 在V1.1中，通过读写锁优化了系统的读性能，但留下了一个隐患，如果秒杀的“写”操作本身很耗时（比如需要调用外部API、复杂的数据库操作等），那么大量的写请求会在WriteLock.lock()处排起长队。这些排队的线程会持续占用着宝贵的服务器线程资源，当数量过多时，足以耗尽资源导致整个应用崩溃。\n- V1.2的核心目标就是，在进入核心业务逻辑之前，先进行流量控制，只允许有限数量的请求进入，从而保护系统不被瞬时流量冲垮。\n#### 代码改写\n- 加入semaphore信号量\n- 加入`Thread.sleep(1000)`,模拟耗时的写操作。\n```Java\n  public String processSeckill(Long productId, Long userId) {\n    try {\n      // 带超时的尝试获取：在指定时间内获取不到，就放弃，避免无限等待\n      if (!semaphore.tryAcquire(3, TimeUnit.SECONDS)) {\n        return \"服务器繁忙，请稍后再试！\";\n      }\n      // 这模拟了这样一种场景：比如，每个秒杀请求都需要先调用一个外部、\n      // 独立的、耗时1秒的API（如风控验证），这个API调用本身是可以并行的。\n      try {\n          Thread.sleep(1000); \n      } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      writeLock.lock();\n      try {\n        // ... 之前的完整手动事务逻辑 ...\n      } finally {\n          writeLock.unlock();\n        }\n    } catch (InterruptedException e) {\n        // 线程在等待许可时被中断\n        Thread.currentThread().interrupt(); // 重新设置中断状态\n        return \"请求被中断，请重试。\";\n      } finally {\n          semaphore.release();\n        }               \n  }\n```\n- 最多10个线程可以同时获取到Semaphore许可。\n- 这十个线程同时开始执行Thread.sleep(1000)，模拟10个并行的慢操作。\n- 1秒后，这10个线程几乎同时结束sleep，然后去竞争writeLock。\n- WriteLock会确保他们一个一个地串行地完成数据库操作。\n#### JMeter设置\n- 保留写请求线程组\n- 线程数：50\n- Ramp-up Period : 1（模拟瞬时的大流量）\n- 循环次数：1\n#### 压测结果与分析\n- 预期结果：吞吐量应该为10/sec左右，即一秒钟内可以处理大约10个（由Semaphore信号量控制，而获取写锁之后的业务逻辑耗时极短）请求。\n- 结果：吞吐量为19.8/sec\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510031245633.png JMeter聚合报告%}\n- 分析：信号量泄漏-代码中的逻辑bug\n - 当其中的某一个线程获取许可失败，会`return \"服务器繁忙，请稍后再试！`，而无论try块中的代码是否正常结束，finally块中的代码都一定正常执行：`semaphore.release();`，也就是说，不管线程是否申请到了许可，都会执行finally块，即Semaphore内部的可用许可量可能会持续增加到10个以上。\n - 使最后的结果显示——吞吐量：19.8/sec。\n### 改进：代码中的逻辑bug\n#### 调整代码\n- 修复：只有在成功获取到资源后，才能进入释放资源的finally块。\n```Java\n  // 简化结构\n  public String processSeckill(...) {\n    if (semaphore.tryAcquire(...)) { // 1. 先过“信号量”这道门（10个并发名额）\n        try {\n            Thread.sleep(1000);      // 2. 执行耗时1秒的【可并行】操作\n            \n            writeLock.lock();        // 3. 再过“写锁”这道门（1个并发名额）\n            try {\n                // 4. 执行耗时极短的【串行】数据库操作\n            } finally {\n                writeLock.unlock();\n            }\n        } finally {\n            semaphore.release();\n        }\n    }\n}\n```\n#### 压测结果与分析\n- 结果：吞吐量为11.1/sec\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510031307073.png JMeter聚合报告 %}\n- 分析：\n  - 流程: 10个线程并行 sleep -> 串行 writeLock\n  - 总耗时 (处理50个请求): 50/10 批 * 1秒/批 ≈ 5秒\n  - 吞吐量: 50 / 5s ≈ 10/sec\n- 当没有Semaphore时，吞吐量为20/sec。\n  - 流程: 50个线程并行 sleep -> 串行 writeLock\n  - 总耗时 (处理50个请求): 1秒 (并行sleep) + 50 * 数据库耗时 ≈ 2~3秒\n  - 吞吐量: 50 / ~2.5s ≈ 20/sec\n\n- 证明了Semaphore流量控制的功能是生效的，它的作用不是提升性能，而是约束性能，防止过多的并发请求将系统资源耗尽，从而保证系统的稳定性。\n### 学学八股\n#### Semaphore\n- 是JUC包提供的一个并发流程控制工具，在内部维护了一组“许可”，线程在执行前必须先获取一个许可，执行完毕后再归还许可。当许可被全部分发完毕后，其他没有获取到许可的线程就必须等待，直到有线程释放许可。\n- 核心思想：通过有限的许可，来控制同一时间能够访问特定资源或执行特定代码块的线程数量。\n- 核心方法：\n  - `acquire()`:阻塞式的获取一个许可。如果当前没有可用的许可，线程将进入休眠状态并排队等待，直到有其他线程调用release()。\n  - `release()`:释放一个许可。信号量内部的许可计数会+1，如果此时有等待的线程，队列中的第一个线程将被唤醒。\n  - `tryAcquire()`:非阻塞式的尝试获取许可。立即返回，成功为true，失败为false。\n  - `tryAcquire(long timeout,TimeUnit unit)`:在指定时间内获取许可，如果超时仍未获取到，则返回false。\n- 底层原理：和ReentrantLock一样，Semaphore的底层也是基于AQS构建\n  - state：AQS内部的int state 变量，在Semaphore中代表了当前可用的许可数量。\n  - 获取许可：对应AQS的共享模式获取，线程会通过CAS操作尝试将state-1，如果减1之后state的值仍然大于等于0，则获取成功。否则获取失败，线程会被打包成节点放入等待队列中并挂起、\n  - 释放许可：对应AQS的共享模式释放，线程会通过CAS操作将state+1，释放成功后，会唤醒等待队列中的后继线程。\n- 关键特性与使用场景：\n  - Semaphore支持公平和非公平两种模式。\n  - 核心使用场景\n    - 流量控制/限流：防止瞬时大量请求冲垮下游服务。\n    - 管理有限的资源池：比如控制同时访问数据库的连接数，或者控制同时使用某个昂贵计算资源的任务数。","updated":"2025-10-03T05:51:23.308Z","path":"wiki/Seckill/1-秒杀项目1.2-流量控制.html","layout":"page","_id":"cmgdn5rh3000a0wuz7ip99dx6","content":"<h3 id=\"场景升级：引入流量控制\"><a href=\"#场景升级：引入流量控制\" class=\"headerlink\" title=\"场景升级：引入流量控制\"></a>场景升级：引入流量控制</h3><ul>\n<li>在V1.1中，通过读写锁优化了系统的读性能，但留下了一个隐患，如果秒杀的“写”操作本身很耗时（比如需要调用外部API、复杂的数据库操作等），那么大量的写请求会在WriteLock.lock()处排起长队。这些排队的线程会持续占用着宝贵的服务器线程资源，当数量过多时，足以耗尽资源导致整个应用崩溃。</li>\n<li>V1.2的核心目标就是，在进入核心业务逻辑之前，先进行流量控制，只允许有限数量的请求进入，从而保护系统不被瞬时流量冲垮。</li>\n</ul>\n<h4 id=\"代码改写\"><a href=\"#代码改写\" class=\"headerlink\" title=\"代码改写\"></a>代码改写</h4><ul>\n<li>加入semaphore信号量</li>\n<li>加入<code>Thread.sleep(1000)</code>,模拟耗时的写操作。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 带超时的尝试获取：在指定时间内获取不到，就放弃，避免无限等待</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!semaphore.tryAcquire(<span class=\"number\">3</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;服务器繁忙，请稍后再试！&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这模拟了这样一种场景：比如，每个秒杀请求都需要先调用一个外部、</span></span><br><span class=\"line\">    <span class=\"comment\">// 独立的、耗时1秒的API（如风控验证），这个API调用本身是可以并行的。</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        Thread.currentThread().interrupt();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    writeLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... 之前的完整手动事务逻辑 ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        writeLock.unlock();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 线程在等待许可时被中断</span></span><br><span class=\"line\">      Thread.currentThread().interrupt(); <span class=\"comment\">// 重新设置中断状态</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;请求被中断，请重试。&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        semaphore.release();</span><br><span class=\"line\">      &#125;               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>最多10个线程可以同时获取到Semaphore许可。</li>\n<li>这十个线程同时开始执行Thread.sleep(1000)，模拟10个并行的慢操作。</li>\n<li>1秒后，这10个线程几乎同时结束sleep，然后去竞争writeLock。</li>\n<li>WriteLock会确保他们一个一个地串行地完成数据库操作。</li>\n</ul>\n<h4 id=\"JMeter设置\"><a href=\"#JMeter设置\" class=\"headerlink\" title=\"JMeter设置\"></a>JMeter设置</h4><ul>\n<li>保留写请求线程组</li>\n<li>线程数：50</li>\n<li>Ramp-up Period : 1（模拟瞬时的大流量）</li>\n<li>循环次数：1</li>\n</ul>\n<h4 id=\"压测结果与分析\"><a href=\"#压测结果与分析\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li>预期结果：吞吐量应该为10&#x2F;sec左右，即一秒钟内可以处理大约10个（由Semaphore信号量控制，而获取写锁之后的业务逻辑耗时极短）请求。</li>\n<li>结果：吞吐量为19.8&#x2F;sec<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510031245633.png\" alt=\"JMeter聚合报告\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">JMeter聚合报告</span></div></div></li>\n<li>分析：信号量泄漏-代码中的逻辑bug</li>\n<li>当其中的某一个线程获取许可失败，会<code>return &quot;服务器繁忙，请稍后再试！</code>，而无论try块中的代码是否正常结束，finally块中的代码都一定正常执行：<code>semaphore.release();</code>，也就是说，不管线程是否申请到了许可，都会执行finally块，即Semaphore内部的可用许可量可能会持续增加到10个以上。</li>\n<li>使最后的结果显示——吞吐量：19.8&#x2F;sec。</li>\n</ul>\n<h3 id=\"改进：代码中的逻辑bug\"><a href=\"#改进：代码中的逻辑bug\" class=\"headerlink\" title=\"改进：代码中的逻辑bug\"></a>改进：代码中的逻辑bug</h3><h4 id=\"调整代码\"><a href=\"#调整代码\" class=\"headerlink\" title=\"调整代码\"></a>调整代码</h4><ul>\n<li>修复：只有在成功获取到资源后，才能进入释放资源的finally块。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 简化结构</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (semaphore.tryAcquire(...)) &#123; <span class=\"comment\">// 1. 先过“信号量”这道门（10个并发名额）</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);      <span class=\"comment\">// 2. 执行耗时1秒的【可并行】操作</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            writeLock.lock();        <span class=\"comment\">// 3. 再过“写锁”这道门（1个并发名额）</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 4. 执行耗时极短的【串行】数据库操作</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                writeLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            semaphore.release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"压测结果与分析-1\"><a href=\"#压测结果与分析-1\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li><p>结果：吞吐量为11.1&#x2F;sec</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510031307073.png\" alt=\"JMeter聚合报告\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">JMeter聚合报告</span></div></div></li>\n<li><p>分析：</p>\n<ul>\n<li>流程: 10个线程并行 sleep -&gt; 串行 writeLock</li>\n<li>总耗时 (处理50个请求): 50&#x2F;10 批 * 1秒&#x2F;批 ≈ 5秒</li>\n<li>吞吐量: 50 &#x2F; 5s ≈ 10&#x2F;sec</li>\n</ul>\n</li>\n<li><p>当没有Semaphore时，吞吐量为20&#x2F;sec。</p>\n<ul>\n<li>流程: 50个线程并行 sleep -&gt; 串行 writeLock</li>\n<li>总耗时 (处理50个请求): 1秒 (并行sleep) + 50 * 数据库耗时 ≈ 2~3秒</li>\n<li>吞吐量: 50 &#x2F; ~2.5s ≈ 20&#x2F;sec</li>\n</ul>\n</li>\n<li><p>证明了Semaphore流量控制的功能是生效的，它的作用不是提升性能，而是约束性能，防止过多的并发请求将系统资源耗尽，从而保证系统的稳定性。</p>\n</li>\n</ul>\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h4><ul>\n<li>是JUC包提供的一个并发流程控制工具，在内部维护了一组“许可”，线程在执行前必须先获取一个许可，执行完毕后再归还许可。当许可被全部分发完毕后，其他没有获取到许可的线程就必须等待，直到有线程释放许可。</li>\n<li>核心思想：通过有限的许可，来控制同一时间能够访问特定资源或执行特定代码块的线程数量。</li>\n<li>核心方法：<ul>\n<li><code>acquire()</code>:阻塞式的获取一个许可。如果当前没有可用的许可，线程将进入休眠状态并排队等待，直到有其他线程调用release()。</li>\n<li><code>release()</code>:释放一个许可。信号量内部的许可计数会+1，如果此时有等待的线程，队列中的第一个线程将被唤醒。</li>\n<li><code>tryAcquire()</code>:非阻塞式的尝试获取许可。立即返回，成功为true，失败为false。</li>\n<li><code>tryAcquire(long timeout,TimeUnit unit)</code>:在指定时间内获取许可，如果超时仍未获取到，则返回false。</li>\n</ul>\n</li>\n<li>底层原理：和ReentrantLock一样，Semaphore的底层也是基于AQS构建<ul>\n<li>state：AQS内部的int state 变量，在Semaphore中代表了当前可用的许可数量。</li>\n<li>获取许可：对应AQS的共享模式获取，线程会通过CAS操作尝试将state-1，如果减1之后state的值仍然大于等于0，则获取成功。否则获取失败，线程会被打包成节点放入等待队列中并挂起、</li>\n<li>释放许可：对应AQS的共享模式释放，线程会通过CAS操作将state+1，释放成功后，会唤醒等待队列中的后继线程。</li>\n</ul>\n</li>\n<li>关键特性与使用场景：<ul>\n<li>Semaphore支持公平和非公平两种模式。</li>\n<li>核心使用场景<ul>\n<li>流量控制&#x2F;限流：防止瞬时大量请求冲垮下游服务。</li>\n<li>管理有限的资源池：比如控制同时访问数据库的连接数，或者控制同时使用某个昂贵计算资源的任务数。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"场景升级：引入流量控制\"><a href=\"#场景升级：引入流量控制\" class=\"headerlink\" title=\"场景升级：引入流量控制\"></a>场景升级：引入流量控制</h3><ul>\n<li>在V1.1中，通过读写锁优化了系统的读性能，但留下了一个隐患，如果秒杀的“写”操作本身很耗时（比如需要调用外部API、复杂的数据库操作等），那么大量的写请求会在WriteLock.lock()处排起长队。这些排队的线程会持续占用着宝贵的服务器线程资源，当数量过多时，足以耗尽资源导致整个应用崩溃。</li>\n<li>V1.2的核心目标就是，在进入核心业务逻辑之前，先进行流量控制，只允许有限数量的请求进入，从而保护系统不被瞬时流量冲垮。</li>\n</ul>\n<h4 id=\"代码改写\"><a href=\"#代码改写\" class=\"headerlink\" title=\"代码改写\"></a>代码改写</h4><ul>\n<li>加入semaphore信号量</li>\n<li>加入<code>Thread.sleep(1000)</code>,模拟耗时的写操作。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 带超时的尝试获取：在指定时间内获取不到，就放弃，避免无限等待</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!semaphore.tryAcquire(<span class=\"number\">3</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;服务器繁忙，请稍后再试！&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这模拟了这样一种场景：比如，每个秒杀请求都需要先调用一个外部、</span></span><br><span class=\"line\">    <span class=\"comment\">// 独立的、耗时1秒的API（如风控验证），这个API调用本身是可以并行的。</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        Thread.currentThread().interrupt();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    writeLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... 之前的完整手动事务逻辑 ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        writeLock.unlock();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 线程在等待许可时被中断</span></span><br><span class=\"line\">      Thread.currentThread().interrupt(); <span class=\"comment\">// 重新设置中断状态</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;请求被中断，请重试。&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        semaphore.release();</span><br><span class=\"line\">      &#125;               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>最多10个线程可以同时获取到Semaphore许可。</li>\n<li>这十个线程同时开始执行Thread.sleep(1000)，模拟10个并行的慢操作。</li>\n<li>1秒后，这10个线程几乎同时结束sleep，然后去竞争writeLock。</li>\n<li>WriteLock会确保他们一个一个地串行地完成数据库操作。</li>\n</ul>\n<h4 id=\"JMeter设置\"><a href=\"#JMeter设置\" class=\"headerlink\" title=\"JMeter设置\"></a>JMeter设置</h4><ul>\n<li>保留写请求线程组</li>\n<li>线程数：50</li>\n<li>Ramp-up Period : 1（模拟瞬时的大流量）</li>\n<li>循环次数：1</li>\n</ul>\n<h4 id=\"压测结果与分析\"><a href=\"#压测结果与分析\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li>预期结果：吞吐量应该为10&#x2F;sec左右，即一秒钟内可以处理大约10个（由Semaphore信号量控制，而获取写锁之后的业务逻辑耗时极短）请求。</li>\n<li>结果：吞吐量为19.8&#x2F;sec<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510031245633.png\" alt=\"JMeter聚合报告\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">JMeter聚合报告</span></div></div></li>\n<li>分析：信号量泄漏-代码中的逻辑bug</li>\n<li>当其中的某一个线程获取许可失败，会<code>return &quot;服务器繁忙，请稍后再试！</code>，而无论try块中的代码是否正常结束，finally块中的代码都一定正常执行：<code>semaphore.release();</code>，也就是说，不管线程是否申请到了许可，都会执行finally块，即Semaphore内部的可用许可量可能会持续增加到10个以上。</li>\n<li>使最后的结果显示——吞吐量：19.8&#x2F;sec。</li>\n</ul>\n<h3 id=\"改进：代码中的逻辑bug\"><a href=\"#改进：代码中的逻辑bug\" class=\"headerlink\" title=\"改进：代码中的逻辑bug\"></a>改进：代码中的逻辑bug</h3><h4 id=\"调整代码\"><a href=\"#调整代码\" class=\"headerlink\" title=\"调整代码\"></a>调整代码</h4><ul>\n<li>修复：只有在成功获取到资源后，才能进入释放资源的finally块。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 简化结构</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (semaphore.tryAcquire(...)) &#123; <span class=\"comment\">// 1. 先过“信号量”这道门（10个并发名额）</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);      <span class=\"comment\">// 2. 执行耗时1秒的【可并行】操作</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            writeLock.lock();        <span class=\"comment\">// 3. 再过“写锁”这道门（1个并发名额）</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 4. 执行耗时极短的【串行】数据库操作</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                writeLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            semaphore.release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"压测结果与分析-1\"><a href=\"#压测结果与分析-1\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li><p>结果：吞吐量为11.1&#x2F;sec</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510031307073.png\" alt=\"JMeter聚合报告\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">JMeter聚合报告</span></div></div></li>\n<li><p>分析：</p>\n<ul>\n<li>流程: 10个线程并行 sleep -&gt; 串行 writeLock</li>\n<li>总耗时 (处理50个请求): 50&#x2F;10 批 * 1秒&#x2F;批 ≈ 5秒</li>\n<li>吞吐量: 50 &#x2F; 5s ≈ 10&#x2F;sec</li>\n</ul>\n</li>\n<li><p>当没有Semaphore时，吞吐量为20&#x2F;sec。</p>\n<ul>\n<li>流程: 50个线程并行 sleep -&gt; 串行 writeLock</li>\n<li>总耗时 (处理50个请求): 1秒 (并行sleep) + 50 * 数据库耗时 ≈ 2~3秒</li>\n<li>吞吐量: 50 &#x2F; ~2.5s ≈ 20&#x2F;sec</li>\n</ul>\n</li>\n<li><p>证明了Semaphore流量控制的功能是生效的，它的作用不是提升性能，而是约束性能，防止过多的并发请求将系统资源耗尽，从而保证系统的稳定性。</p>\n</li>\n</ul>\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h4><ul>\n<li>是JUC包提供的一个并发流程控制工具，在内部维护了一组“许可”，线程在执行前必须先获取一个许可，执行完毕后再归还许可。当许可被全部分发完毕后，其他没有获取到许可的线程就必须等待，直到有线程释放许可。</li>\n<li>核心思想：通过有限的许可，来控制同一时间能够访问特定资源或执行特定代码块的线程数量。</li>\n<li>核心方法：<ul>\n<li><code>acquire()</code>:阻塞式的获取一个许可。如果当前没有可用的许可，线程将进入休眠状态并排队等待，直到有其他线程调用release()。</li>\n<li><code>release()</code>:释放一个许可。信号量内部的许可计数会+1，如果此时有等待的线程，队列中的第一个线程将被唤醒。</li>\n<li><code>tryAcquire()</code>:非阻塞式的尝试获取许可。立即返回，成功为true，失败为false。</li>\n<li><code>tryAcquire(long timeout,TimeUnit unit)</code>:在指定时间内获取许可，如果超时仍未获取到，则返回false。</li>\n</ul>\n</li>\n<li>底层原理：和ReentrantLock一样，Semaphore的底层也是基于AQS构建<ul>\n<li>state：AQS内部的int state 变量，在Semaphore中代表了当前可用的许可数量。</li>\n<li>获取许可：对应AQS的共享模式获取，线程会通过CAS操作尝试将state-1，如果减1之后state的值仍然大于等于0，则获取成功。否则获取失败，线程会被打包成节点放入等待队列中并挂起、</li>\n<li>释放许可：对应AQS的共享模式释放，线程会通过CAS操作将state+1，释放成功后，会唤醒等待队列中的后继线程。</li>\n</ul>\n</li>\n<li>关键特性与使用场景：<ul>\n<li>Semaphore支持公平和非公平两种模式。</li>\n<li>核心使用场景<ul>\n<li>流量控制&#x2F;限流：防止瞬时大量请求冲垮下游服务。</li>\n<li>管理有限的资源池：比如控制同时访问数据库的连接数，或者控制同时使用某个昂贵计算资源的任务数。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"wiki":"Seckill","title":"1-秒杀项目1.1-读写分离","tags":["Spring Boot","高并发","JUC"],"categories":["项目实战"],"poster":{"topic":"标题上方的小字","headline":"大标题","caption":"标题下方的小字","color":"标题颜色"},"date":"2025-10-01T08:44:13.000Z","description":"重新起航版","cover":null,"banner":null,"sticky":null,"mermaid":null,"katex":null,"mathjax":null,"topic":null,"author":null,"references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n### 一、最初的构想：引入读写锁\n- 在秒杀开始前，有成千上万的用户疯狂刷新商品详情页，他们只是想看看库存还剩下多少，即进行读操作。在当前的实现下，大量的读请求也必须排队等待获取ReentrantLock，严重影响了用户体验。这是一个典型的“读多写少”的场景，所以引入读写锁。\n#### 改写代码\n- 重构SeckillService，将业务逻辑拆分出两个核心方法：\n  - checkStock(): 专门用于查询库存，使用读锁。\n  \n  ```Java\n  /*\n    * 新增方法，用于查询商品库存，专门用于处理读请求\n    * 使用读写锁中的读锁，允许并发读取，互不堵塞\n  */\n  public Integer checkStock(Long productId) {\n    log.info(\"线程 {} 尝试获取读锁...\", Thread.currentThread().getName());\n    readLock.lock(); // 读操作上读锁\n    log.info(\"线程 {} 成功获取到读锁\", Thread.currentThread().getName());\n    try {\n        Optional<Product> productOpt = productRepository.findById(productId);\n        if (!productOpt.isPresent()) {\n            throw new RuntimeException(\"商品不存在\");\n        }\n        log.info(\"线程 {} 读取库存为: {}\", Thread.currentThread().getName(), productOpt.get().getStock());\n        return productOpt.get().getStock();\n    } finally {\n        log.info(\"线程 {} 准备释放读锁.\", Thread.currentThread().getName());\n        readLock.unlock();\n    }\n  }\n  ```\n  - processSeckill(): 负责执行秒杀下单，使用写锁\n   ```Java\n    public String processSeckill(Long productId, Long userId) {\n        log.info(\"线程 {} 尝试获取写锁...\", Thread.currentThread().getName());\n        writeLock.lock(); // 2. 秒杀操作上写锁，确保互斥\n        log.info(\"线程 {} 成功获取到写锁\", Thread.currentThread().getName());\n        // 3. 定义事务\n        DefaultTransactionDefinition def = new DefaultTransactionDefinition();\n        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n        // 4. 开启事务\n        TransactionStatus status = transactionManager.getTransaction(def);\n\n        try {\n            // ...所有业务逻辑，和之前一样\n            // 5. 【关键】在锁释放前，手动提交事务\n            transactionManager.commit(status);\n            log.info(\"线程 {} 秒杀成功，提交事务。\", Thread.currentThread().getName());\n\n            return \"秒杀成功！订单创建中...\";\n        } catch (Exception e) {\n            // 6. 如果发生任何异常，手动回滚事务\n            transactionManager.rollback(status);\n            log.error(\"线程 {} 秒杀失败: {}\", Thread.currentThread().getName(), e.getMessage());\n            // 将异常信息返回或记录日志\n            return e.getMessage();\n        } finally {\n            // 7. 最后，释放锁\n            log.info(\"线程 {} 准备释放写锁.\", Thread.currentThread().getName());\n            writeLock.unlock();\n        }\n    }\n  ```\n- 同时，我也在 Controller 层为查询库存新增了一个 GET 方式的 API 接口。\n\n#### JMeter设置\n- **线程组一：读请求**\n  - **线程数：**  **500**。\n  - **Ramp-up:** 1\n  - **循环次数:** 10 \n  - 在该线程组下，创建一个 HTTP 请求，指向**读接口**：`GET /seckill/stock/1`\n- **线程组二：写请求**\n  - **线程数：**  **200** \n  - **Ramp-up:** 1\n  - **循环次数:** 1\n  - 在该线程组下，创建之前配置好的、带计数器的 HTTP 请求，指向**写接口**：`POST /seckill/1?userId=${uniqueUserId}`\n**同时启动压测**：在 JMeter 中，同时运行多个线程组。\n\n#### 压测结果与分析\n- 结果：读请求均为库存为0;写请求正常，数据库显示，库存数为0，订单数新建100。\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510011912013.png 读请求 %}\n- 分析： 瞬时的大量写请求，在一个极端的时间窗口内将库存扣减完毕。读请求因为写锁被阻塞，等到它们能够被执行时，秒杀已经结束。\n\n### 二、改进：并发测试场景设计\n#### 调整JMeter设置\n  由于200个/500个线程数太多，在日志中无法回看到最初的日志信息，所以修改线程数，便于观察。\n**“写请求”线程组：**\n- **线程数:** 20\n- **Ramp-up Period:** 从 `1` 改成 `20`。\n  - **作用：** 这意味着 JMeter 会在20秒内“缓慢地”启动这200个线程，大约每1秒启动一个。这给了读请求在两个写请求之间“插进来”的机会。\n- **循环次数 (Loop Count):** 1 \n\n**“读请求”线程组：**\n\n- **线程数:** 50\n- **Ramp-up Period:** 也改成 `20`。\n- **循环次数:** 保持在 `10` 。\n\n**【关键】为两个线程组设置“调度器”：**\n- 在两个线程组的配置界面下方，找到并勾选 **“调度器”**。\n- 在“**持续时间**”中，输入 `30`。\n  - **作用：** 这会强制两个线程组都在运行30秒后自动停止。这能确保读写请求在同一个时间窗口内并发执行。\n#### 压测结果与分析\n- 结果：读请求在日志中能够显示出库存数逐渐减少，写请求正常，且日志有如下模式，体现了读写锁“读共享、写独占”的理论：\n一次写 -> 一大批读（读到的值都一样） -> 又一次写 -> 又一大批读（读到的新值都一样）...\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510011920654.png 日志信息 %}\n\n### 学学八股\n#### ReentrantReadWriteLock\n- 是一个读写锁的实现，在内部维护了一对关联的锁：一个共享的读锁和一个独占的写锁。在”读多写少“的场景下，如果使用ReentrantLock这种普通互斥锁，会因为大量的饿读操作也必须串行执行而导致性能低下。读写锁则允许多个读线程并发访问，极大提升了这类场景下的系统吞吐量。\n\n  - 读锁：如果当前没有任何线程持有写锁，那么任意数量的线程都可以成功获取并持有读锁。即读-读共享。\n  - 写锁：只有在没有任何线程持有读锁或写锁的情况下，一个线程才有可能成功获取写锁。即写-写互斥，写-读互斥。\n\n- 可能的问题\n  - **“写饥饿”问题：** 在非公平、高并发读的场景下，如果读请求源源不断，写线程可能很难有机会获取到写锁，因为它总能看到有线程持有读锁。这就是所谓的“写饥饿”。**使用公平锁**是缓解这个问题的一种方式。\n  - **性能并非总是更优：** `ReentrantReadWriteLock` 的内部机制比 `ReentrantLock` 复杂得多，因此在**读写竞争不明显**或者**并发度不高**的情况下，它的开销可能会比简单的互斥锁更大。不要盲目使用，只有在明确的“读多写少”且存在性能瓶颈的场景下，它才是最佳选择。","source":"wiki/Seckill/1-秒杀项目1.1-读写分离.md","raw":"---\nwiki: Seckill # 这是项目id，对应 /data/wiki/hexo-stellar.yml\ntitle: 1-秒杀项目1.1-读写分离\ntags: [Spring Boot,高并发,JUC]\ncategories: [项目实战]\nposter:\n  topic: 标题上方的小字\n  headline: 大标题\n  caption: 标题下方的小字\n  color: 标题颜色\ndate: 2025-10-01 16:44:13\ndescription: 重新起航版\ncover:\nbanner:\nsticky:\nmermaid:\nkatex:\nmathjax:\ntopic:\nauthor:\nreferences:\ncomments:\nindexing:\nbreadcrumb:\nleftbar: \nrightbar:\nh1:\ntype: tech\n---\n\n### 一、最初的构想：引入读写锁\n- 在秒杀开始前，有成千上万的用户疯狂刷新商品详情页，他们只是想看看库存还剩下多少，即进行读操作。在当前的实现下，大量的读请求也必须排队等待获取ReentrantLock，严重影响了用户体验。这是一个典型的“读多写少”的场景，所以引入读写锁。\n#### 改写代码\n- 重构SeckillService，将业务逻辑拆分出两个核心方法：\n  - checkStock(): 专门用于查询库存，使用读锁。\n  \n  ```Java\n  /*\n    * 新增方法，用于查询商品库存，专门用于处理读请求\n    * 使用读写锁中的读锁，允许并发读取，互不堵塞\n  */\n  public Integer checkStock(Long productId) {\n    log.info(\"线程 {} 尝试获取读锁...\", Thread.currentThread().getName());\n    readLock.lock(); // 读操作上读锁\n    log.info(\"线程 {} 成功获取到读锁\", Thread.currentThread().getName());\n    try {\n        Optional<Product> productOpt = productRepository.findById(productId);\n        if (!productOpt.isPresent()) {\n            throw new RuntimeException(\"商品不存在\");\n        }\n        log.info(\"线程 {} 读取库存为: {}\", Thread.currentThread().getName(), productOpt.get().getStock());\n        return productOpt.get().getStock();\n    } finally {\n        log.info(\"线程 {} 准备释放读锁.\", Thread.currentThread().getName());\n        readLock.unlock();\n    }\n  }\n  ```\n  - processSeckill(): 负责执行秒杀下单，使用写锁\n   ```Java\n    public String processSeckill(Long productId, Long userId) {\n        log.info(\"线程 {} 尝试获取写锁...\", Thread.currentThread().getName());\n        writeLock.lock(); // 2. 秒杀操作上写锁，确保互斥\n        log.info(\"线程 {} 成功获取到写锁\", Thread.currentThread().getName());\n        // 3. 定义事务\n        DefaultTransactionDefinition def = new DefaultTransactionDefinition();\n        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n        // 4. 开启事务\n        TransactionStatus status = transactionManager.getTransaction(def);\n\n        try {\n            // ...所有业务逻辑，和之前一样\n            // 5. 【关键】在锁释放前，手动提交事务\n            transactionManager.commit(status);\n            log.info(\"线程 {} 秒杀成功，提交事务。\", Thread.currentThread().getName());\n\n            return \"秒杀成功！订单创建中...\";\n        } catch (Exception e) {\n            // 6. 如果发生任何异常，手动回滚事务\n            transactionManager.rollback(status);\n            log.error(\"线程 {} 秒杀失败: {}\", Thread.currentThread().getName(), e.getMessage());\n            // 将异常信息返回或记录日志\n            return e.getMessage();\n        } finally {\n            // 7. 最后，释放锁\n            log.info(\"线程 {} 准备释放写锁.\", Thread.currentThread().getName());\n            writeLock.unlock();\n        }\n    }\n  ```\n- 同时，我也在 Controller 层为查询库存新增了一个 GET 方式的 API 接口。\n\n#### JMeter设置\n- **线程组一：读请求**\n  - **线程数：**  **500**。\n  - **Ramp-up:** 1\n  - **循环次数:** 10 \n  - 在该线程组下，创建一个 HTTP 请求，指向**读接口**：`GET /seckill/stock/1`\n- **线程组二：写请求**\n  - **线程数：**  **200** \n  - **Ramp-up:** 1\n  - **循环次数:** 1\n  - 在该线程组下，创建之前配置好的、带计数器的 HTTP 请求，指向**写接口**：`POST /seckill/1?userId=${uniqueUserId}`\n**同时启动压测**：在 JMeter 中，同时运行多个线程组。\n\n#### 压测结果与分析\n- 结果：读请求均为库存为0;写请求正常，数据库显示，库存数为0，订单数新建100。\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510011912013.png 读请求 %}\n- 分析： 瞬时的大量写请求，在一个极端的时间窗口内将库存扣减完毕。读请求因为写锁被阻塞，等到它们能够被执行时，秒杀已经结束。\n\n### 二、改进：并发测试场景设计\n#### 调整JMeter设置\n  由于200个/500个线程数太多，在日志中无法回看到最初的日志信息，所以修改线程数，便于观察。\n**“写请求”线程组：**\n- **线程数:** 20\n- **Ramp-up Period:** 从 `1` 改成 `20`。\n  - **作用：** 这意味着 JMeter 会在20秒内“缓慢地”启动这200个线程，大约每1秒启动一个。这给了读请求在两个写请求之间“插进来”的机会。\n- **循环次数 (Loop Count):** 1 \n\n**“读请求”线程组：**\n\n- **线程数:** 50\n- **Ramp-up Period:** 也改成 `20`。\n- **循环次数:** 保持在 `10` 。\n\n**【关键】为两个线程组设置“调度器”：**\n- 在两个线程组的配置界面下方，找到并勾选 **“调度器”**。\n- 在“**持续时间**”中，输入 `30`。\n  - **作用：** 这会强制两个线程组都在运行30秒后自动停止。这能确保读写请求在同一个时间窗口内并发执行。\n#### 压测结果与分析\n- 结果：读请求在日志中能够显示出库存数逐渐减少，写请求正常，且日志有如下模式，体现了读写锁“读共享、写独占”的理论：\n一次写 -> 一大批读（读到的值都一样） -> 又一次写 -> 又一大批读（读到的新值都一样）...\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510011920654.png 日志信息 %}\n\n### 学学八股\n#### ReentrantReadWriteLock\n- 是一个读写锁的实现，在内部维护了一对关联的锁：一个共享的读锁和一个独占的写锁。在”读多写少“的场景下，如果使用ReentrantLock这种普通互斥锁，会因为大量的饿读操作也必须串行执行而导致性能低下。读写锁则允许多个读线程并发访问，极大提升了这类场景下的系统吞吐量。\n\n  - 读锁：如果当前没有任何线程持有写锁，那么任意数量的线程都可以成功获取并持有读锁。即读-读共享。\n  - 写锁：只有在没有任何线程持有读锁或写锁的情况下，一个线程才有可能成功获取写锁。即写-写互斥，写-读互斥。\n\n- 可能的问题\n  - **“写饥饿”问题：** 在非公平、高并发读的场景下，如果读请求源源不断，写线程可能很难有机会获取到写锁，因为它总能看到有线程持有读锁。这就是所谓的“写饥饿”。**使用公平锁**是缓解这个问题的一种方式。\n  - **性能并非总是更优：** `ReentrantReadWriteLock` 的内部机制比 `ReentrantLock` 复杂得多，因此在**读写竞争不明显**或者**并发度不高**的情况下，它的开销可能会比简单的互斥锁更大。不要盲目使用，只有在明确的“读多写少”且存在性能瓶颈的场景下，它才是最佳选择。","updated":"2025-10-03T12:58:44.957Z","path":"wiki/Seckill/1-秒杀项目1.1-读写分离.html","layout":"page","_id":"cmgdn5rh4000e0wuzh7vvaoi3","content":"<h3 id=\"一、最初的构想：引入读写锁\"><a href=\"#一、最初的构想：引入读写锁\" class=\"headerlink\" title=\"一、最初的构想：引入读写锁\"></a>一、最初的构想：引入读写锁</h3><ul>\n<li>在秒杀开始前，有成千上万的用户疯狂刷新商品详情页，他们只是想看看库存还剩下多少，即进行读操作。在当前的实现下，大量的读请求也必须排队等待获取ReentrantLock，严重影响了用户体验。这是一个典型的“读多写少”的场景，所以引入读写锁。</li>\n</ul>\n<h4 id=\"改写代码\"><a href=\"#改写代码\" class=\"headerlink\" title=\"改写代码\"></a>改写代码</h4><ul>\n<li><p>重构SeckillService，将业务逻辑拆分出两个核心方法：</p>\n<ul>\n<li>checkStock(): 专门用于查询库存，使用读锁。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  * 新增方法，用于查询商品库存，专门用于处理读请求</span></span><br><span class=\"line\"><span class=\"comment\">  * 使用读写锁中的读锁，允许并发读取，互不堵塞</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Integer <span class=\"title function_\">checkStock</span><span class=\"params\">(Long productId)</span> &#123;</span><br><span class=\"line\">  log.info(<span class=\"string\">&quot;线程 &#123;&#125; 尝试获取读锁...&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">  readLock.lock(); <span class=\"comment\">// 读操作上读锁</span></span><br><span class=\"line\">  log.info(<span class=\"string\">&quot;线程 &#123;&#125; 成功获取到读锁&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      Optional&lt;Product&gt; productOpt = productRepository.findById(productId);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!productOpt.isPresent()) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;商品不存在&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      log.info(<span class=\"string\">&quot;线程 &#123;&#125; 读取库存为: &#123;&#125;&quot;</span>, Thread.currentThread().getName(), productOpt.get().getStock());</span><br><span class=\"line\">      <span class=\"keyword\">return</span> productOpt.get().getStock();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      log.info(<span class=\"string\">&quot;线程 &#123;&#125; 准备释放读锁.&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">      readLock.unlock();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>processSeckill(): 负责执行秒杀下单，使用写锁 <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;线程 &#123;&#125; 尝试获取写锁...&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">    writeLock.lock(); <span class=\"comment\">// 2. 秒杀操作上写锁，确保互斥</span></span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;线程 &#123;&#125; 成功获取到写锁&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">    <span class=\"comment\">// 3. 定义事务</span></span><br><span class=\"line\">    <span class=\"type\">DefaultTransactionDefinition</span> <span class=\"variable\">def</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultTransactionDefinition</span>();</span><br><span class=\"line\">    def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class=\"line\">    <span class=\"comment\">// 4. 开启事务</span></span><br><span class=\"line\">    <span class=\"type\">TransactionStatus</span> <span class=\"variable\">status</span> <span class=\"operator\">=</span> transactionManager.getTransaction(def);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...所有业务逻辑，和之前一样</span></span><br><span class=\"line\">        <span class=\"comment\">// 5. 【关键】在锁释放前，手动提交事务</span></span><br><span class=\"line\">        transactionManager.commit(status);</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;线程 &#123;&#125; 秒杀成功，提交事务。&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！订单创建中...&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 6. 如果发生任何异常，手动回滚事务</span></span><br><span class=\"line\">        transactionManager.rollback(status);</span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;线程 &#123;&#125; 秒杀失败: &#123;&#125;&quot;</span>, Thread.currentThread().getName(), e.getMessage());</span><br><span class=\"line\">        <span class=\"comment\">// 将异常信息返回或记录日志</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> e.getMessage();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 7. 最后，释放锁</span></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;线程 &#123;&#125; 准备释放写锁.&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">        writeLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>同时，我也在 Controller 层为查询库存新增了一个 GET 方式的 API 接口。</p>\n</li>\n</ul>\n<h4 id=\"JMeter设置\"><a href=\"#JMeter设置\" class=\"headerlink\" title=\"JMeter设置\"></a>JMeter设置</h4><ul>\n<li><strong>线程组一：读请求</strong><ul>\n<li><strong>线程数：</strong>  <strong>500</strong>。</li>\n<li><strong>Ramp-up:</strong> 1</li>\n<li><strong>循环次数:</strong> 10 </li>\n<li>在该线程组下，创建一个 HTTP 请求，指向<strong>读接口</strong>：<code>GET /seckill/stock/1</code></li>\n</ul>\n</li>\n<li><strong>线程组二：写请求</strong><ul>\n<li><strong>线程数：</strong>  <strong>200</strong> </li>\n<li><strong>Ramp-up:</strong> 1</li>\n<li><strong>循环次数:</strong> 1</li>\n<li>在该线程组下，创建之前配置好的、带计数器的 HTTP 请求，指向<strong>写接口</strong>：<code>POST /seckill/1?userId=$&#123;uniqueUserId&#125;</code><br><strong>同时启动压测</strong>：在 JMeter 中，同时运行多个线程组。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"压测结果与分析\"><a href=\"#压测结果与分析\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li>结果：读请求均为库存为0;写请求正常，数据库显示，库存数为0，订单数新建100。<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510011912013.png\" alt=\"读请求\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">读请求</span></div></div></li>\n<li>分析： 瞬时的大量写请求，在一个极端的时间窗口内将库存扣减完毕。读请求因为写锁被阻塞，等到它们能够被执行时，秒杀已经结束。</li>\n</ul>\n<h3 id=\"二、改进：并发测试场景设计\"><a href=\"#二、改进：并发测试场景设计\" class=\"headerlink\" title=\"二、改进：并发测试场景设计\"></a>二、改进：并发测试场景设计</h3><h4 id=\"调整JMeter设置\"><a href=\"#调整JMeter设置\" class=\"headerlink\" title=\"调整JMeter设置\"></a>调整JMeter设置</h4><p>  由于200个&#x2F;500个线程数太多，在日志中无法回看到最初的日志信息，所以修改线程数，便于观察。<br><strong>“写请求”线程组：</strong></p>\n<ul>\n<li><strong>线程数:</strong> 20</li>\n<li><strong>Ramp-up Period:</strong> 从 <code>1</code> 改成 <code>20</code>。<ul>\n<li><strong>作用：</strong> 这意味着 JMeter 会在20秒内“缓慢地”启动这200个线程，大约每1秒启动一个。这给了读请求在两个写请求之间“插进来”的机会。</li>\n</ul>\n</li>\n<li><strong>循环次数 (Loop Count):</strong> 1</li>\n</ul>\n<p><strong>“读请求”线程组：</strong></p>\n<ul>\n<li><strong>线程数:</strong> 50</li>\n<li><strong>Ramp-up Period:</strong> 也改成 <code>20</code>。</li>\n<li><strong>循环次数:</strong> 保持在 <code>10</code> 。</li>\n</ul>\n<p><strong>【关键】为两个线程组设置“调度器”：</strong></p>\n<ul>\n<li>在两个线程组的配置界面下方，找到并勾选 <strong>“调度器”</strong>。</li>\n<li>在“<strong>持续时间</strong>”中，输入 <code>30</code>。<ul>\n<li><strong>作用：</strong> 这会强制两个线程组都在运行30秒后自动停止。这能确保读写请求在同一个时间窗口内并发执行。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"压测结果与分析-1\"><a href=\"#压测结果与分析-1\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li>结果：读请求在日志中能够显示出库存数逐渐减少，写请求正常，且日志有如下模式，体现了读写锁“读共享、写独占”的理论：<br>一次写 -&gt; 一大批读（读到的值都一样） -&gt; 又一次写 -&gt; 又一大批读（读到的新值都一样）…<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510011920654.png\" alt=\"日志信息\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">日志信息</span></div></div></li>\n</ul>\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"ReentrantReadWriteLock\"><a href=\"#ReentrantReadWriteLock\" class=\"headerlink\" title=\"ReentrantReadWriteLock\"></a>ReentrantReadWriteLock</h4><ul>\n<li><p>是一个读写锁的实现，在内部维护了一对关联的锁：一个共享的读锁和一个独占的写锁。在”读多写少“的场景下，如果使用ReentrantLock这种普通互斥锁，会因为大量的饿读操作也必须串行执行而导致性能低下。读写锁则允许多个读线程并发访问，极大提升了这类场景下的系统吞吐量。</p>\n<ul>\n<li>读锁：如果当前没有任何线程持有写锁，那么任意数量的线程都可以成功获取并持有读锁。即读-读共享。</li>\n<li>写锁：只有在没有任何线程持有读锁或写锁的情况下，一个线程才有可能成功获取写锁。即写-写互斥，写-读互斥。</li>\n</ul>\n</li>\n<li><p>可能的问题</p>\n<ul>\n<li><strong>“写饥饿”问题：</strong> 在非公平、高并发读的场景下，如果读请求源源不断，写线程可能很难有机会获取到写锁，因为它总能看到有线程持有读锁。这就是所谓的“写饥饿”。<strong>使用公平锁</strong>是缓解这个问题的一种方式。</li>\n<li><strong>性能并非总是更优：</strong> <code>ReentrantReadWriteLock</code> 的内部机制比 <code>ReentrantLock</code> 复杂得多，因此在<strong>读写竞争不明显</strong>或者<strong>并发度不高</strong>的情况下，它的开销可能会比简单的互斥锁更大。不要盲目使用，只有在明确的“读多写少”且存在性能瓶颈的场景下，它才是最佳选择。</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一、最初的构想：引入读写锁\"><a href=\"#一、最初的构想：引入读写锁\" class=\"headerlink\" title=\"一、最初的构想：引入读写锁\"></a>一、最初的构想：引入读写锁</h3><ul>\n<li>在秒杀开始前，有成千上万的用户疯狂刷新商品详情页，他们只是想看看库存还剩下多少，即进行读操作。在当前的实现下，大量的读请求也必须排队等待获取ReentrantLock，严重影响了用户体验。这是一个典型的“读多写少”的场景，所以引入读写锁。</li>\n</ul>\n<h4 id=\"改写代码\"><a href=\"#改写代码\" class=\"headerlink\" title=\"改写代码\"></a>改写代码</h4><ul>\n<li><p>重构SeckillService，将业务逻辑拆分出两个核心方法：</p>\n<ul>\n<li>checkStock(): 专门用于查询库存，使用读锁。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  * 新增方法，用于查询商品库存，专门用于处理读请求</span></span><br><span class=\"line\"><span class=\"comment\">  * 使用读写锁中的读锁，允许并发读取，互不堵塞</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Integer <span class=\"title function_\">checkStock</span><span class=\"params\">(Long productId)</span> &#123;</span><br><span class=\"line\">  log.info(<span class=\"string\">&quot;线程 &#123;&#125; 尝试获取读锁...&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">  readLock.lock(); <span class=\"comment\">// 读操作上读锁</span></span><br><span class=\"line\">  log.info(<span class=\"string\">&quot;线程 &#123;&#125; 成功获取到读锁&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      Optional&lt;Product&gt; productOpt = productRepository.findById(productId);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!productOpt.isPresent()) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;商品不存在&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      log.info(<span class=\"string\">&quot;线程 &#123;&#125; 读取库存为: &#123;&#125;&quot;</span>, Thread.currentThread().getName(), productOpt.get().getStock());</span><br><span class=\"line\">      <span class=\"keyword\">return</span> productOpt.get().getStock();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      log.info(<span class=\"string\">&quot;线程 &#123;&#125; 准备释放读锁.&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">      readLock.unlock();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>processSeckill(): 负责执行秒杀下单，使用写锁 <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;线程 &#123;&#125; 尝试获取写锁...&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">    writeLock.lock(); <span class=\"comment\">// 2. 秒杀操作上写锁，确保互斥</span></span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;线程 &#123;&#125; 成功获取到写锁&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">    <span class=\"comment\">// 3. 定义事务</span></span><br><span class=\"line\">    <span class=\"type\">DefaultTransactionDefinition</span> <span class=\"variable\">def</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultTransactionDefinition</span>();</span><br><span class=\"line\">    def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class=\"line\">    <span class=\"comment\">// 4. 开启事务</span></span><br><span class=\"line\">    <span class=\"type\">TransactionStatus</span> <span class=\"variable\">status</span> <span class=\"operator\">=</span> transactionManager.getTransaction(def);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...所有业务逻辑，和之前一样</span></span><br><span class=\"line\">        <span class=\"comment\">// 5. 【关键】在锁释放前，手动提交事务</span></span><br><span class=\"line\">        transactionManager.commit(status);</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;线程 &#123;&#125; 秒杀成功，提交事务。&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！订单创建中...&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 6. 如果发生任何异常，手动回滚事务</span></span><br><span class=\"line\">        transactionManager.rollback(status);</span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;线程 &#123;&#125; 秒杀失败: &#123;&#125;&quot;</span>, Thread.currentThread().getName(), e.getMessage());</span><br><span class=\"line\">        <span class=\"comment\">// 将异常信息返回或记录日志</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> e.getMessage();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 7. 最后，释放锁</span></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;线程 &#123;&#125; 准备释放写锁.&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">        writeLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>同时，我也在 Controller 层为查询库存新增了一个 GET 方式的 API 接口。</p>\n</li>\n</ul>\n<h4 id=\"JMeter设置\"><a href=\"#JMeter设置\" class=\"headerlink\" title=\"JMeter设置\"></a>JMeter设置</h4><ul>\n<li><strong>线程组一：读请求</strong><ul>\n<li><strong>线程数：</strong>  <strong>500</strong>。</li>\n<li><strong>Ramp-up:</strong> 1</li>\n<li><strong>循环次数:</strong> 10 </li>\n<li>在该线程组下，创建一个 HTTP 请求，指向<strong>读接口</strong>：<code>GET /seckill/stock/1</code></li>\n</ul>\n</li>\n<li><strong>线程组二：写请求</strong><ul>\n<li><strong>线程数：</strong>  <strong>200</strong> </li>\n<li><strong>Ramp-up:</strong> 1</li>\n<li><strong>循环次数:</strong> 1</li>\n<li>在该线程组下，创建之前配置好的、带计数器的 HTTP 请求，指向<strong>写接口</strong>：<code>POST /seckill/1?userId=$&#123;uniqueUserId&#125;</code><br><strong>同时启动压测</strong>：在 JMeter 中，同时运行多个线程组。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"压测结果与分析\"><a href=\"#压测结果与分析\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li>结果：读请求均为库存为0;写请求正常，数据库显示，库存数为0，订单数新建100。<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510011912013.png\" alt=\"读请求\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">读请求</span></div></div></li>\n<li>分析： 瞬时的大量写请求，在一个极端的时间窗口内将库存扣减完毕。读请求因为写锁被阻塞，等到它们能够被执行时，秒杀已经结束。</li>\n</ul>\n<h3 id=\"二、改进：并发测试场景设计\"><a href=\"#二、改进：并发测试场景设计\" class=\"headerlink\" title=\"二、改进：并发测试场景设计\"></a>二、改进：并发测试场景设计</h3><h4 id=\"调整JMeter设置\"><a href=\"#调整JMeter设置\" class=\"headerlink\" title=\"调整JMeter设置\"></a>调整JMeter设置</h4><p>  由于200个&#x2F;500个线程数太多，在日志中无法回看到最初的日志信息，所以修改线程数，便于观察。<br><strong>“写请求”线程组：</strong></p>\n<ul>\n<li><strong>线程数:</strong> 20</li>\n<li><strong>Ramp-up Period:</strong> 从 <code>1</code> 改成 <code>20</code>。<ul>\n<li><strong>作用：</strong> 这意味着 JMeter 会在20秒内“缓慢地”启动这200个线程，大约每1秒启动一个。这给了读请求在两个写请求之间“插进来”的机会。</li>\n</ul>\n</li>\n<li><strong>循环次数 (Loop Count):</strong> 1</li>\n</ul>\n<p><strong>“读请求”线程组：</strong></p>\n<ul>\n<li><strong>线程数:</strong> 50</li>\n<li><strong>Ramp-up Period:</strong> 也改成 <code>20</code>。</li>\n<li><strong>循环次数:</strong> 保持在 <code>10</code> 。</li>\n</ul>\n<p><strong>【关键】为两个线程组设置“调度器”：</strong></p>\n<ul>\n<li>在两个线程组的配置界面下方，找到并勾选 <strong>“调度器”</strong>。</li>\n<li>在“<strong>持续时间</strong>”中，输入 <code>30</code>。<ul>\n<li><strong>作用：</strong> 这会强制两个线程组都在运行30秒后自动停止。这能确保读写请求在同一个时间窗口内并发执行。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"压测结果与分析-1\"><a href=\"#压测结果与分析-1\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li>结果：读请求在日志中能够显示出库存数逐渐减少，写请求正常，且日志有如下模式，体现了读写锁“读共享、写独占”的理论：<br>一次写 -&gt; 一大批读（读到的值都一样） -&gt; 又一次写 -&gt; 又一大批读（读到的新值都一样）…<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510011920654.png\" alt=\"日志信息\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">日志信息</span></div></div></li>\n</ul>\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"ReentrantReadWriteLock\"><a href=\"#ReentrantReadWriteLock\" class=\"headerlink\" title=\"ReentrantReadWriteLock\"></a>ReentrantReadWriteLock</h4><ul>\n<li><p>是一个读写锁的实现，在内部维护了一对关联的锁：一个共享的读锁和一个独占的写锁。在”读多写少“的场景下，如果使用ReentrantLock这种普通互斥锁，会因为大量的饿读操作也必须串行执行而导致性能低下。读写锁则允许多个读线程并发访问，极大提升了这类场景下的系统吞吐量。</p>\n<ul>\n<li>读锁：如果当前没有任何线程持有写锁，那么任意数量的线程都可以成功获取并持有读锁。即读-读共享。</li>\n<li>写锁：只有在没有任何线程持有读锁或写锁的情况下，一个线程才有可能成功获取写锁。即写-写互斥，写-读互斥。</li>\n</ul>\n</li>\n<li><p>可能的问题</p>\n<ul>\n<li><strong>“写饥饿”问题：</strong> 在非公平、高并发读的场景下，如果读请求源源不断，写线程可能很难有机会获取到写锁，因为它总能看到有线程持有读锁。这就是所谓的“写饥饿”。<strong>使用公平锁</strong>是缓解这个问题的一种方式。</li>\n<li><strong>性能并非总是更优：</strong> <code>ReentrantReadWriteLock</code> 的内部机制比 <code>ReentrantLock</code> 复杂得多，因此在<strong>读写竞争不明显</strong>或者<strong>并发度不高</strong>的情况下，它的开销可能会比简单的互斥锁更大。不要盲目使用，只有在明确的“读多写少”且存在性能瓶颈的场景下，它才是最佳选择。</li>\n</ul>\n</li>\n</ul>\n"},{"wiki":"Seckill","title":"1-秒杀项目1.3-异步处理和优化","tags":["Spring Boot","高并发","JUC"],"categories":["项目实战"],"poster":{"topic":"标题上方的小字","headline":"大标题","caption":"标题下方的小字","color":"标题颜色"},"date":"2025-10-03T12:58:06.000Z","description":"重新起航版","cover":null,"banner":null,"sticky":null,"mermaid":null,"katex":null,"mathjax":null,"topic":null,"author":null,"references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n### 用户体验：引入异步处理\n- 在V1.1和V1.2，通过读写锁和信号量，构建了一个数据相对正确，流量可控的秒杀系统。尽管后端相对稳定，但用户体验糟糕，同步阻塞的模式，意味着用户必须在浏览器前“转圈圈”，等待后端的耗时操作。\n- 在V1.3中，实现异步化，将用户请求与后端耗时任务解耦，实现用户的及时响应。\n#### 代码改写\n- 线程池，创建`ThreadPoolConfig.java`\n```Java\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport java.util.concurrent.*;\n\n@Configuration\npublic class ThreadPoolConfig {\n\n    @Bean\n    public ExecutorService seckillExecutorService() {\n    \n        // 手动实现一个简单的 ThreadFactory\n        ThreadFactory namedThreadFactory = r -> new Thread(\"seckill-thread-\" + r.hashCode());\n\n        // 创建线程池\n        ExecutorService pool = new ThreadPoolExecutor(\n                10,     // corePoolSize: 核心线程数，即长期保持的线程数\n                20,     // maximumPoolSize: 最大线程数\n                60L,    // keepAliveTime: 空闲线程的存活时间\n                TimeUnit.SECONDS, // 时间单位\n                new LinkedBlockingQueue<>(100), // workQueue: 任务队列，容量为100\n                namedThreadFactory, // threadFactory: 线程工厂，用于给线程命名\n                new ThreadPoolExecutor.AbortPolicy() // rejectedExecutionHandler: 拒绝策略\n        );\n        return pool;\n    }\n}\n```\n- 重构SeckillService，分离提交与执行\n```Java\n@Service\npublic class SeckillService {\n\n    @Autowired\n    private ExecutorService seckillExecutorService; // 1. 注入我们创建的线程池\n\n    // ... 其他属性保持不变 ...\n\n    /**\n     * 新的入口方法：负责接收请求并提交到线程池\n     * 这个方法会【立刻】返回，不会等待后台线程执行完毕\n     */\n    public String submitSeckillOrder(Long productId, Long userId) {\n        \n        // 2. 创建一个任务（Runnable）\n        Runnable task = () -> {\n            // 在这个任务中，调用我们之前那个耗时的、带锁的真实秒杀逻辑\n            executeSeckill(productId, userId);\n        };\n\n        // 3. 将任务提交给线程池\n        seckillExecutorService.submit(task);\n        \n        return \"请求已接收，正在排队处理中，请稍后查看订单状态。\";\n    }\n\n    /**\n     * 真实的秒杀执行逻辑，现在是一个私有方法\n     * 它会被后台线程池中的线程调用\n     * @param productId\n     * @param userId\n     */\n    private void executeSeckill(Long productId, Long userId) {\n        boolean acquired = false;\n        try {\n            acquired = semaphore.tryAcquire(3, TimeUnit.SECONDS);\n            if (!acquired) {\n                log.warn(\"线程 {} 获取信号量许可超时\", Thread.currentThread().getName());\n                return; // 获取不到许可，直接结束任务\n            }\n            // ... 省略了之前完整的、带 writeLock 和手动事务的业务逻辑 ...\n            // 注意：因为这个方法现在没有返回值了，你需要通过日志来记录成功或失败\n            // 比如在 commit 后 log.info(\"订单创建成功...\")\n            // 在 rollback 后 log.error(\"订单创建失败...\")\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            log.error(\"线程 {} 被中断\", Thread.currentThread().getName());\n        } finally {\n            if (acquired) {\n                semaphore.release();\n            }\n        }\n    }\n}\n```\n- 更新 SeckillController，调用新的“提交”方法。\n#### 压测结果与分析\n- JMeter设置与之前的版本相同，只执行写请求。\n- 结果：有120个线程成功请求到了线程池，80个失败请求。没有任何的库存减少和新订单的建立，并且在日志中没有任何关于申请信号量许可的信息。\n- 分析：\n  - 120个成功请求和80个失败请求：系统能够容纳的瞬时任务上限是20（正在执行）+100（排队等待）=120个，而剩下的80个失败请求对应的是因为线程池已满而被拒绝。\n  - 没有库存减少和新订单的建立：120个被线程池接收的任务，没有一个成功完成数据库操作。\n  - 日志中没有见到任何申请信号量许可的信息：甚至有可能没有进入`executeSeckill()`方法。类似于“当第200个请求被拒绝后，所有200个请求都结束了”\n- 原因：“守护线程”的提前退场\n  - 用户线程：通常创建的、执行核心任务的“前台线程”。JVM规则：只要还有一个用户线程没有执行完毕，JVM进程就必须等待，不能退出。\n  - 守护线程：特殊的“后台线程”，为其他线程服务。JVM规则：当程序中只剩下守护线程在运行时，JVM会认为所有核心工作已经全部完成，于是会退出并且终止所有仍在运行的守护线程。\n- 由于某种原因，在seckillExecutorService中创建的工作线程，被设置为了守护线程。\n#### 改进\n- 在创建线程时，明确设置为“用户线程”。\n```Java\n@Configuration\npublic class ThreadPoolConfig {\n\n    @Bean\n    public ExecutorService seckillExecutorService() {\n        ThreadFactory namedThreadFactory = r -> {\n            Thread t = new Thread(r);\n            // 【关键改动】将线程设置为非守护线程\n            t.setDaemon(false); \n            t.setName(\"seckill-thread-\" + t.hashCode());\n            return t;\n        };\n\n        // 创建线程池的其余代码保持不变\n        ExecutorService pool = new ThreadPoolExecutor(\n                10,\n                20,\n                60L,\n                TimeUnit.SECONDS,\n                new LinkedBlockingQueue<>(100),\n                namedThreadFactory,\n                new ThreadPoolExecutor.AbortPolicy()\n        );\n        return pool;\n    }\n}\n```\n- 在手动创建 Thread 对象后，调用了 t.setDaemon(false);。false 表示它是一个用户线程（非守护线程），这是 Java 线程的默认行为，但在这里我们明确地指定它，以覆盖任何可能的默认设置，确保万无一失。\n\n- 结果：库存减少至0，新增订单数100，数据正常。日志显示正常。\n\n### 单体应用的性能优化\n#### 数据库原子化更新、引入内存售罄标记\n- 使用“原子化SQL更新”替代Java锁，将检查库存和扣减库存合并为同一条SQL语句，并且引入内存售罄标记。数据库原子化更新利用了数据库的行锁来保证原子性，性能远高于在Java应用层加锁。引入内存售罄标记，直接拒绝已知的无效流量，保护了后端服务。\n- 修改 ProductRepository.java\n```Java\n@Repository\npublic interface ProductRepository extends JpaRepository<Product, Long> {\n\n    /**\n     * 【新增】原子化扣减库存的方法\n     * 使用 @Modifying 注解来告诉 Spring Data JPA 这是一个“修改”操作\n     * 使用 @Query 注解来定义我们的 JPQL 语句\n     * WHERE 子句中的 \"p.stock > 0\" 是关键，它在数据库层面保证了不会超卖\n     * @param productId 商品ID\n     * @return 返回受影响的行数，如果 > 0 表示更新成功，= 0 表示库存不足或商品不存在\n     */\n    @Modifying\n    @Query(\"UPDATE Product p SET p.stock = p.stock - 1 WHERE p.id = :productId AND p.stock > 0\")\n    int deductStock(@Param(\"productId\") Long productId);\n}\n```\n\n- 重构 SeckillService.java 的核心逻辑\n```Java\n@Service\npublic class SeckillService {\n    // ... 其他属性 ...\n\n    // 【移除】不再需要写锁了！\n    // private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock(true);\n    // private final Lock writeLock = rwLock.writeLock();\n\n    // ...\n\n    // 【新增】内存售罄标记\n    private volatile boolean isSoldOut = false;\n\n    public String submitSeckillOrder(Long productId, Long userId) {\n        // 【优化】在所有逻辑之前，先检查内存标记\n        if (isSoldOut) {\n            return \"商品已售罄（内存标记拦截）\";\n        }\n\n        // ... 之前的提交到线程池的逻辑保持不变 ...\n        // ...\n    }\n\n    private void executeSeckill(Long productId, Long userId) {\n        // ... Semaphore 的获取和释放逻辑保持不变 ...\n        boolean acquired = false;\n        try {\n            acquired = semaphore.tryAcquire(3, TimeUnit.SECONDS);\n            if (!acquired) {\n                // ...\n                return;\n            }\n\n            // 【移除】不再需要 Thread.sleep()\n            // Thread.sleep(1000);\n\n            // 【重构】调用新的、无锁的数据库操作方法\n            executeDbOperationsWithoutLock(productId, userId);\n\n        } catch (InterruptedException e) {\n            // ...\n        } finally {\n            if (acquired) {\n                semaphore.release();\n            }\n        }\n    }\n\n    // 【重构】创建一个新的、无锁的数据库操作方法\n    private void executeDbOperationsWithoutLock(Long productId, Long userId) {\n        // 【移除】不再需要 writeLock.lock()\n        DefaultTransactionDefinition def = new DefaultTransactionDefinition();\n        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n        TransactionStatus status = transactionManager.getTransaction(def);\n        try {\n            // 前置检查（重复下单等）依然可以保留\n            if (orderRepository.findByUserIdAndProductId(userId, productId) != null) {\n                throw new RuntimeException(\"您已秒杀过此商品，请勿重复下单\");\n            }\n            \n            // 1. 【核心改动】直接调用原子更新方法扣减库存\n            int result = productRepository.deductStock(productId);\n\n            // 2. 检查结果\n            if (result == 0) {\n                // 如果更新行数为0，说明库存不足\n                isSoldOut = true; // 【优化】设置内存售罄标记\n                throw new RuntimeException(\"商品已售罄\");\n            }\n\n            // 3. 如果扣减成功，才创建订单...\n\n            transactionManager.commit(status);\n            log.info(\"线程 {} 秒杀成功，提交事务。\", Thread.currentThread().getName());\n\n        } catch (Exception e) {\n            transactionManager.rollback(status);\n            log.error(\"线程 {} 秒杀失败，回滚事务: {}\", Thread.currentThread().getName(), e.getMessage());\n        }\n        // 【移除】不再需要 finally { writeLock.unlock() }\n    }\n}\n```\n#### 集成Spring Boot Actuator\n- 修改 pom.xml 文件\n- 在 <dependencies> 标签内，添加 Actuator 的 starter 依赖：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n- 修改 src/main/resources/application.properties 文件\n添加以下配置，来暴露所有的监控端点 (endpoints) 以供访问：\n\n```Properties\n# Spring Boot Actuator 配置\n# 暴露所有 Web 端点（在生产环境中应按需暴露，* 是为了开发方便）\nmanagement.endpoints.web.exposure.include=*\n# (可选) 让 health 端点总是显示详细信息\nmanagement.endpoint.health.show-details=always\n```\n\n### 学学八股\n#### ThreadPoolExecutor 线程池\n- 核心作用\n  - 降低资源消耗：通过复用已创建的线程，避免了频繁创建和销毁线程的巨大开销。\n  - 提高响应速度：任务到达时，可以直接使用池中的线程执行，省去了创建线程的时间。\n  - 提高客观理性：可以对线程进行统一的分配、监控和调优，防止无限制的创建线程耗尽系统资源。\n- 核心参数\n  - corePoolSize ：核心线程数，线程池长期维持的线程数量，即使它们处于空闲状态。\n  - maximumPoolSize ：最大线程数，线程池能够容纳的最大线程数量。当任务队列满了，且当前线程数小于最大线程数时，才会创建新线程。\n  - KeepAliveTime：空闲线程存活时间，当线程池中的数量大于corePoolSize时，多余的空闲线程在等待新任务时能够存活的最长时间。\n  - unit：时间单位\n  - workQueue：任务队列，用于存放等待执行的任务的阻塞队列。\n  - threadFactory： 线程工厂，用于创建新线程的工厂。\n  - rejectedExecutionHandler：拒绝策略，当任务队列和线程池都满了，新任务到来时所采取的策略。\n#### 原子化SQL更新\n- 核心思想：放弃在 Java 应用层使用锁（如 ReentrantLock）来保证“读-改-写”的原子性，而是将这个职责下推到数据库层面。\n- 底层原理：数据库的 InnoDB 引擎 会对符合 WHERE 条件的行加上行锁 (Row Lock)，从而天然地保证了该操作的原子性。\n#### Spring Boot Actuator\n- 核心作用：通过一系列的HTTP端点，暴露应用的内部运行情况。\n- Actuator 是构建可观测性系统的第一步。通过它暴露的 metrics 端点，可以与 Prometheus (数据采集) 和 Grafana (数据可视化) 等工具链集成，搭建出专业的监控仪表盘，实时监控 JVM 状态、数据库连接池、线程池活跃度等关键指标。","source":"wiki/Seckill/1-秒杀项目1.3-异步处理和优化.md","raw":"---\nwiki: Seckill # 这是项目id，对应 /data/wiki/hexo-stellar.yml\ntitle: 1-秒杀项目1.3-异步处理和优化\ntags: [Spring Boot,高并发,JUC]\ncategories: [项目实战]\nposter:\n  topic: 标题上方的小字\n  headline: 大标题\n  caption: 标题下方的小字\n  color: 标题颜色\ndate: 2025-10-03 20:58:06\ndescription: 重新起航版\ncover:\nbanner:\nsticky:\nmermaid:\nkatex:\nmathjax:\ntopic:\nauthor:\nreferences:\ncomments:\nindexing:\nbreadcrumb:\nleftbar:\nrightbar:\nh1:\ntype: tech\n---\n\n### 用户体验：引入异步处理\n- 在V1.1和V1.2，通过读写锁和信号量，构建了一个数据相对正确，流量可控的秒杀系统。尽管后端相对稳定，但用户体验糟糕，同步阻塞的模式，意味着用户必须在浏览器前“转圈圈”，等待后端的耗时操作。\n- 在V1.3中，实现异步化，将用户请求与后端耗时任务解耦，实现用户的及时响应。\n#### 代码改写\n- 线程池，创建`ThreadPoolConfig.java`\n```Java\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport java.util.concurrent.*;\n\n@Configuration\npublic class ThreadPoolConfig {\n\n    @Bean\n    public ExecutorService seckillExecutorService() {\n    \n        // 手动实现一个简单的 ThreadFactory\n        ThreadFactory namedThreadFactory = r -> new Thread(\"seckill-thread-\" + r.hashCode());\n\n        // 创建线程池\n        ExecutorService pool = new ThreadPoolExecutor(\n                10,     // corePoolSize: 核心线程数，即长期保持的线程数\n                20,     // maximumPoolSize: 最大线程数\n                60L,    // keepAliveTime: 空闲线程的存活时间\n                TimeUnit.SECONDS, // 时间单位\n                new LinkedBlockingQueue<>(100), // workQueue: 任务队列，容量为100\n                namedThreadFactory, // threadFactory: 线程工厂，用于给线程命名\n                new ThreadPoolExecutor.AbortPolicy() // rejectedExecutionHandler: 拒绝策略\n        );\n        return pool;\n    }\n}\n```\n- 重构SeckillService，分离提交与执行\n```Java\n@Service\npublic class SeckillService {\n\n    @Autowired\n    private ExecutorService seckillExecutorService; // 1. 注入我们创建的线程池\n\n    // ... 其他属性保持不变 ...\n\n    /**\n     * 新的入口方法：负责接收请求并提交到线程池\n     * 这个方法会【立刻】返回，不会等待后台线程执行完毕\n     */\n    public String submitSeckillOrder(Long productId, Long userId) {\n        \n        // 2. 创建一个任务（Runnable）\n        Runnable task = () -> {\n            // 在这个任务中，调用我们之前那个耗时的、带锁的真实秒杀逻辑\n            executeSeckill(productId, userId);\n        };\n\n        // 3. 将任务提交给线程池\n        seckillExecutorService.submit(task);\n        \n        return \"请求已接收，正在排队处理中，请稍后查看订单状态。\";\n    }\n\n    /**\n     * 真实的秒杀执行逻辑，现在是一个私有方法\n     * 它会被后台线程池中的线程调用\n     * @param productId\n     * @param userId\n     */\n    private void executeSeckill(Long productId, Long userId) {\n        boolean acquired = false;\n        try {\n            acquired = semaphore.tryAcquire(3, TimeUnit.SECONDS);\n            if (!acquired) {\n                log.warn(\"线程 {} 获取信号量许可超时\", Thread.currentThread().getName());\n                return; // 获取不到许可，直接结束任务\n            }\n            // ... 省略了之前完整的、带 writeLock 和手动事务的业务逻辑 ...\n            // 注意：因为这个方法现在没有返回值了，你需要通过日志来记录成功或失败\n            // 比如在 commit 后 log.info(\"订单创建成功...\")\n            // 在 rollback 后 log.error(\"订单创建失败...\")\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            log.error(\"线程 {} 被中断\", Thread.currentThread().getName());\n        } finally {\n            if (acquired) {\n                semaphore.release();\n            }\n        }\n    }\n}\n```\n- 更新 SeckillController，调用新的“提交”方法。\n#### 压测结果与分析\n- JMeter设置与之前的版本相同，只执行写请求。\n- 结果：有120个线程成功请求到了线程池，80个失败请求。没有任何的库存减少和新订单的建立，并且在日志中没有任何关于申请信号量许可的信息。\n- 分析：\n  - 120个成功请求和80个失败请求：系统能够容纳的瞬时任务上限是20（正在执行）+100（排队等待）=120个，而剩下的80个失败请求对应的是因为线程池已满而被拒绝。\n  - 没有库存减少和新订单的建立：120个被线程池接收的任务，没有一个成功完成数据库操作。\n  - 日志中没有见到任何申请信号量许可的信息：甚至有可能没有进入`executeSeckill()`方法。类似于“当第200个请求被拒绝后，所有200个请求都结束了”\n- 原因：“守护线程”的提前退场\n  - 用户线程：通常创建的、执行核心任务的“前台线程”。JVM规则：只要还有一个用户线程没有执行完毕，JVM进程就必须等待，不能退出。\n  - 守护线程：特殊的“后台线程”，为其他线程服务。JVM规则：当程序中只剩下守护线程在运行时，JVM会认为所有核心工作已经全部完成，于是会退出并且终止所有仍在运行的守护线程。\n- 由于某种原因，在seckillExecutorService中创建的工作线程，被设置为了守护线程。\n#### 改进\n- 在创建线程时，明确设置为“用户线程”。\n```Java\n@Configuration\npublic class ThreadPoolConfig {\n\n    @Bean\n    public ExecutorService seckillExecutorService() {\n        ThreadFactory namedThreadFactory = r -> {\n            Thread t = new Thread(r);\n            // 【关键改动】将线程设置为非守护线程\n            t.setDaemon(false); \n            t.setName(\"seckill-thread-\" + t.hashCode());\n            return t;\n        };\n\n        // 创建线程池的其余代码保持不变\n        ExecutorService pool = new ThreadPoolExecutor(\n                10,\n                20,\n                60L,\n                TimeUnit.SECONDS,\n                new LinkedBlockingQueue<>(100),\n                namedThreadFactory,\n                new ThreadPoolExecutor.AbortPolicy()\n        );\n        return pool;\n    }\n}\n```\n- 在手动创建 Thread 对象后，调用了 t.setDaemon(false);。false 表示它是一个用户线程（非守护线程），这是 Java 线程的默认行为，但在这里我们明确地指定它，以覆盖任何可能的默认设置，确保万无一失。\n\n- 结果：库存减少至0，新增订单数100，数据正常。日志显示正常。\n\n### 单体应用的性能优化\n#### 数据库原子化更新、引入内存售罄标记\n- 使用“原子化SQL更新”替代Java锁，将检查库存和扣减库存合并为同一条SQL语句，并且引入内存售罄标记。数据库原子化更新利用了数据库的行锁来保证原子性，性能远高于在Java应用层加锁。引入内存售罄标记，直接拒绝已知的无效流量，保护了后端服务。\n- 修改 ProductRepository.java\n```Java\n@Repository\npublic interface ProductRepository extends JpaRepository<Product, Long> {\n\n    /**\n     * 【新增】原子化扣减库存的方法\n     * 使用 @Modifying 注解来告诉 Spring Data JPA 这是一个“修改”操作\n     * 使用 @Query 注解来定义我们的 JPQL 语句\n     * WHERE 子句中的 \"p.stock > 0\" 是关键，它在数据库层面保证了不会超卖\n     * @param productId 商品ID\n     * @return 返回受影响的行数，如果 > 0 表示更新成功，= 0 表示库存不足或商品不存在\n     */\n    @Modifying\n    @Query(\"UPDATE Product p SET p.stock = p.stock - 1 WHERE p.id = :productId AND p.stock > 0\")\n    int deductStock(@Param(\"productId\") Long productId);\n}\n```\n\n- 重构 SeckillService.java 的核心逻辑\n```Java\n@Service\npublic class SeckillService {\n    // ... 其他属性 ...\n\n    // 【移除】不再需要写锁了！\n    // private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock(true);\n    // private final Lock writeLock = rwLock.writeLock();\n\n    // ...\n\n    // 【新增】内存售罄标记\n    private volatile boolean isSoldOut = false;\n\n    public String submitSeckillOrder(Long productId, Long userId) {\n        // 【优化】在所有逻辑之前，先检查内存标记\n        if (isSoldOut) {\n            return \"商品已售罄（内存标记拦截）\";\n        }\n\n        // ... 之前的提交到线程池的逻辑保持不变 ...\n        // ...\n    }\n\n    private void executeSeckill(Long productId, Long userId) {\n        // ... Semaphore 的获取和释放逻辑保持不变 ...\n        boolean acquired = false;\n        try {\n            acquired = semaphore.tryAcquire(3, TimeUnit.SECONDS);\n            if (!acquired) {\n                // ...\n                return;\n            }\n\n            // 【移除】不再需要 Thread.sleep()\n            // Thread.sleep(1000);\n\n            // 【重构】调用新的、无锁的数据库操作方法\n            executeDbOperationsWithoutLock(productId, userId);\n\n        } catch (InterruptedException e) {\n            // ...\n        } finally {\n            if (acquired) {\n                semaphore.release();\n            }\n        }\n    }\n\n    // 【重构】创建一个新的、无锁的数据库操作方法\n    private void executeDbOperationsWithoutLock(Long productId, Long userId) {\n        // 【移除】不再需要 writeLock.lock()\n        DefaultTransactionDefinition def = new DefaultTransactionDefinition();\n        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n        TransactionStatus status = transactionManager.getTransaction(def);\n        try {\n            // 前置检查（重复下单等）依然可以保留\n            if (orderRepository.findByUserIdAndProductId(userId, productId) != null) {\n                throw new RuntimeException(\"您已秒杀过此商品，请勿重复下单\");\n            }\n            \n            // 1. 【核心改动】直接调用原子更新方法扣减库存\n            int result = productRepository.deductStock(productId);\n\n            // 2. 检查结果\n            if (result == 0) {\n                // 如果更新行数为0，说明库存不足\n                isSoldOut = true; // 【优化】设置内存售罄标记\n                throw new RuntimeException(\"商品已售罄\");\n            }\n\n            // 3. 如果扣减成功，才创建订单...\n\n            transactionManager.commit(status);\n            log.info(\"线程 {} 秒杀成功，提交事务。\", Thread.currentThread().getName());\n\n        } catch (Exception e) {\n            transactionManager.rollback(status);\n            log.error(\"线程 {} 秒杀失败，回滚事务: {}\", Thread.currentThread().getName(), e.getMessage());\n        }\n        // 【移除】不再需要 finally { writeLock.unlock() }\n    }\n}\n```\n#### 集成Spring Boot Actuator\n- 修改 pom.xml 文件\n- 在 <dependencies> 标签内，添加 Actuator 的 starter 依赖：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n- 修改 src/main/resources/application.properties 文件\n添加以下配置，来暴露所有的监控端点 (endpoints) 以供访问：\n\n```Properties\n# Spring Boot Actuator 配置\n# 暴露所有 Web 端点（在生产环境中应按需暴露，* 是为了开发方便）\nmanagement.endpoints.web.exposure.include=*\n# (可选) 让 health 端点总是显示详细信息\nmanagement.endpoint.health.show-details=always\n```\n\n### 学学八股\n#### ThreadPoolExecutor 线程池\n- 核心作用\n  - 降低资源消耗：通过复用已创建的线程，避免了频繁创建和销毁线程的巨大开销。\n  - 提高响应速度：任务到达时，可以直接使用池中的线程执行，省去了创建线程的时间。\n  - 提高客观理性：可以对线程进行统一的分配、监控和调优，防止无限制的创建线程耗尽系统资源。\n- 核心参数\n  - corePoolSize ：核心线程数，线程池长期维持的线程数量，即使它们处于空闲状态。\n  - maximumPoolSize ：最大线程数，线程池能够容纳的最大线程数量。当任务队列满了，且当前线程数小于最大线程数时，才会创建新线程。\n  - KeepAliveTime：空闲线程存活时间，当线程池中的数量大于corePoolSize时，多余的空闲线程在等待新任务时能够存活的最长时间。\n  - unit：时间单位\n  - workQueue：任务队列，用于存放等待执行的任务的阻塞队列。\n  - threadFactory： 线程工厂，用于创建新线程的工厂。\n  - rejectedExecutionHandler：拒绝策略，当任务队列和线程池都满了，新任务到来时所采取的策略。\n#### 原子化SQL更新\n- 核心思想：放弃在 Java 应用层使用锁（如 ReentrantLock）来保证“读-改-写”的原子性，而是将这个职责下推到数据库层面。\n- 底层原理：数据库的 InnoDB 引擎 会对符合 WHERE 条件的行加上行锁 (Row Lock)，从而天然地保证了该操作的原子性。\n#### Spring Boot Actuator\n- 核心作用：通过一系列的HTTP端点，暴露应用的内部运行情况。\n- Actuator 是构建可观测性系统的第一步。通过它暴露的 metrics 端点，可以与 Prometheus (数据采集) 和 Grafana (数据可视化) 等工具链集成，搭建出专业的监控仪表盘，实时监控 JVM 状态、数据库连接池、线程池活跃度等关键指标。","updated":"2025-10-03T14:09:20.838Z","path":"wiki/Seckill/1-秒杀项目1.3-异步处理和优化.html","layout":"page","_id":"cmgdn5rh5000g0wuz1tib9vc0","content":"<h3 id=\"用户体验：引入异步处理\"><a href=\"#用户体验：引入异步处理\" class=\"headerlink\" title=\"用户体验：引入异步处理\"></a>用户体验：引入异步处理</h3><ul>\n<li>在V1.1和V1.2，通过读写锁和信号量，构建了一个数据相对正确，流量可控的秒杀系统。尽管后端相对稳定，但用户体验糟糕，同步阻塞的模式，意味着用户必须在浏览器前“转圈圈”，等待后端的耗时操作。</li>\n<li>在V1.3中，实现异步化，将用户请求与后端耗时任务解耦，实现用户的及时响应。</li>\n</ul>\n<h4 id=\"代码改写\"><a href=\"#代码改写\" class=\"headerlink\" title=\"代码改写\"></a>代码改写</h4><ul>\n<li>线程池，创建<code>ThreadPoolConfig.java</code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPoolConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ExecutorService <span class=\"title function_\">seckillExecutorService</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 手动实现一个简单的 ThreadFactory</span></span><br><span class=\"line\">        <span class=\"type\">ThreadFactory</span> <span class=\"variable\">namedThreadFactory</span> <span class=\"operator\">=</span> r -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"string\">&quot;seckill-thread-&quot;</span> + r.hashCode());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建线程池</span></span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">pool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(</span><br><span class=\"line\">                <span class=\"number\">10</span>,     <span class=\"comment\">// corePoolSize: 核心线程数，即长期保持的线程数</span></span><br><span class=\"line\">                <span class=\"number\">20</span>,     <span class=\"comment\">// maximumPoolSize: 最大线程数</span></span><br><span class=\"line\">                <span class=\"number\">60L</span>,    <span class=\"comment\">// keepAliveTime: 空闲线程的存活时间</span></span><br><span class=\"line\">                TimeUnit.SECONDS, <span class=\"comment\">// 时间单位</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;(<span class=\"number\">100</span>), <span class=\"comment\">// workQueue: 任务队列，容量为100</span></span><br><span class=\"line\">                namedThreadFactory, <span class=\"comment\">// threadFactory: 线程工厂，用于给线程命名</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>.AbortPolicy() <span class=\"comment\">// rejectedExecutionHandler: 拒绝策略</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>重构SeckillService，分离提交与执行<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SeckillService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ExecutorService seckillExecutorService; <span class=\"comment\">// 1. 注入我们创建的线程池</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ... 其他属性保持不变 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 新的入口方法：负责接收请求并提交到线程池</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个方法会【立刻】返回，不会等待后台线程执行完毕</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">submitSeckillOrder</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 2. 创建一个任务（Runnable）</span></span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在这个任务中，调用我们之前那个耗时的、带锁的真实秒杀逻辑</span></span><br><span class=\"line\">            executeSeckill(productId, userId);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. 将任务提交给线程池</span></span><br><span class=\"line\">        seckillExecutorService.submit(task);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;请求已接收，正在排队处理中，请稍后查看订单状态。&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 真实的秒杀执行逻辑，现在是一个私有方法</span></span><br><span class=\"line\"><span class=\"comment\">     * 它会被后台线程池中的线程调用</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> productId</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> userId</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">acquired</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            acquired = semaphore.tryAcquire(<span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!acquired) &#123;</span><br><span class=\"line\">                log.warn(<span class=\"string\">&quot;线程 &#123;&#125; 获取信号量许可超时&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">                <span class=\"keyword\">return</span>; <span class=\"comment\">// 获取不到许可，直接结束任务</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// ... 省略了之前完整的、带 writeLock 和手动事务的业务逻辑 ...</span></span><br><span class=\"line\">            <span class=\"comment\">// 注意：因为这个方法现在没有返回值了，你需要通过日志来记录成功或失败</span></span><br><span class=\"line\">            <span class=\"comment\">// 比如在 commit 后 log.info(&quot;订单创建成功...&quot;)</span></span><br><span class=\"line\">            <span class=\"comment\">// 在 rollback 后 log.error(&quot;订单创建失败...&quot;)</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            Thread.currentThread().interrupt();</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;线程 &#123;&#125; 被中断&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (acquired) &#123;</span><br><span class=\"line\">                semaphore.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>更新 SeckillController，调用新的“提交”方法。</li>\n</ul>\n<h4 id=\"压测结果与分析\"><a href=\"#压测结果与分析\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li>JMeter设置与之前的版本相同，只执行写请求。</li>\n<li>结果：有120个线程成功请求到了线程池，80个失败请求。没有任何的库存减少和新订单的建立，并且在日志中没有任何关于申请信号量许可的信息。</li>\n<li>分析：<ul>\n<li>120个成功请求和80个失败请求：系统能够容纳的瞬时任务上限是20（正在执行）+100（排队等待）&#x3D;120个，而剩下的80个失败请求对应的是因为线程池已满而被拒绝。</li>\n<li>没有库存减少和新订单的建立：120个被线程池接收的任务，没有一个成功完成数据库操作。</li>\n<li>日志中没有见到任何申请信号量许可的信息：甚至有可能没有进入<code>executeSeckill()</code>方法。类似于“当第200个请求被拒绝后，所有200个请求都结束了”</li>\n</ul>\n</li>\n<li>原因：“守护线程”的提前退场<ul>\n<li>用户线程：通常创建的、执行核心任务的“前台线程”。JVM规则：只要还有一个用户线程没有执行完毕，JVM进程就必须等待，不能退出。</li>\n<li>守护线程：特殊的“后台线程”，为其他线程服务。JVM规则：当程序中只剩下守护线程在运行时，JVM会认为所有核心工作已经全部完成，于是会退出并且终止所有仍在运行的守护线程。</li>\n</ul>\n</li>\n<li>由于某种原因，在seckillExecutorService中创建的工作线程，被设置为了守护线程。</li>\n</ul>\n<h4 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h4><ul>\n<li><p>在创建线程时，明确设置为“用户线程”。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPoolConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ExecutorService <span class=\"title function_\">seckillExecutorService</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ThreadFactory</span> <span class=\"variable\">namedThreadFactory</span> <span class=\"operator\">=</span> r -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(r);</span><br><span class=\"line\">            <span class=\"comment\">// 【关键改动】将线程设置为非守护线程</span></span><br><span class=\"line\">            t.setDaemon(<span class=\"literal\">false</span>); </span><br><span class=\"line\">            t.setName(<span class=\"string\">&quot;seckill-thread-&quot;</span> + t.hashCode());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建线程池的其余代码保持不变</span></span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">pool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(</span><br><span class=\"line\">                <span class=\"number\">10</span>,</span><br><span class=\"line\">                <span class=\"number\">20</span>,</span><br><span class=\"line\">                <span class=\"number\">60L</span>,</span><br><span class=\"line\">                TimeUnit.SECONDS,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;(<span class=\"number\">100</span>),</span><br><span class=\"line\">                namedThreadFactory,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>在手动创建 Thread 对象后，调用了 t.setDaemon(false);。false 表示它是一个用户线程（非守护线程），这是 Java 线程的默认行为，但在这里我们明确地指定它，以覆盖任何可能的默认设置，确保万无一失。</p>\n</li>\n<li><p>结果：库存减少至0，新增订单数100，数据正常。日志显示正常。</p>\n</li>\n</ul>\n<h3 id=\"单体应用的性能优化\"><a href=\"#单体应用的性能优化\" class=\"headerlink\" title=\"单体应用的性能优化\"></a>单体应用的性能优化</h3><h4 id=\"数据库原子化更新、引入内存售罄标记\"><a href=\"#数据库原子化更新、引入内存售罄标记\" class=\"headerlink\" title=\"数据库原子化更新、引入内存售罄标记\"></a>数据库原子化更新、引入内存售罄标记</h4><ul>\n<li><p>使用“原子化SQL更新”替代Java锁，将检查库存和扣减库存合并为同一条SQL语句，并且引入内存售罄标记。数据库原子化更新利用了数据库的行锁来保证原子性，性能远高于在Java应用层加锁。引入内存售罄标记，直接拒绝已知的无效流量，保护了后端服务。</p>\n</li>\n<li><p>修改 ProductRepository.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ProductRepository</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">JpaRepository</span>&lt;Product, Long&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 【新增】原子化扣减库存的方法</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用 <span class=\"doctag\">@Modifying</span> 注解来告诉 Spring Data JPA 这是一个“修改”操作</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用 <span class=\"doctag\">@Query</span> 注解来定义我们的 JPQL 语句</span></span><br><span class=\"line\"><span class=\"comment\">     * WHERE 子句中的 &quot;p.stock &gt; 0&quot; 是关键，它在数据库层面保证了不会超卖</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> productId 商品ID</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 返回受影响的行数，如果 &gt; 0 表示更新成功，= 0 表示库存不足或商品不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Modifying</span></span><br><span class=\"line\">    <span class=\"meta\">@Query(&quot;UPDATE Product p SET p.stock = p.stock - 1 WHERE p.id = :productId AND p.stock &gt; 0&quot;)</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">deductStock</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;productId&quot;)</span> Long productId)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重构 SeckillService.java 的核心逻辑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SeckillService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... 其他属性 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 【移除】不再需要写锁了！</span></span><br><span class=\"line\">    <span class=\"comment\">// private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock(true);</span></span><br><span class=\"line\">    <span class=\"comment\">// private final Lock writeLock = rwLock.writeLock();</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 【新增】内存售罄标记</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">isSoldOut</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">submitSeckillOrder</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 【优化】在所有逻辑之前，先检查内存标记</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isSoldOut) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;商品已售罄（内存标记拦截）&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ... 之前的提交到线程池的逻辑保持不变 ...</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... Semaphore 的获取和释放逻辑保持不变 ...</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">acquired</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            acquired = semaphore.tryAcquire(<span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!acquired) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 【移除】不再需要 Thread.sleep()</span></span><br><span class=\"line\">            <span class=\"comment\">// Thread.sleep(1000);</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 【重构】调用新的、无锁的数据库操作方法</span></span><br><span class=\"line\">            executeDbOperationsWithoutLock(productId, userId);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (acquired) &#123;</span><br><span class=\"line\">                semaphore.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 【重构】创建一个新的、无锁的数据库操作方法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeDbOperationsWithoutLock</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 【移除】不再需要 writeLock.lock()</span></span><br><span class=\"line\">        <span class=\"type\">DefaultTransactionDefinition</span> <span class=\"variable\">def</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultTransactionDefinition</span>();</span><br><span class=\"line\">        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class=\"line\">        <span class=\"type\">TransactionStatus</span> <span class=\"variable\">status</span> <span class=\"operator\">=</span> transactionManager.getTransaction(def);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 前置检查（重复下单等）依然可以保留</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (orderRepository.findByUserIdAndProductId(userId, productId) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;您已秒杀过此商品，请勿重复下单&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 1. 【核心改动】直接调用原子更新方法扣减库存</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> productRepository.deductStock(productId);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 2. 检查结果</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果更新行数为0，说明库存不足</span></span><br><span class=\"line\">                isSoldOut = <span class=\"literal\">true</span>; <span class=\"comment\">// 【优化】设置内存售罄标记</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;商品已售罄&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 3. 如果扣减成功，才创建订单...</span></span><br><span class=\"line\"></span><br><span class=\"line\">            transactionManager.commit(status);</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;线程 &#123;&#125; 秒杀成功，提交事务。&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            transactionManager.rollback(status);</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;线程 &#123;&#125; 秒杀失败，回滚事务: &#123;&#125;&quot;</span>, Thread.currentThread().getName(), e.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 【移除】不再需要 finally &#123; writeLock.unlock() &#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"集成Spring-Boot-Actuator\"><a href=\"#集成Spring-Boot-Actuator\" class=\"headerlink\" title=\"集成Spring Boot Actuator\"></a>集成Spring Boot Actuator</h4><ul>\n<li><p>修改 pom.xml 文件</p>\n</li>\n<li><p>在 <dependencies> 标签内，添加 Actuator 的 starter 依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改 src&#x2F;main&#x2F;resources&#x2F;application.properties 文件<br>添加以下配置，来暴露所有的监控端点 (endpoints) 以供访问：</p>\n</li>\n</ul>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Spring Boot Actuator 配置</span></span><br><span class=\"line\"><span class=\"comment\"># 暴露所有 Web 端点（在生产环境中应按需暴露，* 是为了开发方便）</span></span><br><span class=\"line\"><span class=\"attr\">management.endpoints.web.exposure.include</span>=<span class=\"string\">*</span></span><br><span class=\"line\"><span class=\"comment\"># (可选) 让 health 端点总是显示详细信息</span></span><br><span class=\"line\"><span class=\"attr\">management.endpoint.health.show-details</span>=<span class=\"string\">always</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"ThreadPoolExecutor-线程池\"><a href=\"#ThreadPoolExecutor-线程池\" class=\"headerlink\" title=\"ThreadPoolExecutor 线程池\"></a>ThreadPoolExecutor 线程池</h4><ul>\n<li>核心作用<ul>\n<li>降低资源消耗：通过复用已创建的线程，避免了频繁创建和销毁线程的巨大开销。</li>\n<li>提高响应速度：任务到达时，可以直接使用池中的线程执行，省去了创建线程的时间。</li>\n<li>提高客观理性：可以对线程进行统一的分配、监控和调优，防止无限制的创建线程耗尽系统资源。</li>\n</ul>\n</li>\n<li>核心参数<ul>\n<li>corePoolSize ：核心线程数，线程池长期维持的线程数量，即使它们处于空闲状态。</li>\n<li>maximumPoolSize ：最大线程数，线程池能够容纳的最大线程数量。当任务队列满了，且当前线程数小于最大线程数时，才会创建新线程。</li>\n<li>KeepAliveTime：空闲线程存活时间，当线程池中的数量大于corePoolSize时，多余的空闲线程在等待新任务时能够存活的最长时间。</li>\n<li>unit：时间单位</li>\n<li>workQueue：任务队列，用于存放等待执行的任务的阻塞队列。</li>\n<li>threadFactory： 线程工厂，用于创建新线程的工厂。</li>\n<li>rejectedExecutionHandler：拒绝策略，当任务队列和线程池都满了，新任务到来时所采取的策略。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"原子化SQL更新\"><a href=\"#原子化SQL更新\" class=\"headerlink\" title=\"原子化SQL更新\"></a>原子化SQL更新</h4><ul>\n<li>核心思想：放弃在 Java 应用层使用锁（如 ReentrantLock）来保证“读-改-写”的原子性，而是将这个职责下推到数据库层面。</li>\n<li>底层原理：数据库的 InnoDB 引擎 会对符合 WHERE 条件的行加上行锁 (Row Lock)，从而天然地保证了该操作的原子性。</li>\n</ul>\n<h4 id=\"Spring-Boot-Actuator\"><a href=\"#Spring-Boot-Actuator\" class=\"headerlink\" title=\"Spring Boot Actuator\"></a>Spring Boot Actuator</h4><ul>\n<li>核心作用：通过一系列的HTTP端点，暴露应用的内部运行情况。</li>\n<li>Actuator 是构建可观测性系统的第一步。通过它暴露的 metrics 端点，可以与 Prometheus (数据采集) 和 Grafana (数据可视化) 等工具链集成，搭建出专业的监控仪表盘，实时监控 JVM 状态、数据库连接池、线程池活跃度等关键指标。</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"用户体验：引入异步处理\"><a href=\"#用户体验：引入异步处理\" class=\"headerlink\" title=\"用户体验：引入异步处理\"></a>用户体验：引入异步处理</h3><ul>\n<li>在V1.1和V1.2，通过读写锁和信号量，构建了一个数据相对正确，流量可控的秒杀系统。尽管后端相对稳定，但用户体验糟糕，同步阻塞的模式，意味着用户必须在浏览器前“转圈圈”，等待后端的耗时操作。</li>\n<li>在V1.3中，实现异步化，将用户请求与后端耗时任务解耦，实现用户的及时响应。</li>\n</ul>\n<h4 id=\"代码改写\"><a href=\"#代码改写\" class=\"headerlink\" title=\"代码改写\"></a>代码改写</h4><ul>\n<li>线程池，创建<code>ThreadPoolConfig.java</code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPoolConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ExecutorService <span class=\"title function_\">seckillExecutorService</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 手动实现一个简单的 ThreadFactory</span></span><br><span class=\"line\">        <span class=\"type\">ThreadFactory</span> <span class=\"variable\">namedThreadFactory</span> <span class=\"operator\">=</span> r -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"string\">&quot;seckill-thread-&quot;</span> + r.hashCode());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建线程池</span></span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">pool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(</span><br><span class=\"line\">                <span class=\"number\">10</span>,     <span class=\"comment\">// corePoolSize: 核心线程数，即长期保持的线程数</span></span><br><span class=\"line\">                <span class=\"number\">20</span>,     <span class=\"comment\">// maximumPoolSize: 最大线程数</span></span><br><span class=\"line\">                <span class=\"number\">60L</span>,    <span class=\"comment\">// keepAliveTime: 空闲线程的存活时间</span></span><br><span class=\"line\">                TimeUnit.SECONDS, <span class=\"comment\">// 时间单位</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;(<span class=\"number\">100</span>), <span class=\"comment\">// workQueue: 任务队列，容量为100</span></span><br><span class=\"line\">                namedThreadFactory, <span class=\"comment\">// threadFactory: 线程工厂，用于给线程命名</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>.AbortPolicy() <span class=\"comment\">// rejectedExecutionHandler: 拒绝策略</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>重构SeckillService，分离提交与执行<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SeckillService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ExecutorService seckillExecutorService; <span class=\"comment\">// 1. 注入我们创建的线程池</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ... 其他属性保持不变 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 新的入口方法：负责接收请求并提交到线程池</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个方法会【立刻】返回，不会等待后台线程执行完毕</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">submitSeckillOrder</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 2. 创建一个任务（Runnable）</span></span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在这个任务中，调用我们之前那个耗时的、带锁的真实秒杀逻辑</span></span><br><span class=\"line\">            executeSeckill(productId, userId);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. 将任务提交给线程池</span></span><br><span class=\"line\">        seckillExecutorService.submit(task);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;请求已接收，正在排队处理中，请稍后查看订单状态。&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 真实的秒杀执行逻辑，现在是一个私有方法</span></span><br><span class=\"line\"><span class=\"comment\">     * 它会被后台线程池中的线程调用</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> productId</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> userId</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">acquired</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            acquired = semaphore.tryAcquire(<span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!acquired) &#123;</span><br><span class=\"line\">                log.warn(<span class=\"string\">&quot;线程 &#123;&#125; 获取信号量许可超时&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">                <span class=\"keyword\">return</span>; <span class=\"comment\">// 获取不到许可，直接结束任务</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// ... 省略了之前完整的、带 writeLock 和手动事务的业务逻辑 ...</span></span><br><span class=\"line\">            <span class=\"comment\">// 注意：因为这个方法现在没有返回值了，你需要通过日志来记录成功或失败</span></span><br><span class=\"line\">            <span class=\"comment\">// 比如在 commit 后 log.info(&quot;订单创建成功...&quot;)</span></span><br><span class=\"line\">            <span class=\"comment\">// 在 rollback 后 log.error(&quot;订单创建失败...&quot;)</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            Thread.currentThread().interrupt();</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;线程 &#123;&#125; 被中断&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (acquired) &#123;</span><br><span class=\"line\">                semaphore.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>更新 SeckillController，调用新的“提交”方法。</li>\n</ul>\n<h4 id=\"压测结果与分析\"><a href=\"#压测结果与分析\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li>JMeter设置与之前的版本相同，只执行写请求。</li>\n<li>结果：有120个线程成功请求到了线程池，80个失败请求。没有任何的库存减少和新订单的建立，并且在日志中没有任何关于申请信号量许可的信息。</li>\n<li>分析：<ul>\n<li>120个成功请求和80个失败请求：系统能够容纳的瞬时任务上限是20（正在执行）+100（排队等待）&#x3D;120个，而剩下的80个失败请求对应的是因为线程池已满而被拒绝。</li>\n<li>没有库存减少和新订单的建立：120个被线程池接收的任务，没有一个成功完成数据库操作。</li>\n<li>日志中没有见到任何申请信号量许可的信息：甚至有可能没有进入<code>executeSeckill()</code>方法。类似于“当第200个请求被拒绝后，所有200个请求都结束了”</li>\n</ul>\n</li>\n<li>原因：“守护线程”的提前退场<ul>\n<li>用户线程：通常创建的、执行核心任务的“前台线程”。JVM规则：只要还有一个用户线程没有执行完毕，JVM进程就必须等待，不能退出。</li>\n<li>守护线程：特殊的“后台线程”，为其他线程服务。JVM规则：当程序中只剩下守护线程在运行时，JVM会认为所有核心工作已经全部完成，于是会退出并且终止所有仍在运行的守护线程。</li>\n</ul>\n</li>\n<li>由于某种原因，在seckillExecutorService中创建的工作线程，被设置为了守护线程。</li>\n</ul>\n<h4 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h4><ul>\n<li><p>在创建线程时，明确设置为“用户线程”。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPoolConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ExecutorService <span class=\"title function_\">seckillExecutorService</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ThreadFactory</span> <span class=\"variable\">namedThreadFactory</span> <span class=\"operator\">=</span> r -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(r);</span><br><span class=\"line\">            <span class=\"comment\">// 【关键改动】将线程设置为非守护线程</span></span><br><span class=\"line\">            t.setDaemon(<span class=\"literal\">false</span>); </span><br><span class=\"line\">            t.setName(<span class=\"string\">&quot;seckill-thread-&quot;</span> + t.hashCode());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建线程池的其余代码保持不变</span></span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">pool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(</span><br><span class=\"line\">                <span class=\"number\">10</span>,</span><br><span class=\"line\">                <span class=\"number\">20</span>,</span><br><span class=\"line\">                <span class=\"number\">60L</span>,</span><br><span class=\"line\">                TimeUnit.SECONDS,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;(<span class=\"number\">100</span>),</span><br><span class=\"line\">                namedThreadFactory,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>在手动创建 Thread 对象后，调用了 t.setDaemon(false);。false 表示它是一个用户线程（非守护线程），这是 Java 线程的默认行为，但在这里我们明确地指定它，以覆盖任何可能的默认设置，确保万无一失。</p>\n</li>\n<li><p>结果：库存减少至0，新增订单数100，数据正常。日志显示正常。</p>\n</li>\n</ul>\n<h3 id=\"单体应用的性能优化\"><a href=\"#单体应用的性能优化\" class=\"headerlink\" title=\"单体应用的性能优化\"></a>单体应用的性能优化</h3><h4 id=\"数据库原子化更新、引入内存售罄标记\"><a href=\"#数据库原子化更新、引入内存售罄标记\" class=\"headerlink\" title=\"数据库原子化更新、引入内存售罄标记\"></a>数据库原子化更新、引入内存售罄标记</h4><ul>\n<li><p>使用“原子化SQL更新”替代Java锁，将检查库存和扣减库存合并为同一条SQL语句，并且引入内存售罄标记。数据库原子化更新利用了数据库的行锁来保证原子性，性能远高于在Java应用层加锁。引入内存售罄标记，直接拒绝已知的无效流量，保护了后端服务。</p>\n</li>\n<li><p>修改 ProductRepository.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ProductRepository</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">JpaRepository</span>&lt;Product, Long&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 【新增】原子化扣减库存的方法</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用 <span class=\"doctag\">@Modifying</span> 注解来告诉 Spring Data JPA 这是一个“修改”操作</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用 <span class=\"doctag\">@Query</span> 注解来定义我们的 JPQL 语句</span></span><br><span class=\"line\"><span class=\"comment\">     * WHERE 子句中的 &quot;p.stock &gt; 0&quot; 是关键，它在数据库层面保证了不会超卖</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> productId 商品ID</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 返回受影响的行数，如果 &gt; 0 表示更新成功，= 0 表示库存不足或商品不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Modifying</span></span><br><span class=\"line\">    <span class=\"meta\">@Query(&quot;UPDATE Product p SET p.stock = p.stock - 1 WHERE p.id = :productId AND p.stock &gt; 0&quot;)</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">deductStock</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;productId&quot;)</span> Long productId)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重构 SeckillService.java 的核心逻辑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SeckillService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... 其他属性 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 【移除】不再需要写锁了！</span></span><br><span class=\"line\">    <span class=\"comment\">// private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock(true);</span></span><br><span class=\"line\">    <span class=\"comment\">// private final Lock writeLock = rwLock.writeLock();</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 【新增】内存售罄标记</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">isSoldOut</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">submitSeckillOrder</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 【优化】在所有逻辑之前，先检查内存标记</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isSoldOut) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;商品已售罄（内存标记拦截）&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ... 之前的提交到线程池的逻辑保持不变 ...</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... Semaphore 的获取和释放逻辑保持不变 ...</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">acquired</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            acquired = semaphore.tryAcquire(<span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!acquired) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 【移除】不再需要 Thread.sleep()</span></span><br><span class=\"line\">            <span class=\"comment\">// Thread.sleep(1000);</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 【重构】调用新的、无锁的数据库操作方法</span></span><br><span class=\"line\">            executeDbOperationsWithoutLock(productId, userId);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (acquired) &#123;</span><br><span class=\"line\">                semaphore.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 【重构】创建一个新的、无锁的数据库操作方法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeDbOperationsWithoutLock</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 【移除】不再需要 writeLock.lock()</span></span><br><span class=\"line\">        <span class=\"type\">DefaultTransactionDefinition</span> <span class=\"variable\">def</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultTransactionDefinition</span>();</span><br><span class=\"line\">        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class=\"line\">        <span class=\"type\">TransactionStatus</span> <span class=\"variable\">status</span> <span class=\"operator\">=</span> transactionManager.getTransaction(def);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 前置检查（重复下单等）依然可以保留</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (orderRepository.findByUserIdAndProductId(userId, productId) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;您已秒杀过此商品，请勿重复下单&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 1. 【核心改动】直接调用原子更新方法扣减库存</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> productRepository.deductStock(productId);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 2. 检查结果</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果更新行数为0，说明库存不足</span></span><br><span class=\"line\">                isSoldOut = <span class=\"literal\">true</span>; <span class=\"comment\">// 【优化】设置内存售罄标记</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;商品已售罄&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 3. 如果扣减成功，才创建订单...</span></span><br><span class=\"line\"></span><br><span class=\"line\">            transactionManager.commit(status);</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;线程 &#123;&#125; 秒杀成功，提交事务。&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            transactionManager.rollback(status);</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;线程 &#123;&#125; 秒杀失败，回滚事务: &#123;&#125;&quot;</span>, Thread.currentThread().getName(), e.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 【移除】不再需要 finally &#123; writeLock.unlock() &#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"集成Spring-Boot-Actuator\"><a href=\"#集成Spring-Boot-Actuator\" class=\"headerlink\" title=\"集成Spring Boot Actuator\"></a>集成Spring Boot Actuator</h4><ul>\n<li><p>修改 pom.xml 文件</p>\n</li>\n<li><p>在 <dependencies> 标签内，添加 Actuator 的 starter 依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改 src&#x2F;main&#x2F;resources&#x2F;application.properties 文件<br>添加以下配置，来暴露所有的监控端点 (endpoints) 以供访问：</p>\n</li>\n</ul>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Spring Boot Actuator 配置</span></span><br><span class=\"line\"><span class=\"comment\"># 暴露所有 Web 端点（在生产环境中应按需暴露，* 是为了开发方便）</span></span><br><span class=\"line\"><span class=\"attr\">management.endpoints.web.exposure.include</span>=<span class=\"string\">*</span></span><br><span class=\"line\"><span class=\"comment\"># (可选) 让 health 端点总是显示详细信息</span></span><br><span class=\"line\"><span class=\"attr\">management.endpoint.health.show-details</span>=<span class=\"string\">always</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"ThreadPoolExecutor-线程池\"><a href=\"#ThreadPoolExecutor-线程池\" class=\"headerlink\" title=\"ThreadPoolExecutor 线程池\"></a>ThreadPoolExecutor 线程池</h4><ul>\n<li>核心作用<ul>\n<li>降低资源消耗：通过复用已创建的线程，避免了频繁创建和销毁线程的巨大开销。</li>\n<li>提高响应速度：任务到达时，可以直接使用池中的线程执行，省去了创建线程的时间。</li>\n<li>提高客观理性：可以对线程进行统一的分配、监控和调优，防止无限制的创建线程耗尽系统资源。</li>\n</ul>\n</li>\n<li>核心参数<ul>\n<li>corePoolSize ：核心线程数，线程池长期维持的线程数量，即使它们处于空闲状态。</li>\n<li>maximumPoolSize ：最大线程数，线程池能够容纳的最大线程数量。当任务队列满了，且当前线程数小于最大线程数时，才会创建新线程。</li>\n<li>KeepAliveTime：空闲线程存活时间，当线程池中的数量大于corePoolSize时，多余的空闲线程在等待新任务时能够存活的最长时间。</li>\n<li>unit：时间单位</li>\n<li>workQueue：任务队列，用于存放等待执行的任务的阻塞队列。</li>\n<li>threadFactory： 线程工厂，用于创建新线程的工厂。</li>\n<li>rejectedExecutionHandler：拒绝策略，当任务队列和线程池都满了，新任务到来时所采取的策略。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"原子化SQL更新\"><a href=\"#原子化SQL更新\" class=\"headerlink\" title=\"原子化SQL更新\"></a>原子化SQL更新</h4><ul>\n<li>核心思想：放弃在 Java 应用层使用锁（如 ReentrantLock）来保证“读-改-写”的原子性，而是将这个职责下推到数据库层面。</li>\n<li>底层原理：数据库的 InnoDB 引擎 会对符合 WHERE 条件的行加上行锁 (Row Lock)，从而天然地保证了该操作的原子性。</li>\n</ul>\n<h4 id=\"Spring-Boot-Actuator\"><a href=\"#Spring-Boot-Actuator\" class=\"headerlink\" title=\"Spring Boot Actuator\"></a>Spring Boot Actuator</h4><ul>\n<li>核心作用：通过一系列的HTTP端点，暴露应用的内部运行情况。</li>\n<li>Actuator 是构建可观测性系统的第一步。通过它暴露的 metrics 端点，可以与 Prometheus (数据采集) 和 Grafana (数据可视化) 等工具链集成，搭建出专业的监控仪表盘，实时监控 JVM 状态、数据库连接池、线程池活跃度等关键指标。</li>\n</ul>\n"},{"wiki":"Seckill","title":"1-秒杀项目2.0-Redis机制","tags":["Spring Boot","高并发","JUC"],"categories":["项目实战"],"poster":{"topic":"标题上方的小字","headline":"大标题","caption":"标题下方的小字","color":"标题颜色"},"date":"2025-10-05T09:59:28.000Z","description":"重新起航版","cover":null,"banner":null,"sticky":null,"mermaid":null,"katex":null,"mathjax":null,"topic":null,"author":null,"references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n### 突破限制：引入Redis机制\n\n**当前系统V1.3 已经具备的功能：**\n- 异步处理：用户的点击会立刻得到响应。\n- 流量控制：保护系统不会因过多线程而崩溃\n- 原子化SQL：数据库操作精准无误\n- 内存标记：售罄后能快速拒绝请求。\n\n**无法回避的“物理上限”：**\n- 用户体验的断崖式下跌：服务器可能在第一秒就收到了数万甚至数十万的 HTTP 请求。而应用内置的 Tomcat 服务器线程池（比如200个）会瞬间被打满。后续的所有请求，都会在操作系统的 TCP 连接队列中排队，最终大量超时。\n  -  99% 的用户刷新页面后，看到的是一个永远在“转圈圈”的加载动画，或是冰冷的 “503 Service Unavailable” 错误。\n- 数据库是最终的性能瓶颈：数据库的磁盘I/O、网络带宽、以及自身的处理能力成为了整个系统性能的天花板。\n  - 数据库通常是多个业务的**共享资源**。秒杀业务对数据库的极限压榨，会导致**整个网站的其他核心功能全部瘫痪**。普通用户无法登录、无法浏览其他商品、无法对购物车里的其他商品下单。**为了一个秒杀活动，导致整个电商平台的交易系统停摆，这是任何公司都无法接受的巨大损失。**\n- 应用服务器是“单点故障”：应用运行在一个实例上，如果这个应用因为任何原因，比如JVM崩溃或服务器宕机，挂掉，那么整个秒杀服务就会彻底中断。\n  - **整个秒杀服务彻底消失**，恢复时间未知。\n- 无法水平扩展：所有基于Java内存的并发控制，在多实例部署时都会失效。\n  - 暴露了架构的僵化和脆弱\n\n**Redis能解决什么问题？**\n- 解决了数据库雪崩和用户体验差的问题\n  - 把高频的库存读写、用户资格判断，从毫秒级的、基于磁盘的MYSQL，转移到了微秒级的、基于内存的Redis。\n  - 99%的读写流量由Redis抗住，每秒可以处理数万甚至数万次请求。\n  - 数据库只负责收尾工作，只有极少数成功抢到资格的用户，它们的订单信息才会异步的、平稳的写入数据库中。\n- 解决了单点故障和无法水平扩展的问题\n  - 通过将所有需要共享的状态统一放在Redis中，本身的Spring Boot应用本身变成了“无状态”的。\n#### 环境准备与集成\n> 在 Spring Boot 项目中成功引入并连接到 Redis\n\n1. 安装并运行Redis\n  - 在电脑上，使用docker在后台启动一个名为seckill-redis的Redis容器，并将其6379端口映射到电脑的6379端口。\n  ```Bash\n  docker run -d --name seckill-redis -p 6379:6379 redis\n  ```\n2. 添加Maven依赖\n  - 在pom.xml文件中，添加新的依赖\n  ```XML\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n  </dependency>\n  ```\n  - 保存并让IDE重新加载依赖\n3. 配置application.properties\n  - 添加 Redis 的连接信息\n  ```Properties\n  # ================== Redis Configuration ==================\n  spring.redis.host=localhost\n  spring.redis.port=6379\n  ```\n4. 验证连接\n  - 可以创建一个简单的测试类来验证应用启动时能否成功连接到Redis\n  ```Java\n  @Component\n  public class RedisConnectionTester implements CommandLineRunner {\n\n      @Autowired\n      private StringRedisTemplate redisTemplate;\n\n      @Override\n      public void run(String... args) throws Exception {\n        try {\n            String result = redisTemplate.getConnectionFactory().getConnection().ping();\n            System.out.println(\"=========================================\");\n            System.out.println(\"Successfully connected to Redis. PING response: \" + result);\n            System.out.println(\"=========================================\");\n        } catch (Exception e) {\n            System.err.println(\"=========================================\");\n            System.err.println(\"Failed to connect to Redis: \" + e.getMessage());\n            System.err.println(\"=========================================\");\n        }\n      }\n  }\n  ```\n  - 启动 Spring Boot 应用。在控制台看到了 Successfully connected to Redis 的信息，表示第一阶段就成功。\n#### 数据预热与缓存“读”操作\n> 将查询库存的流量从 MySQL 转移到 Redis。\n1. 创建数据预热Service\n  - 在秒杀开始之前，把数据从MYSQL加载到Redis。用启动时加载器来模拟。\n  - 创建`RedisPreheatService.java`\n  ```Java\n  @Service\n  public class RedisPreheatService implements CommandLineRunner{\n    public static final String STOCK_KEY = \"seckill:stock:\";\n    public static final String PRODUCT_KEY = \"seckill:product:\";\n    public static final String USER_SET_KEY = \"seckill:users:\";\n\n    @Autowired\n    private ProductRepository productRepository; // 假设你已注入\n\n    @Autowired\n    private RedisTemplate<String, Object> redisTemplate;\n\n    // 应用启动后自动执行\n    @Override\n    public void run(String... args) throws Exception {\n        // 假设我们秒杀的商品ID是 1\n        long productId = 1L;\n        Product product = productRepository.findById(productId).orElse(null);\n\n        if (product != null) {\n            // 1. 清理旧数据（为了可重复测试）\n            redisTemplate.delete(STOCK_KEY + productId);\n            redisTemplate.delete(USER_SET_KEY + productId);\n\n            // 2. 加载库存到 Redis String\n            redisTemplate.opsForValue().set(STOCK_KEY + productId, product.getStock());\n\n            System.out.println(\"=========================================\");\n            System.out.println(\"Product \" + productId + \" stock preheated to Redis: \" + product.getStock());\n            System.out.println(\"=========================================\");\n        }\n    }\n  }\n  ```\n2. 改造SeckillService的checkStock方法\n  - 直接从Redis读数据\n  ```Java\n  // 在 SeckillService.java 中\n  @Autowired\n  private RedisTemplate<String, Object> redisTemplate;\n\n  public Integer checkStock(Long productId) {\n    String stockKey = RedisPreheatService.STOCK_KEY + productId;\n    Object stockObj = redisTemplate.opsForValue().get(stockKey);\n    return stockObj != null ? Integer.parseInt(stockObj.toString()) : -1;\n  }\n  ```\n#### 核心逻辑迁移（Redis + Lua脚本）\n> 将最关键的“判断资格&扣减库存”操作，从Java层的锁+数据库，迁移到Redis的原子化Lua脚本。\n1. 创建Lua脚本文件\n  - 在 src/main/resources/ 目录下，创建一个新文件夹 scripts。\n  - 在 scripts 文件夹里，创建一个新文件 seckill.lua\n  ```Lua\n  -- seckill.lua\n  -- KEYS[1]: 库存的 key (e.g., seckill:stock:1)\n  -- KEYS[2]: 已购买用户集合的 key (e.g., seckill:users:1)\n  -- ARGV[1]: 当前请求的用户 ID\n\n  -- 1. 判断用户是否重复购买\n  if redis.call('sismember', KEYS[2], ARGV[1]) == 1 then\n    return 2 -- 2 代表重复购买\n  end\n\n  -- 2. 获取库存\n  local stock = tonumber(redis.call('get', KEYS[1]))\n  if stock <= 0 then\n    return 1 -- 1 代表库存不足\n  end\n\n  -- 3. 扣减库存\n  redis.call('decr', KEYS[1])\n\n  -- 4. 记录购买用户\n  redis.call('sadd', KEYS[2], ARGV[1])\n\n  return 0 -- 0 代表秒杀成功\n  ```\n2. 配置并加载Lua脚本\n  - 创建一个RedisConfig.java文件。用于管理与Redis相关的Bean。\n  ```Java\n  @Configuration\n  public class RedisConfig {\n\n    /**\n     * 【新增】配置并创建 RedisTemplate Bean\n     * @param connectionFactory Spring Boot 自动配置好的连接工厂\n     * @return RedisTemplate 实例\n     */\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {\n        // 创建 RedisTemplate 对象\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        // 设置连接工厂\n        template.setConnectionFactory(connectionFactory);\n\n        // 创建 JSON 序列化工具\n        GenericJackson2JsonRedisSerializer jsonSerializer = new GenericJackson2JsonRedisSerializer();\n\n        // 设置 Key 的序列化方式为 String\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n\n        // 设置 Value 的序列化方式为 JSON\n        template.setValueSerializer(jsonSerializer);\n        template.setHashValueSerializer(jsonSerializer);\n\n        // 使配置生效\n        template.afterPropertiesSet();\n        \n        return template;\n    }\n\n    @Bean\n    public DefaultRedisScript<Long> seckillScript() {\n        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();\n        redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(\"scripts/seckill.lua\")));\n        redisScript.setResultType(Long.class);\n        return redisScript;\n    }\n  }\n  ```\n3. 重构SeckillService的核心秒杀逻辑\n```Java\n// 在 SeckillService.java 中\n@Autowired\nprivate DefaultRedisScript<Long> seckillScript;\n\n// 我们需要一个内存队列来存放成功秒杀的订单信息\nprivate final BlockingQueue<SeckillOrder> orderQueue = new LinkedBlockingQueue<>(1000);\n\n// 改造异步执行的后台任务\nprivate void executeSeckill(Long productId, Long userId) {\n    List<String> keys = Arrays.asList(\n        RedisPreheatService.STOCK_KEY + productId,\n        RedisPreheatService.USER_SET_KEY + productId\n    );\n\n    // 执行 Lua 脚本\n    Long result = redisTemplate.execute(seckillScript, keys, userId.toString());\n\n    if (result == 0) {\n        log.info(\"用户 {} 秒杀成功！\", userId);\n        // 秒杀成功，生成订单信息并放入内存队列\n        // 此时订单尚未写入数据库\n        Product product = ... // 可以从缓存或数据库获取商品信息\n        SeckillOrder order = new SeckillOrder();\n        order.setProductId(productId);\n        order.setUserId(userId);\n        order.setOrderPrice(product.getPrice());\n        // 将订单放入队列\n        try {\n            orderQueue.put(order);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    } else if (result == 1) {\n        log.warn(\"用户 {} 秒杀失败：库存不足\", userId);\n    } else if (result == 2) {\n        log.warn(\"用户 {} 秒杀失败：重复下单\", userId);\n    } else {\n        log.error(\"用户 {} 秒杀异常\", userId);\n    }\n}\n```\n#### 异步持久化\n> 创建订单消费者Service\n  - 新建一个OrderConsumeService.java\n  ```Java\n  @Service\n  public class OrderConsumerService {\n    \n    // ... 其他注入的属性 ...\n\n    // 应用启动后，开启一个后台线程\n    @PostConstruct\n    private void startConsumer() {\n        new Thread(() -> {\n            while (true) {\n                try {\n                    SeckillOrder order = seckillService.getOrderQueue().take();\n                    // 2. 循环体内部现在只调用这个新的、带事务的方法\n                    createOrderInDb(order);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    log.error(\"订单消费者线程被中断\", e);\n                    break;\n                } catch (Exception e) {\n                    // 捕获所有其他可能的异常，防止线程意外终止\n                    log.error(\"处理订单时发生未知异常\", e);\n                }\n            }\n        }).start();\n    }\n\n    /**\n     * 3. 【新增】一个公开的、带事务注解的方法，专门用于数据库操作\n     * @param order 从队列中取出的订单信息\n     */\n    @Transactional\n    public void createOrderInDb(SeckillOrder order) {\n        log.info(\"正在创建订单并扣减MySQL库存: {}\", order);\n        \n        // 将所有数据库操作都放在这个方法里\n        orderRepository.save(order);\n        \n        int result = productRepository.deductStock(order.getProductId());\n        if (result == 0) {\n            // 这是一个补偿逻辑，理论上在Redis阶段已经保证了库存充足\n            // 但为了数据最终一致性，如果MySQL库存扣减失败，应抛出异常让事务回滚\n            throw new RuntimeException(\"MySQL a's stock deduction failed for order: \" + order);\n        }\n        \n        log.info(\"数据库订单创建成功\");\n    }\n  }\n  ```\n  - 在 SeckillService 中为 orderQueue 提供一个 getter 方法。\n\n### JMeter压测结果分析与改进\n#### 结果分析\n- 结果：日志显示：处理订单时发生未知异常；数据库信息显示：订单正常创建，但是库存数没有减少；存在`TransactionRequiredException`报错。\n- 分析：\n  - 订单正常创建：说明 orderRepository.save(order) 这行代码执行成功了，并且它的结果被提交到了数据库。\n  - 库存数没有减少：说明 productRepository.deductStock(...) 这行代码没有成功，或者它的结果被回滚了。\n  - 存在`TransactionRequiredException`报错：deductStock() 在执行时，没有找到一个正在运行的事务。\n  - 即，orderRepository.save() 在一个事务里成功了（或者在没有事务的情况下自动提交了），而紧接着的 deductStock() 却发现自己不在任何事务里。但是这两个方法在同一个被@Transactional注解的方法里。所以真正的原因应该是，方法上的@Transactional注解没有生效。**因为这个方法是通过this关键字进行的方法自调用，无法触发AOP代理**。当startConsumer方法在 while 循环里调用 createOrderInDb(order) 时，它实际上是在调用 this.createOrderInDb(order)，绕过了AOP代理，所以无人发现@Transactional注解，事务没有被开启。\n\n#### 改进\n- 注入服务自身，通过代理对象来调用方法。\n- 修改`OrderConsumerService.java`\n```Java\n@Service\npublic class OrderConsumerService {\n    \n    // ... 其他注入的属性 ...\n    @Autowired\n    private SeckillService seckillService;\n\n    // 2. 注入自己（代理对象）\n    // 使用 @Lazy 是为了解决循环依赖的潜在问题\n    @Autowired\n    @Lazy\n    private OrderConsumerService self;\n\n    // 应用启动后，开启一个后台线程\n    @PostConstruct\n    private void startConsumer() {\n        new Thread(() -> {\n            while (true) {\n                try {\n                    SeckillOrder order = seckillService.getOrderQueue().take();\n                    // 3. 【关键改动】通过 self 代理对象来调用事务方法\n                    self.createOrderInDb(order);\n                } catch (InterruptedException e) {\n                    // ...\n                } catch (Exception e) {\n                    // ...\n                }\n            }\n        }).start();\n    }\n\n    /**\n     * 这个方法保持不变，但现在它能被正确地代理了\n     */\n    @Transactional\n    public void createOrderInDb(SeckillOrder order) {\n        // ... 之前的数据库操作逻辑完全不变 ...\n        log.info(\"正在创建订单并扣减MySQL库存: {}\", order);\n        orderRepository.save(order);\n        int result = productRepository.deductStock(order.getProductId());\n        if (result == 0) {\n            throw new RuntimeException(\"MySQL stock deduction failed for order: \" + order);\n        }\n        log.info(\"数据库订单创建成功\");\n    }\n}\n```\n- @Autowired private OrderConsumerService self; 注入的 self 变量，不是 this 对象，而是 Spring 创建的、包含了事务处理逻辑的代理对象。\n- 当调用 self.createOrderInDb(order) 时，请求就从`startConsumer`发到了AOP代理那里。\n- AOP代理会正常地开启事务，然后再让真实对象去执行数据库操作。这样，@Transactional 就重新恢复了它的作用。\n\n- 结果：数据库信息显示正常，库存正确减少，订单正确建立。\n\n### 学学八股\n#### Redis\n- Redis是一个开源的、基于内存的、key-value结构的高性能数据库。\n  - 基于内存：是Redis高性能的根本原因。所有数据都存储在内存中，读写速度极快，远超基于磁盘的数据库。\n  - key-value：数据存储方式非常简单，像一个巨大的HashMap，通过一个唯一的Key来存取一个Value。\n  - 不仅仅是缓存：除了被用于缓存外，也被广泛运用于数据库、消息队列等。\n- 核心原理（为什么快）\n  - 纯内存操作：所有的操作都在内存中完成，完全避免了磁盘I/O这个最耗时的环节。\n  - 单线程模型：Redis的核心网络模型和命令处理是由一个单线程来完成的。无线程切换开销、无锁竞争、I/O多路复用。\n- Redis的原子性与Lua脚本\n  - Redis的单个命令是原子性的，但是多个命令组合在一起，就不是原子性的。\n  - 但Redis允许将一段Lua脚本作为一个整体发送给服务器执行，Redis会保证这个脚本在执行期间不会被任何其他命令打断，从而实现了多个命令的原子性组合。\n- Redis的持久化机制\n  - RDB：在指定的时间间隔内，将内存中的数据快照完整的写入到磁盘上的一个二进制文件中。恢复速度快，文件紧凑。但如果Redis在两次快照之间崩溃，会损失一部分数据。\n  - AOF：将每一条接受到的写命令，以追加的方式写入到一个日志文件中，恢复时，重新执行一遍文件中的所有写命令。数据的安全性更高（最多只丢失1秒的数据），单文件体积大，恢复速度相对较慢。\n- Redis的缓存经典问题\n  - 缓存穿透：查询一个数据库中根本不存在的数据，缓存中自然也没有，导致每次请求都直接打到数据库上，失去了缓存的意义。\n    - 缓存空对象：如果数据库查询结果为空，依然在Redis中缓存一个特殊的空值，并设置一个较短的过期时间。\n    - 布隆过滤器：在Redis前再加一道屏障，用布隆过滤器快速判断请求的数据是否存在。\n  - 缓存击穿：一个热点Key在某个瞬间突然失效，导致海量的并发请求同时涌向这个Key，并全部穿透到数据库，导致数据库瞬时压力过大。\n    - 互斥锁：当缓存失效时，第一个查询请求获取一个互斥锁，然后去加载数据并回设缓存。其他线程则等待锁释放后，直接从缓存中获取数据。\n    - 热点数据永不过期：对极热点的数据设置逻辑过期，由后台线程异步更新。\n  - 缓存雪崩：大量的key在同一时间集中失效，导致瞬时大量的请求都穿透到数据库。\n    - 随机化过期时间：在基础过期时间上，增加一个随机值，避免集中失效。\n    - 高可用架构：通过Redis集群、限流降级等操作，保证即使缓存出现问题，数据库也不会被完全冲垮。","source":"wiki/Seckill/1-秒杀项目2.0-Redis机制.md","raw":"---\nwiki: Seckill # 这是项目id，对应 /data/wiki/hexo-stellar.yml\ntitle: 1-秒杀项目2.0-Redis机制\ntags: [Spring Boot,高并发,JUC]\ncategories: [项目实战]\nposter:\n  topic: 标题上方的小字\n  headline: 大标题\n  caption: 标题下方的小字\n  color: 标题颜色\ndate: 2025-10-05 17:59:28\ndescription: 重新起航版\ncover:\nbanner:\nsticky:\nmermaid:\nkatex:\nmathjax:\ntopic:\nauthor:\nreferences:\ncomments:\nindexing:\nbreadcrumb:\nleftbar:\nrightbar:\nh1:\ntype: tech\n---\n\n### 突破限制：引入Redis机制\n\n**当前系统V1.3 已经具备的功能：**\n- 异步处理：用户的点击会立刻得到响应。\n- 流量控制：保护系统不会因过多线程而崩溃\n- 原子化SQL：数据库操作精准无误\n- 内存标记：售罄后能快速拒绝请求。\n\n**无法回避的“物理上限”：**\n- 用户体验的断崖式下跌：服务器可能在第一秒就收到了数万甚至数十万的 HTTP 请求。而应用内置的 Tomcat 服务器线程池（比如200个）会瞬间被打满。后续的所有请求，都会在操作系统的 TCP 连接队列中排队，最终大量超时。\n  -  99% 的用户刷新页面后，看到的是一个永远在“转圈圈”的加载动画，或是冰冷的 “503 Service Unavailable” 错误。\n- 数据库是最终的性能瓶颈：数据库的磁盘I/O、网络带宽、以及自身的处理能力成为了整个系统性能的天花板。\n  - 数据库通常是多个业务的**共享资源**。秒杀业务对数据库的极限压榨，会导致**整个网站的其他核心功能全部瘫痪**。普通用户无法登录、无法浏览其他商品、无法对购物车里的其他商品下单。**为了一个秒杀活动，导致整个电商平台的交易系统停摆，这是任何公司都无法接受的巨大损失。**\n- 应用服务器是“单点故障”：应用运行在一个实例上，如果这个应用因为任何原因，比如JVM崩溃或服务器宕机，挂掉，那么整个秒杀服务就会彻底中断。\n  - **整个秒杀服务彻底消失**，恢复时间未知。\n- 无法水平扩展：所有基于Java内存的并发控制，在多实例部署时都会失效。\n  - 暴露了架构的僵化和脆弱\n\n**Redis能解决什么问题？**\n- 解决了数据库雪崩和用户体验差的问题\n  - 把高频的库存读写、用户资格判断，从毫秒级的、基于磁盘的MYSQL，转移到了微秒级的、基于内存的Redis。\n  - 99%的读写流量由Redis抗住，每秒可以处理数万甚至数万次请求。\n  - 数据库只负责收尾工作，只有极少数成功抢到资格的用户，它们的订单信息才会异步的、平稳的写入数据库中。\n- 解决了单点故障和无法水平扩展的问题\n  - 通过将所有需要共享的状态统一放在Redis中，本身的Spring Boot应用本身变成了“无状态”的。\n#### 环境准备与集成\n> 在 Spring Boot 项目中成功引入并连接到 Redis\n\n1. 安装并运行Redis\n  - 在电脑上，使用docker在后台启动一个名为seckill-redis的Redis容器，并将其6379端口映射到电脑的6379端口。\n  ```Bash\n  docker run -d --name seckill-redis -p 6379:6379 redis\n  ```\n2. 添加Maven依赖\n  - 在pom.xml文件中，添加新的依赖\n  ```XML\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n  </dependency>\n  ```\n  - 保存并让IDE重新加载依赖\n3. 配置application.properties\n  - 添加 Redis 的连接信息\n  ```Properties\n  # ================== Redis Configuration ==================\n  spring.redis.host=localhost\n  spring.redis.port=6379\n  ```\n4. 验证连接\n  - 可以创建一个简单的测试类来验证应用启动时能否成功连接到Redis\n  ```Java\n  @Component\n  public class RedisConnectionTester implements CommandLineRunner {\n\n      @Autowired\n      private StringRedisTemplate redisTemplate;\n\n      @Override\n      public void run(String... args) throws Exception {\n        try {\n            String result = redisTemplate.getConnectionFactory().getConnection().ping();\n            System.out.println(\"=========================================\");\n            System.out.println(\"Successfully connected to Redis. PING response: \" + result);\n            System.out.println(\"=========================================\");\n        } catch (Exception e) {\n            System.err.println(\"=========================================\");\n            System.err.println(\"Failed to connect to Redis: \" + e.getMessage());\n            System.err.println(\"=========================================\");\n        }\n      }\n  }\n  ```\n  - 启动 Spring Boot 应用。在控制台看到了 Successfully connected to Redis 的信息，表示第一阶段就成功。\n#### 数据预热与缓存“读”操作\n> 将查询库存的流量从 MySQL 转移到 Redis。\n1. 创建数据预热Service\n  - 在秒杀开始之前，把数据从MYSQL加载到Redis。用启动时加载器来模拟。\n  - 创建`RedisPreheatService.java`\n  ```Java\n  @Service\n  public class RedisPreheatService implements CommandLineRunner{\n    public static final String STOCK_KEY = \"seckill:stock:\";\n    public static final String PRODUCT_KEY = \"seckill:product:\";\n    public static final String USER_SET_KEY = \"seckill:users:\";\n\n    @Autowired\n    private ProductRepository productRepository; // 假设你已注入\n\n    @Autowired\n    private RedisTemplate<String, Object> redisTemplate;\n\n    // 应用启动后自动执行\n    @Override\n    public void run(String... args) throws Exception {\n        // 假设我们秒杀的商品ID是 1\n        long productId = 1L;\n        Product product = productRepository.findById(productId).orElse(null);\n\n        if (product != null) {\n            // 1. 清理旧数据（为了可重复测试）\n            redisTemplate.delete(STOCK_KEY + productId);\n            redisTemplate.delete(USER_SET_KEY + productId);\n\n            // 2. 加载库存到 Redis String\n            redisTemplate.opsForValue().set(STOCK_KEY + productId, product.getStock());\n\n            System.out.println(\"=========================================\");\n            System.out.println(\"Product \" + productId + \" stock preheated to Redis: \" + product.getStock());\n            System.out.println(\"=========================================\");\n        }\n    }\n  }\n  ```\n2. 改造SeckillService的checkStock方法\n  - 直接从Redis读数据\n  ```Java\n  // 在 SeckillService.java 中\n  @Autowired\n  private RedisTemplate<String, Object> redisTemplate;\n\n  public Integer checkStock(Long productId) {\n    String stockKey = RedisPreheatService.STOCK_KEY + productId;\n    Object stockObj = redisTemplate.opsForValue().get(stockKey);\n    return stockObj != null ? Integer.parseInt(stockObj.toString()) : -1;\n  }\n  ```\n#### 核心逻辑迁移（Redis + Lua脚本）\n> 将最关键的“判断资格&扣减库存”操作，从Java层的锁+数据库，迁移到Redis的原子化Lua脚本。\n1. 创建Lua脚本文件\n  - 在 src/main/resources/ 目录下，创建一个新文件夹 scripts。\n  - 在 scripts 文件夹里，创建一个新文件 seckill.lua\n  ```Lua\n  -- seckill.lua\n  -- KEYS[1]: 库存的 key (e.g., seckill:stock:1)\n  -- KEYS[2]: 已购买用户集合的 key (e.g., seckill:users:1)\n  -- ARGV[1]: 当前请求的用户 ID\n\n  -- 1. 判断用户是否重复购买\n  if redis.call('sismember', KEYS[2], ARGV[1]) == 1 then\n    return 2 -- 2 代表重复购买\n  end\n\n  -- 2. 获取库存\n  local stock = tonumber(redis.call('get', KEYS[1]))\n  if stock <= 0 then\n    return 1 -- 1 代表库存不足\n  end\n\n  -- 3. 扣减库存\n  redis.call('decr', KEYS[1])\n\n  -- 4. 记录购买用户\n  redis.call('sadd', KEYS[2], ARGV[1])\n\n  return 0 -- 0 代表秒杀成功\n  ```\n2. 配置并加载Lua脚本\n  - 创建一个RedisConfig.java文件。用于管理与Redis相关的Bean。\n  ```Java\n  @Configuration\n  public class RedisConfig {\n\n    /**\n     * 【新增】配置并创建 RedisTemplate Bean\n     * @param connectionFactory Spring Boot 自动配置好的连接工厂\n     * @return RedisTemplate 实例\n     */\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {\n        // 创建 RedisTemplate 对象\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        // 设置连接工厂\n        template.setConnectionFactory(connectionFactory);\n\n        // 创建 JSON 序列化工具\n        GenericJackson2JsonRedisSerializer jsonSerializer = new GenericJackson2JsonRedisSerializer();\n\n        // 设置 Key 的序列化方式为 String\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n\n        // 设置 Value 的序列化方式为 JSON\n        template.setValueSerializer(jsonSerializer);\n        template.setHashValueSerializer(jsonSerializer);\n\n        // 使配置生效\n        template.afterPropertiesSet();\n        \n        return template;\n    }\n\n    @Bean\n    public DefaultRedisScript<Long> seckillScript() {\n        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();\n        redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(\"scripts/seckill.lua\")));\n        redisScript.setResultType(Long.class);\n        return redisScript;\n    }\n  }\n  ```\n3. 重构SeckillService的核心秒杀逻辑\n```Java\n// 在 SeckillService.java 中\n@Autowired\nprivate DefaultRedisScript<Long> seckillScript;\n\n// 我们需要一个内存队列来存放成功秒杀的订单信息\nprivate final BlockingQueue<SeckillOrder> orderQueue = new LinkedBlockingQueue<>(1000);\n\n// 改造异步执行的后台任务\nprivate void executeSeckill(Long productId, Long userId) {\n    List<String> keys = Arrays.asList(\n        RedisPreheatService.STOCK_KEY + productId,\n        RedisPreheatService.USER_SET_KEY + productId\n    );\n\n    // 执行 Lua 脚本\n    Long result = redisTemplate.execute(seckillScript, keys, userId.toString());\n\n    if (result == 0) {\n        log.info(\"用户 {} 秒杀成功！\", userId);\n        // 秒杀成功，生成订单信息并放入内存队列\n        // 此时订单尚未写入数据库\n        Product product = ... // 可以从缓存或数据库获取商品信息\n        SeckillOrder order = new SeckillOrder();\n        order.setProductId(productId);\n        order.setUserId(userId);\n        order.setOrderPrice(product.getPrice());\n        // 将订单放入队列\n        try {\n            orderQueue.put(order);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    } else if (result == 1) {\n        log.warn(\"用户 {} 秒杀失败：库存不足\", userId);\n    } else if (result == 2) {\n        log.warn(\"用户 {} 秒杀失败：重复下单\", userId);\n    } else {\n        log.error(\"用户 {} 秒杀异常\", userId);\n    }\n}\n```\n#### 异步持久化\n> 创建订单消费者Service\n  - 新建一个OrderConsumeService.java\n  ```Java\n  @Service\n  public class OrderConsumerService {\n    \n    // ... 其他注入的属性 ...\n\n    // 应用启动后，开启一个后台线程\n    @PostConstruct\n    private void startConsumer() {\n        new Thread(() -> {\n            while (true) {\n                try {\n                    SeckillOrder order = seckillService.getOrderQueue().take();\n                    // 2. 循环体内部现在只调用这个新的、带事务的方法\n                    createOrderInDb(order);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    log.error(\"订单消费者线程被中断\", e);\n                    break;\n                } catch (Exception e) {\n                    // 捕获所有其他可能的异常，防止线程意外终止\n                    log.error(\"处理订单时发生未知异常\", e);\n                }\n            }\n        }).start();\n    }\n\n    /**\n     * 3. 【新增】一个公开的、带事务注解的方法，专门用于数据库操作\n     * @param order 从队列中取出的订单信息\n     */\n    @Transactional\n    public void createOrderInDb(SeckillOrder order) {\n        log.info(\"正在创建订单并扣减MySQL库存: {}\", order);\n        \n        // 将所有数据库操作都放在这个方法里\n        orderRepository.save(order);\n        \n        int result = productRepository.deductStock(order.getProductId());\n        if (result == 0) {\n            // 这是一个补偿逻辑，理论上在Redis阶段已经保证了库存充足\n            // 但为了数据最终一致性，如果MySQL库存扣减失败，应抛出异常让事务回滚\n            throw new RuntimeException(\"MySQL a's stock deduction failed for order: \" + order);\n        }\n        \n        log.info(\"数据库订单创建成功\");\n    }\n  }\n  ```\n  - 在 SeckillService 中为 orderQueue 提供一个 getter 方法。\n\n### JMeter压测结果分析与改进\n#### 结果分析\n- 结果：日志显示：处理订单时发生未知异常；数据库信息显示：订单正常创建，但是库存数没有减少；存在`TransactionRequiredException`报错。\n- 分析：\n  - 订单正常创建：说明 orderRepository.save(order) 这行代码执行成功了，并且它的结果被提交到了数据库。\n  - 库存数没有减少：说明 productRepository.deductStock(...) 这行代码没有成功，或者它的结果被回滚了。\n  - 存在`TransactionRequiredException`报错：deductStock() 在执行时，没有找到一个正在运行的事务。\n  - 即，orderRepository.save() 在一个事务里成功了（或者在没有事务的情况下自动提交了），而紧接着的 deductStock() 却发现自己不在任何事务里。但是这两个方法在同一个被@Transactional注解的方法里。所以真正的原因应该是，方法上的@Transactional注解没有生效。**因为这个方法是通过this关键字进行的方法自调用，无法触发AOP代理**。当startConsumer方法在 while 循环里调用 createOrderInDb(order) 时，它实际上是在调用 this.createOrderInDb(order)，绕过了AOP代理，所以无人发现@Transactional注解，事务没有被开启。\n\n#### 改进\n- 注入服务自身，通过代理对象来调用方法。\n- 修改`OrderConsumerService.java`\n```Java\n@Service\npublic class OrderConsumerService {\n    \n    // ... 其他注入的属性 ...\n    @Autowired\n    private SeckillService seckillService;\n\n    // 2. 注入自己（代理对象）\n    // 使用 @Lazy 是为了解决循环依赖的潜在问题\n    @Autowired\n    @Lazy\n    private OrderConsumerService self;\n\n    // 应用启动后，开启一个后台线程\n    @PostConstruct\n    private void startConsumer() {\n        new Thread(() -> {\n            while (true) {\n                try {\n                    SeckillOrder order = seckillService.getOrderQueue().take();\n                    // 3. 【关键改动】通过 self 代理对象来调用事务方法\n                    self.createOrderInDb(order);\n                } catch (InterruptedException e) {\n                    // ...\n                } catch (Exception e) {\n                    // ...\n                }\n            }\n        }).start();\n    }\n\n    /**\n     * 这个方法保持不变，但现在它能被正确地代理了\n     */\n    @Transactional\n    public void createOrderInDb(SeckillOrder order) {\n        // ... 之前的数据库操作逻辑完全不变 ...\n        log.info(\"正在创建订单并扣减MySQL库存: {}\", order);\n        orderRepository.save(order);\n        int result = productRepository.deductStock(order.getProductId());\n        if (result == 0) {\n            throw new RuntimeException(\"MySQL stock deduction failed for order: \" + order);\n        }\n        log.info(\"数据库订单创建成功\");\n    }\n}\n```\n- @Autowired private OrderConsumerService self; 注入的 self 变量，不是 this 对象，而是 Spring 创建的、包含了事务处理逻辑的代理对象。\n- 当调用 self.createOrderInDb(order) 时，请求就从`startConsumer`发到了AOP代理那里。\n- AOP代理会正常地开启事务，然后再让真实对象去执行数据库操作。这样，@Transactional 就重新恢复了它的作用。\n\n- 结果：数据库信息显示正常，库存正确减少，订单正确建立。\n\n### 学学八股\n#### Redis\n- Redis是一个开源的、基于内存的、key-value结构的高性能数据库。\n  - 基于内存：是Redis高性能的根本原因。所有数据都存储在内存中，读写速度极快，远超基于磁盘的数据库。\n  - key-value：数据存储方式非常简单，像一个巨大的HashMap，通过一个唯一的Key来存取一个Value。\n  - 不仅仅是缓存：除了被用于缓存外，也被广泛运用于数据库、消息队列等。\n- 核心原理（为什么快）\n  - 纯内存操作：所有的操作都在内存中完成，完全避免了磁盘I/O这个最耗时的环节。\n  - 单线程模型：Redis的核心网络模型和命令处理是由一个单线程来完成的。无线程切换开销、无锁竞争、I/O多路复用。\n- Redis的原子性与Lua脚本\n  - Redis的单个命令是原子性的，但是多个命令组合在一起，就不是原子性的。\n  - 但Redis允许将一段Lua脚本作为一个整体发送给服务器执行，Redis会保证这个脚本在执行期间不会被任何其他命令打断，从而实现了多个命令的原子性组合。\n- Redis的持久化机制\n  - RDB：在指定的时间间隔内，将内存中的数据快照完整的写入到磁盘上的一个二进制文件中。恢复速度快，文件紧凑。但如果Redis在两次快照之间崩溃，会损失一部分数据。\n  - AOF：将每一条接受到的写命令，以追加的方式写入到一个日志文件中，恢复时，重新执行一遍文件中的所有写命令。数据的安全性更高（最多只丢失1秒的数据），单文件体积大，恢复速度相对较慢。\n- Redis的缓存经典问题\n  - 缓存穿透：查询一个数据库中根本不存在的数据，缓存中自然也没有，导致每次请求都直接打到数据库上，失去了缓存的意义。\n    - 缓存空对象：如果数据库查询结果为空，依然在Redis中缓存一个特殊的空值，并设置一个较短的过期时间。\n    - 布隆过滤器：在Redis前再加一道屏障，用布隆过滤器快速判断请求的数据是否存在。\n  - 缓存击穿：一个热点Key在某个瞬间突然失效，导致海量的并发请求同时涌向这个Key，并全部穿透到数据库，导致数据库瞬时压力过大。\n    - 互斥锁：当缓存失效时，第一个查询请求获取一个互斥锁，然后去加载数据并回设缓存。其他线程则等待锁释放后，直接从缓存中获取数据。\n    - 热点数据永不过期：对极热点的数据设置逻辑过期，由后台线程异步更新。\n  - 缓存雪崩：大量的key在同一时间集中失效，导致瞬时大量的请求都穿透到数据库。\n    - 随机化过期时间：在基础过期时间上，增加一个随机值，避免集中失效。\n    - 高可用架构：通过Redis集群、限流降级等操作，保证即使缓存出现问题，数据库也不会被完全冲垮。","updated":"2025-10-05T11:47:54.059Z","path":"wiki/Seckill/1-秒杀项目2.0-Redis机制.html","layout":"page","_id":"cmgdn5rh7000l0wuz261v38hm","content":"<h3 id=\"突破限制：引入Redis机制\"><a href=\"#突破限制：引入Redis机制\" class=\"headerlink\" title=\"突破限制：引入Redis机制\"></a>突破限制：引入Redis机制</h3><p><strong>当前系统V1.3 已经具备的功能：</strong></p>\n<ul>\n<li>异步处理：用户的点击会立刻得到响应。</li>\n<li>流量控制：保护系统不会因过多线程而崩溃</li>\n<li>原子化SQL：数据库操作精准无误</li>\n<li>内存标记：售罄后能快速拒绝请求。</li>\n</ul>\n<p><strong>无法回避的“物理上限”：</strong></p>\n<ul>\n<li>用户体验的断崖式下跌：服务器可能在第一秒就收到了数万甚至数十万的 HTTP 请求。而应用内置的 Tomcat 服务器线程池（比如200个）会瞬间被打满。后续的所有请求，都会在操作系统的 TCP 连接队列中排队，最终大量超时。<ul>\n<li>99% 的用户刷新页面后，看到的是一个永远在“转圈圈”的加载动画，或是冰冷的 “503 Service Unavailable” 错误。</li>\n</ul>\n</li>\n<li>数据库是最终的性能瓶颈：数据库的磁盘I&#x2F;O、网络带宽、以及自身的处理能力成为了整个系统性能的天花板。<ul>\n<li>数据库通常是多个业务的<strong>共享资源</strong>。秒杀业务对数据库的极限压榨，会导致<strong>整个网站的其他核心功能全部瘫痪</strong>。普通用户无法登录、无法浏览其他商品、无法对购物车里的其他商品下单。<strong>为了一个秒杀活动，导致整个电商平台的交易系统停摆，这是任何公司都无法接受的巨大损失。</strong></li>\n</ul>\n</li>\n<li>应用服务器是“单点故障”：应用运行在一个实例上，如果这个应用因为任何原因，比如JVM崩溃或服务器宕机，挂掉，那么整个秒杀服务就会彻底中断。<ul>\n<li><strong>整个秒杀服务彻底消失</strong>，恢复时间未知。</li>\n</ul>\n</li>\n<li>无法水平扩展：所有基于Java内存的并发控制，在多实例部署时都会失效。<ul>\n<li>暴露了架构的僵化和脆弱</li>\n</ul>\n</li>\n</ul>\n<p><strong>Redis能解决什么问题？</strong></p>\n<ul>\n<li>解决了数据库雪崩和用户体验差的问题<ul>\n<li>把高频的库存读写、用户资格判断，从毫秒级的、基于磁盘的MYSQL，转移到了微秒级的、基于内存的Redis。</li>\n<li>99%的读写流量由Redis抗住，每秒可以处理数万甚至数万次请求。</li>\n<li>数据库只负责收尾工作，只有极少数成功抢到资格的用户，它们的订单信息才会异步的、平稳的写入数据库中。</li>\n</ul>\n</li>\n<li>解决了单点故障和无法水平扩展的问题<ul>\n<li>通过将所有需要共享的状态统一放在Redis中，本身的Spring Boot应用本身变成了“无状态”的。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"环境准备与集成\"><a href=\"#环境准备与集成\" class=\"headerlink\" title=\"环境准备与集成\"></a>环境准备与集成</h4><blockquote>\n<p>在 Spring Boot 项目中成功引入并连接到 Redis</p>\n</blockquote>\n<ol>\n<li>安装并运行Redis</li>\n</ol>\n<ul>\n<li>在电脑上，使用docker在后台启动一个名为seckill-redis的Redis容器，并将其6379端口映射到电脑的6379端口。  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d --name seckill-redis -p 6379:6379 redis</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>添加Maven依赖</li>\n</ol>\n<ul>\n<li>在pom.xml文件中，添加新的依赖  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>保存并让IDE重新加载依赖</li>\n</ul>\n<ol start=\"3\">\n<li>配置application.properties</li>\n</ol>\n<ul>\n<li>添加 Redis 的连接信息  <figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ================== Redis Configuration ==================</span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.host</span>=<span class=\"string\">localhost</span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.port</span>=<span class=\"string\">6379</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"4\">\n<li>验证连接</li>\n</ol>\n<ul>\n<li>可以创建一个简单的测试类来验证应用启动时能否成功连接到Redis  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisConnectionTester</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CommandLineRunner</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> StringRedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> redisTemplate.getConnectionFactory().getConnection().ping();</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;Successfully connected to Redis. PING response: &quot;</span> + result);</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">          System.err.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">          System.err.println(<span class=\"string\">&quot;Failed to connect to Redis: &quot;</span> + e.getMessage());</span><br><span class=\"line\">          System.err.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>启动 Spring Boot 应用。在控制台看到了 Successfully connected to Redis 的信息，表示第一阶段就成功。</li>\n</ul>\n<h4 id=\"数据预热与缓存“读”操作\"><a href=\"#数据预热与缓存“读”操作\" class=\"headerlink\" title=\"数据预热与缓存“读”操作\"></a>数据预热与缓存“读”操作</h4><blockquote>\n<p>将查询库存的流量从 MySQL 转移到 Redis。</p>\n</blockquote>\n<ol>\n<li>创建数据预热Service</li>\n</ol>\n<ul>\n<li>在秒杀开始之前，把数据从MYSQL加载到Redis。用启动时加载器来模拟。</li>\n<li>创建<code>RedisPreheatService.java</code>  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisPreheatService</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CommandLineRunner</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">STOCK_KEY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;seckill:stock:&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">PRODUCT_KEY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;seckill:product:&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">USER_SET_KEY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;seckill:users:&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> ProductRepository productRepository; <span class=\"comment\">// 假设你已注入</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 应用启动后自动执行</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 假设我们秒杀的商品ID是 1</span></span><br><span class=\"line\">      <span class=\"type\">long</span> <span class=\"variable\">productId</span> <span class=\"operator\">=</span> <span class=\"number\">1L</span>;</span><br><span class=\"line\">      <span class=\"type\">Product</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> productRepository.findById(productId).orElse(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (product != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 1. 清理旧数据（为了可重复测试）</span></span><br><span class=\"line\">          redisTemplate.delete(STOCK_KEY + productId);</span><br><span class=\"line\">          redisTemplate.delete(USER_SET_KEY + productId);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// 2. 加载库存到 Redis String</span></span><br><span class=\"line\">          redisTemplate.opsForValue().set(STOCK_KEY + productId, product.getStock());</span><br><span class=\"line\"></span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;Product &quot;</span> + productId + <span class=\"string\">&quot; stock preheated to Redis: &quot;</span> + product.getStock());</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>改造SeckillService的checkStock方法</li>\n</ol>\n<ul>\n<li>直接从Redis读数据  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 SeckillService.java 中</span></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> Integer <span class=\"title function_\">checkStock</span><span class=\"params\">(Long productId)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">stockKey</span> <span class=\"operator\">=</span> RedisPreheatService.STOCK_KEY + productId;</span><br><span class=\"line\">  <span class=\"type\">Object</span> <span class=\"variable\">stockObj</span> <span class=\"operator\">=</span> redisTemplate.opsForValue().get(stockKey);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> stockObj != <span class=\"literal\">null</span> ? Integer.parseInt(stockObj.toString()) : -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"核心逻辑迁移（Redis-Lua脚本）\"><a href=\"#核心逻辑迁移（Redis-Lua脚本）\" class=\"headerlink\" title=\"核心逻辑迁移（Redis + Lua脚本）\"></a>核心逻辑迁移（Redis + Lua脚本）</h4><blockquote>\n<p>将最关键的“判断资格&amp;扣减库存”操作，从Java层的锁+数据库，迁移到Redis的原子化Lua脚本。</p>\n</blockquote>\n<ol>\n<li>创建Lua脚本文件</li>\n</ol>\n<ul>\n<li>在 src&#x2F;main&#x2F;resources&#x2F; 目录下，创建一个新文件夹 scripts。</li>\n<li>在 scripts 文件夹里，创建一个新文件 seckill.lua  <figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- seckill.lua</span></span><br><span class=\"line\"><span class=\"comment\">-- KEYS[1]: 库存的 key (e.g., seckill:stock:1)</span></span><br><span class=\"line\"><span class=\"comment\">-- KEYS[2]: 已购买用户集合的 key (e.g., seckill:users:1)</span></span><br><span class=\"line\"><span class=\"comment\">-- ARGV[1]: 当前请求的用户 ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 1. 判断用户是否重复购买</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> redis.call(<span class=\"string\">&#x27;sismember&#x27;</span>, KEYS[<span class=\"number\">2</span>], ARGV[<span class=\"number\">1</span>]) == <span class=\"number\">1</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">2</span> <span class=\"comment\">-- 2 代表重复购买</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 2. 获取库存</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> stock = <span class=\"built_in\">tonumber</span>(redis.call(<span class=\"string\">&#x27;get&#x27;</span>, KEYS[<span class=\"number\">1</span>]))</span><br><span class=\"line\"><span class=\"keyword\">if</span> stock &lt;= <span class=\"number\">0</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span> <span class=\"comment\">-- 1 代表库存不足</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 3. 扣减库存</span></span><br><span class=\"line\">redis.call(<span class=\"string\">&#x27;decr&#x27;</span>, KEYS[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 4. 记录购买用户</span></span><br><span class=\"line\">redis.call(<span class=\"string\">&#x27;sadd&#x27;</span>, KEYS[<span class=\"number\">2</span>], ARGV[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span> <span class=\"comment\">-- 0 代表秒杀成功</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>配置并加载Lua脚本</li>\n</ol>\n<ul>\n<li>创建一个RedisConfig.java文件。用于管理与Redis相关的Bean。  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 【新增】配置并创建 RedisTemplate Bean</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param</span> connectionFactory Spring Boot 自动配置好的连接工厂</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return</span> RedisTemplate 实例</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> RedisTemplate&lt;String, Object&gt; <span class=\"title function_\">redisTemplate</span><span class=\"params\">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 创建 RedisTemplate 对象</span></span><br><span class=\"line\">      RedisTemplate&lt;String, Object&gt; template = <span class=\"keyword\">new</span> <span class=\"title class_\">RedisTemplate</span>&lt;&gt;();</span><br><span class=\"line\">      <span class=\"comment\">// 设置连接工厂</span></span><br><span class=\"line\">      template.setConnectionFactory(connectionFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 创建 JSON 序列化工具</span></span><br><span class=\"line\">      <span class=\"type\">GenericJackson2JsonRedisSerializer</span> <span class=\"variable\">jsonSerializer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">GenericJackson2JsonRedisSerializer</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 设置 Key 的序列化方式为 String</span></span><br><span class=\"line\">      template.setKeySerializer(<span class=\"keyword\">new</span> <span class=\"title class_\">StringRedisSerializer</span>());</span><br><span class=\"line\">      template.setHashKeySerializer(<span class=\"keyword\">new</span> <span class=\"title class_\">StringRedisSerializer</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 设置 Value 的序列化方式为 JSON</span></span><br><span class=\"line\">      template.setValueSerializer(jsonSerializer);</span><br><span class=\"line\">      template.setHashValueSerializer(jsonSerializer);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 使配置生效</span></span><br><span class=\"line\">      template.afterPropertiesSet();</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">return</span> template;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> DefaultRedisScript&lt;Long&gt; <span class=\"title function_\">seckillScript</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      DefaultRedisScript&lt;Long&gt; redisScript = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;();</span><br><span class=\"line\">      redisScript.setScriptSource(<span class=\"keyword\">new</span> <span class=\"title class_\">ResourceScriptSource</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathResource</span>(<span class=\"string\">&quot;scripts/seckill.lua&quot;</span>)));</span><br><span class=\"line\">      redisScript.setResultType(Long.class);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> redisScript;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"3\">\n<li>重构SeckillService的核心秒杀逻辑<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 SeckillService.java 中</span></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> DefaultRedisScript&lt;Long&gt; seckillScript;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们需要一个内存队列来存放成功秒杀的订单信息</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;SeckillOrder&gt; orderQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;(<span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 改造异步执行的后台任务</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">    List&lt;String&gt; keys = Arrays.asList(</span><br><span class=\"line\">        RedisPreheatService.STOCK_KEY + productId,</span><br><span class=\"line\">        RedisPreheatService.USER_SET_KEY + productId</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 Lua 脚本</span></span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> redisTemplate.execute(seckillScript, keys, userId.toString());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;用户 &#123;&#125; 秒杀成功！&quot;</span>, userId);</span><br><span class=\"line\">        <span class=\"comment\">// 秒杀成功，生成订单信息并放入内存队列</span></span><br><span class=\"line\">        <span class=\"comment\">// 此时订单尚未写入数据库</span></span><br><span class=\"line\">        <span class=\"type\">Product</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> ... <span class=\"comment\">// 可以从缓存或数据库获取商品信息</span></span><br><span class=\"line\">        <span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SeckillOrder</span>();</span><br><span class=\"line\">        order.setProductId(productId);</span><br><span class=\"line\">        order.setUserId(userId);</span><br><span class=\"line\">        order.setOrderPrice(product.getPrice());</span><br><span class=\"line\">        <span class=\"comment\">// 将订单放入队列</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            orderQueue.put(order);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            Thread.currentThread().interrupt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (result == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;用户 &#123;&#125; 秒杀失败：库存不足&quot;</span>, userId);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (result == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;用户 &#123;&#125; 秒杀失败：重复下单&quot;</span>, userId);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;用户 &#123;&#125; 秒杀异常&quot;</span>, userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"异步持久化\"><a href=\"#异步持久化\" class=\"headerlink\" title=\"异步持久化\"></a>异步持久化</h4><blockquote>\n<p>创建订单消费者Service</p>\n</blockquote>\n<ul>\n<li>新建一个OrderConsumeService.java  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderConsumerService</span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// ... 其他注入的属性 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 应用启动后，开启一个后台线程</span></span><br><span class=\"line\">  <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startConsumer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                  <span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> seckillService.getOrderQueue().take();</span><br><span class=\"line\">                  <span class=\"comment\">// 2. 循环体内部现在只调用这个新的、带事务的方法</span></span><br><span class=\"line\">                  createOrderInDb(order);</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                  Thread.currentThread().interrupt();</span><br><span class=\"line\">                  log.error(<span class=\"string\">&quot;订单消费者线程被中断&quot;</span>, e);</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// 捕获所有其他可能的异常，防止线程意外终止</span></span><br><span class=\"line\">                  log.error(<span class=\"string\">&quot;处理订单时发生未知异常&quot;</span>, e);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;).start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 3. 【新增】一个公开的、带事务注解的方法，专门用于数据库操作</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param</span> order 从队列中取出的订单信息</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createOrderInDb</span><span class=\"params\">(SeckillOrder order)</span> &#123;</span><br><span class=\"line\">      log.info(<span class=\"string\">&quot;正在创建订单并扣减MySQL库存: &#123;&#125;&quot;</span>, order);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 将所有数据库操作都放在这个方法里</span></span><br><span class=\"line\">      orderRepository.save(order);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> productRepository.deductStock(order.getProductId());</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 这是一个补偿逻辑，理论上在Redis阶段已经保证了库存充足</span></span><br><span class=\"line\">          <span class=\"comment\">// 但为了数据最终一致性，如果MySQL库存扣减失败，应抛出异常让事务回滚</span></span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;MySQL a&#x27;s stock deduction failed for order: &quot;</span> + order);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      log.info(<span class=\"string\">&quot;数据库订单创建成功&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>在 SeckillService 中为 orderQueue 提供一个 getter 方法。</li>\n</ul>\n<h3 id=\"JMeter压测结果分析与改进\"><a href=\"#JMeter压测结果分析与改进\" class=\"headerlink\" title=\"JMeter压测结果分析与改进\"></a>JMeter压测结果分析与改进</h3><h4 id=\"结果分析\"><a href=\"#结果分析\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h4><ul>\n<li>结果：日志显示：处理订单时发生未知异常；数据库信息显示：订单正常创建，但是库存数没有减少；存在<code>TransactionRequiredException</code>报错。</li>\n<li>分析：<ul>\n<li>订单正常创建：说明 orderRepository.save(order) 这行代码执行成功了，并且它的结果被提交到了数据库。</li>\n<li>库存数没有减少：说明 productRepository.deductStock(…) 这行代码没有成功，或者它的结果被回滚了。</li>\n<li>存在<code>TransactionRequiredException</code>报错：deductStock() 在执行时，没有找到一个正在运行的事务。</li>\n<li>即，orderRepository.save() 在一个事务里成功了（或者在没有事务的情况下自动提交了），而紧接着的 deductStock() 却发现自己不在任何事务里。但是这两个方法在同一个被@Transactional注解的方法里。所以真正的原因应该是，方法上的@Transactional注解没有生效。<strong>因为这个方法是通过this关键字进行的方法自调用，无法触发AOP代理</strong>。当startConsumer方法在 while 循环里调用 createOrderInDb(order) 时，它实际上是在调用 this.createOrderInDb(order)，绕过了AOP代理，所以无人发现@Transactional注解，事务没有被开启。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h4><ul>\n<li><p>注入服务自身，通过代理对象来调用方法。</p>\n</li>\n<li><p>修改<code>OrderConsumerService.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderConsumerService</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// ... 其他注入的属性 ...</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SeckillService seckillService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 注入自己（代理对象）</span></span><br><span class=\"line\">    <span class=\"comment\">// 使用 @Lazy 是为了解决循环依赖的潜在问题</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Lazy</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> OrderConsumerService self;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 应用启动后，开启一个后台线程</span></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startConsumer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> seckillService.getOrderQueue().take();</span><br><span class=\"line\">                    <span class=\"comment\">// 3. 【关键改动】通过 self 代理对象来调用事务方法</span></span><br><span class=\"line\">                    self.createOrderInDb(order);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// ...</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// ...</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个方法保持不变，但现在它能被正确地代理了</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createOrderInDb</span><span class=\"params\">(SeckillOrder order)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... 之前的数据库操作逻辑完全不变 ...</span></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;正在创建订单并扣减MySQL库存: &#123;&#125;&quot;</span>, order);</span><br><span class=\"line\">        orderRepository.save(order);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> productRepository.deductStock(order.getProductId());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;MySQL stock deduction failed for order: &quot;</span> + order);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;数据库订单创建成功&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>@Autowired private OrderConsumerService self; 注入的 self 变量，不是 this 对象，而是 Spring 创建的、包含了事务处理逻辑的代理对象。</p>\n</li>\n<li><p>当调用 self.createOrderInDb(order) 时，请求就从<code>startConsumer</code>发到了AOP代理那里。</p>\n</li>\n<li><p>AOP代理会正常地开启事务，然后再让真实对象去执行数据库操作。这样，@Transactional 就重新恢复了它的作用。</p>\n</li>\n<li><p>结果：数据库信息显示正常，库存正确减少，订单正确建立。</p>\n</li>\n</ul>\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h4><ul>\n<li>Redis是一个开源的、基于内存的、key-value结构的高性能数据库。<ul>\n<li>基于内存：是Redis高性能的根本原因。所有数据都存储在内存中，读写速度极快，远超基于磁盘的数据库。</li>\n<li>key-value：数据存储方式非常简单，像一个巨大的HashMap，通过一个唯一的Key来存取一个Value。</li>\n<li>不仅仅是缓存：除了被用于缓存外，也被广泛运用于数据库、消息队列等。</li>\n</ul>\n</li>\n<li>核心原理（为什么快）<ul>\n<li>纯内存操作：所有的操作都在内存中完成，完全避免了磁盘I&#x2F;O这个最耗时的环节。</li>\n<li>单线程模型：Redis的核心网络模型和命令处理是由一个单线程来完成的。无线程切换开销、无锁竞争、I&#x2F;O多路复用。</li>\n</ul>\n</li>\n<li>Redis的原子性与Lua脚本<ul>\n<li>Redis的单个命令是原子性的，但是多个命令组合在一起，就不是原子性的。</li>\n<li>但Redis允许将一段Lua脚本作为一个整体发送给服务器执行，Redis会保证这个脚本在执行期间不会被任何其他命令打断，从而实现了多个命令的原子性组合。</li>\n</ul>\n</li>\n<li>Redis的持久化机制<ul>\n<li>RDB：在指定的时间间隔内，将内存中的数据快照完整的写入到磁盘上的一个二进制文件中。恢复速度快，文件紧凑。但如果Redis在两次快照之间崩溃，会损失一部分数据。</li>\n<li>AOF：将每一条接受到的写命令，以追加的方式写入到一个日志文件中，恢复时，重新执行一遍文件中的所有写命令。数据的安全性更高（最多只丢失1秒的数据），单文件体积大，恢复速度相对较慢。</li>\n</ul>\n</li>\n<li>Redis的缓存经典问题<ul>\n<li>缓存穿透：查询一个数据库中根本不存在的数据，缓存中自然也没有，导致每次请求都直接打到数据库上，失去了缓存的意义。<ul>\n<li>缓存空对象：如果数据库查询结果为空，依然在Redis中缓存一个特殊的空值，并设置一个较短的过期时间。</li>\n<li>布隆过滤器：在Redis前再加一道屏障，用布隆过滤器快速判断请求的数据是否存在。</li>\n</ul>\n</li>\n<li>缓存击穿：一个热点Key在某个瞬间突然失效，导致海量的并发请求同时涌向这个Key，并全部穿透到数据库，导致数据库瞬时压力过大。<ul>\n<li>互斥锁：当缓存失效时，第一个查询请求获取一个互斥锁，然后去加载数据并回设缓存。其他线程则等待锁释放后，直接从缓存中获取数据。</li>\n<li>热点数据永不过期：对极热点的数据设置逻辑过期，由后台线程异步更新。</li>\n</ul>\n</li>\n<li>缓存雪崩：大量的key在同一时间集中失效，导致瞬时大量的请求都穿透到数据库。<ul>\n<li>随机化过期时间：在基础过期时间上，增加一个随机值，避免集中失效。</li>\n<li>高可用架构：通过Redis集群、限流降级等操作，保证即使缓存出现问题，数据库也不会被完全冲垮。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"突破限制：引入Redis机制\"><a href=\"#突破限制：引入Redis机制\" class=\"headerlink\" title=\"突破限制：引入Redis机制\"></a>突破限制：引入Redis机制</h3><p><strong>当前系统V1.3 已经具备的功能：</strong></p>\n<ul>\n<li>异步处理：用户的点击会立刻得到响应。</li>\n<li>流量控制：保护系统不会因过多线程而崩溃</li>\n<li>原子化SQL：数据库操作精准无误</li>\n<li>内存标记：售罄后能快速拒绝请求。</li>\n</ul>\n<p><strong>无法回避的“物理上限”：</strong></p>\n<ul>\n<li>用户体验的断崖式下跌：服务器可能在第一秒就收到了数万甚至数十万的 HTTP 请求。而应用内置的 Tomcat 服务器线程池（比如200个）会瞬间被打满。后续的所有请求，都会在操作系统的 TCP 连接队列中排队，最终大量超时。<ul>\n<li>99% 的用户刷新页面后，看到的是一个永远在“转圈圈”的加载动画，或是冰冷的 “503 Service Unavailable” 错误。</li>\n</ul>\n</li>\n<li>数据库是最终的性能瓶颈：数据库的磁盘I&#x2F;O、网络带宽、以及自身的处理能力成为了整个系统性能的天花板。<ul>\n<li>数据库通常是多个业务的<strong>共享资源</strong>。秒杀业务对数据库的极限压榨，会导致<strong>整个网站的其他核心功能全部瘫痪</strong>。普通用户无法登录、无法浏览其他商品、无法对购物车里的其他商品下单。<strong>为了一个秒杀活动，导致整个电商平台的交易系统停摆，这是任何公司都无法接受的巨大损失。</strong></li>\n</ul>\n</li>\n<li>应用服务器是“单点故障”：应用运行在一个实例上，如果这个应用因为任何原因，比如JVM崩溃或服务器宕机，挂掉，那么整个秒杀服务就会彻底中断。<ul>\n<li><strong>整个秒杀服务彻底消失</strong>，恢复时间未知。</li>\n</ul>\n</li>\n<li>无法水平扩展：所有基于Java内存的并发控制，在多实例部署时都会失效。<ul>\n<li>暴露了架构的僵化和脆弱</li>\n</ul>\n</li>\n</ul>\n<p><strong>Redis能解决什么问题？</strong></p>\n<ul>\n<li>解决了数据库雪崩和用户体验差的问题<ul>\n<li>把高频的库存读写、用户资格判断，从毫秒级的、基于磁盘的MYSQL，转移到了微秒级的、基于内存的Redis。</li>\n<li>99%的读写流量由Redis抗住，每秒可以处理数万甚至数万次请求。</li>\n<li>数据库只负责收尾工作，只有极少数成功抢到资格的用户，它们的订单信息才会异步的、平稳的写入数据库中。</li>\n</ul>\n</li>\n<li>解决了单点故障和无法水平扩展的问题<ul>\n<li>通过将所有需要共享的状态统一放在Redis中，本身的Spring Boot应用本身变成了“无状态”的。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"环境准备与集成\"><a href=\"#环境准备与集成\" class=\"headerlink\" title=\"环境准备与集成\"></a>环境准备与集成</h4><blockquote>\n<p>在 Spring Boot 项目中成功引入并连接到 Redis</p>\n</blockquote>\n<ol>\n<li>安装并运行Redis</li>\n</ol>\n<ul>\n<li>在电脑上，使用docker在后台启动一个名为seckill-redis的Redis容器，并将其6379端口映射到电脑的6379端口。  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d --name seckill-redis -p 6379:6379 redis</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>添加Maven依赖</li>\n</ol>\n<ul>\n<li>在pom.xml文件中，添加新的依赖  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>保存并让IDE重新加载依赖</li>\n</ul>\n<ol start=\"3\">\n<li>配置application.properties</li>\n</ol>\n<ul>\n<li>添加 Redis 的连接信息  <figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ================== Redis Configuration ==================</span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.host</span>=<span class=\"string\">localhost</span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.port</span>=<span class=\"string\">6379</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"4\">\n<li>验证连接</li>\n</ol>\n<ul>\n<li>可以创建一个简单的测试类来验证应用启动时能否成功连接到Redis  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisConnectionTester</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CommandLineRunner</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> StringRedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> redisTemplate.getConnectionFactory().getConnection().ping();</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;Successfully connected to Redis. PING response: &quot;</span> + result);</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">          System.err.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">          System.err.println(<span class=\"string\">&quot;Failed to connect to Redis: &quot;</span> + e.getMessage());</span><br><span class=\"line\">          System.err.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>启动 Spring Boot 应用。在控制台看到了 Successfully connected to Redis 的信息，表示第一阶段就成功。</li>\n</ul>\n<h4 id=\"数据预热与缓存“读”操作\"><a href=\"#数据预热与缓存“读”操作\" class=\"headerlink\" title=\"数据预热与缓存“读”操作\"></a>数据预热与缓存“读”操作</h4><blockquote>\n<p>将查询库存的流量从 MySQL 转移到 Redis。</p>\n</blockquote>\n<ol>\n<li>创建数据预热Service</li>\n</ol>\n<ul>\n<li>在秒杀开始之前，把数据从MYSQL加载到Redis。用启动时加载器来模拟。</li>\n<li>创建<code>RedisPreheatService.java</code>  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisPreheatService</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CommandLineRunner</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">STOCK_KEY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;seckill:stock:&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">PRODUCT_KEY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;seckill:product:&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">USER_SET_KEY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;seckill:users:&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> ProductRepository productRepository; <span class=\"comment\">// 假设你已注入</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 应用启动后自动执行</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 假设我们秒杀的商品ID是 1</span></span><br><span class=\"line\">      <span class=\"type\">long</span> <span class=\"variable\">productId</span> <span class=\"operator\">=</span> <span class=\"number\">1L</span>;</span><br><span class=\"line\">      <span class=\"type\">Product</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> productRepository.findById(productId).orElse(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (product != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 1. 清理旧数据（为了可重复测试）</span></span><br><span class=\"line\">          redisTemplate.delete(STOCK_KEY + productId);</span><br><span class=\"line\">          redisTemplate.delete(USER_SET_KEY + productId);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// 2. 加载库存到 Redis String</span></span><br><span class=\"line\">          redisTemplate.opsForValue().set(STOCK_KEY + productId, product.getStock());</span><br><span class=\"line\"></span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;Product &quot;</span> + productId + <span class=\"string\">&quot; stock preheated to Redis: &quot;</span> + product.getStock());</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>改造SeckillService的checkStock方法</li>\n</ol>\n<ul>\n<li>直接从Redis读数据  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 SeckillService.java 中</span></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> Integer <span class=\"title function_\">checkStock</span><span class=\"params\">(Long productId)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">stockKey</span> <span class=\"operator\">=</span> RedisPreheatService.STOCK_KEY + productId;</span><br><span class=\"line\">  <span class=\"type\">Object</span> <span class=\"variable\">stockObj</span> <span class=\"operator\">=</span> redisTemplate.opsForValue().get(stockKey);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> stockObj != <span class=\"literal\">null</span> ? Integer.parseInt(stockObj.toString()) : -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"核心逻辑迁移（Redis-Lua脚本）\"><a href=\"#核心逻辑迁移（Redis-Lua脚本）\" class=\"headerlink\" title=\"核心逻辑迁移（Redis + Lua脚本）\"></a>核心逻辑迁移（Redis + Lua脚本）</h4><blockquote>\n<p>将最关键的“判断资格&amp;扣减库存”操作，从Java层的锁+数据库，迁移到Redis的原子化Lua脚本。</p>\n</blockquote>\n<ol>\n<li>创建Lua脚本文件</li>\n</ol>\n<ul>\n<li>在 src&#x2F;main&#x2F;resources&#x2F; 目录下，创建一个新文件夹 scripts。</li>\n<li>在 scripts 文件夹里，创建一个新文件 seckill.lua  <figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- seckill.lua</span></span><br><span class=\"line\"><span class=\"comment\">-- KEYS[1]: 库存的 key (e.g., seckill:stock:1)</span></span><br><span class=\"line\"><span class=\"comment\">-- KEYS[2]: 已购买用户集合的 key (e.g., seckill:users:1)</span></span><br><span class=\"line\"><span class=\"comment\">-- ARGV[1]: 当前请求的用户 ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 1. 判断用户是否重复购买</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> redis.call(<span class=\"string\">&#x27;sismember&#x27;</span>, KEYS[<span class=\"number\">2</span>], ARGV[<span class=\"number\">1</span>]) == <span class=\"number\">1</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">2</span> <span class=\"comment\">-- 2 代表重复购买</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 2. 获取库存</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> stock = <span class=\"built_in\">tonumber</span>(redis.call(<span class=\"string\">&#x27;get&#x27;</span>, KEYS[<span class=\"number\">1</span>]))</span><br><span class=\"line\"><span class=\"keyword\">if</span> stock &lt;= <span class=\"number\">0</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span> <span class=\"comment\">-- 1 代表库存不足</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 3. 扣减库存</span></span><br><span class=\"line\">redis.call(<span class=\"string\">&#x27;decr&#x27;</span>, KEYS[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 4. 记录购买用户</span></span><br><span class=\"line\">redis.call(<span class=\"string\">&#x27;sadd&#x27;</span>, KEYS[<span class=\"number\">2</span>], ARGV[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span> <span class=\"comment\">-- 0 代表秒杀成功</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>配置并加载Lua脚本</li>\n</ol>\n<ul>\n<li>创建一个RedisConfig.java文件。用于管理与Redis相关的Bean。  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 【新增】配置并创建 RedisTemplate Bean</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param</span> connectionFactory Spring Boot 自动配置好的连接工厂</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return</span> RedisTemplate 实例</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> RedisTemplate&lt;String, Object&gt; <span class=\"title function_\">redisTemplate</span><span class=\"params\">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 创建 RedisTemplate 对象</span></span><br><span class=\"line\">      RedisTemplate&lt;String, Object&gt; template = <span class=\"keyword\">new</span> <span class=\"title class_\">RedisTemplate</span>&lt;&gt;();</span><br><span class=\"line\">      <span class=\"comment\">// 设置连接工厂</span></span><br><span class=\"line\">      template.setConnectionFactory(connectionFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 创建 JSON 序列化工具</span></span><br><span class=\"line\">      <span class=\"type\">GenericJackson2JsonRedisSerializer</span> <span class=\"variable\">jsonSerializer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">GenericJackson2JsonRedisSerializer</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 设置 Key 的序列化方式为 String</span></span><br><span class=\"line\">      template.setKeySerializer(<span class=\"keyword\">new</span> <span class=\"title class_\">StringRedisSerializer</span>());</span><br><span class=\"line\">      template.setHashKeySerializer(<span class=\"keyword\">new</span> <span class=\"title class_\">StringRedisSerializer</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 设置 Value 的序列化方式为 JSON</span></span><br><span class=\"line\">      template.setValueSerializer(jsonSerializer);</span><br><span class=\"line\">      template.setHashValueSerializer(jsonSerializer);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 使配置生效</span></span><br><span class=\"line\">      template.afterPropertiesSet();</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">return</span> template;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> DefaultRedisScript&lt;Long&gt; <span class=\"title function_\">seckillScript</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      DefaultRedisScript&lt;Long&gt; redisScript = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;();</span><br><span class=\"line\">      redisScript.setScriptSource(<span class=\"keyword\">new</span> <span class=\"title class_\">ResourceScriptSource</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathResource</span>(<span class=\"string\">&quot;scripts/seckill.lua&quot;</span>)));</span><br><span class=\"line\">      redisScript.setResultType(Long.class);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> redisScript;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"3\">\n<li>重构SeckillService的核心秒杀逻辑<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 SeckillService.java 中</span></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> DefaultRedisScript&lt;Long&gt; seckillScript;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们需要一个内存队列来存放成功秒杀的订单信息</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;SeckillOrder&gt; orderQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;(<span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 改造异步执行的后台任务</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">    List&lt;String&gt; keys = Arrays.asList(</span><br><span class=\"line\">        RedisPreheatService.STOCK_KEY + productId,</span><br><span class=\"line\">        RedisPreheatService.USER_SET_KEY + productId</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 Lua 脚本</span></span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> redisTemplate.execute(seckillScript, keys, userId.toString());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;用户 &#123;&#125; 秒杀成功！&quot;</span>, userId);</span><br><span class=\"line\">        <span class=\"comment\">// 秒杀成功，生成订单信息并放入内存队列</span></span><br><span class=\"line\">        <span class=\"comment\">// 此时订单尚未写入数据库</span></span><br><span class=\"line\">        <span class=\"type\">Product</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> ... <span class=\"comment\">// 可以从缓存或数据库获取商品信息</span></span><br><span class=\"line\">        <span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SeckillOrder</span>();</span><br><span class=\"line\">        order.setProductId(productId);</span><br><span class=\"line\">        order.setUserId(userId);</span><br><span class=\"line\">        order.setOrderPrice(product.getPrice());</span><br><span class=\"line\">        <span class=\"comment\">// 将订单放入队列</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            orderQueue.put(order);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            Thread.currentThread().interrupt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (result == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;用户 &#123;&#125; 秒杀失败：库存不足&quot;</span>, userId);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (result == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;用户 &#123;&#125; 秒杀失败：重复下单&quot;</span>, userId);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;用户 &#123;&#125; 秒杀异常&quot;</span>, userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"异步持久化\"><a href=\"#异步持久化\" class=\"headerlink\" title=\"异步持久化\"></a>异步持久化</h4><blockquote>\n<p>创建订单消费者Service</p>\n</blockquote>\n<ul>\n<li>新建一个OrderConsumeService.java  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderConsumerService</span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// ... 其他注入的属性 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 应用启动后，开启一个后台线程</span></span><br><span class=\"line\">  <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startConsumer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                  <span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> seckillService.getOrderQueue().take();</span><br><span class=\"line\">                  <span class=\"comment\">// 2. 循环体内部现在只调用这个新的、带事务的方法</span></span><br><span class=\"line\">                  createOrderInDb(order);</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                  Thread.currentThread().interrupt();</span><br><span class=\"line\">                  log.error(<span class=\"string\">&quot;订单消费者线程被中断&quot;</span>, e);</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// 捕获所有其他可能的异常，防止线程意外终止</span></span><br><span class=\"line\">                  log.error(<span class=\"string\">&quot;处理订单时发生未知异常&quot;</span>, e);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;).start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 3. 【新增】一个公开的、带事务注解的方法，专门用于数据库操作</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param</span> order 从队列中取出的订单信息</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createOrderInDb</span><span class=\"params\">(SeckillOrder order)</span> &#123;</span><br><span class=\"line\">      log.info(<span class=\"string\">&quot;正在创建订单并扣减MySQL库存: &#123;&#125;&quot;</span>, order);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 将所有数据库操作都放在这个方法里</span></span><br><span class=\"line\">      orderRepository.save(order);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> productRepository.deductStock(order.getProductId());</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 这是一个补偿逻辑，理论上在Redis阶段已经保证了库存充足</span></span><br><span class=\"line\">          <span class=\"comment\">// 但为了数据最终一致性，如果MySQL库存扣减失败，应抛出异常让事务回滚</span></span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;MySQL a&#x27;s stock deduction failed for order: &quot;</span> + order);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      log.info(<span class=\"string\">&quot;数据库订单创建成功&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>在 SeckillService 中为 orderQueue 提供一个 getter 方法。</li>\n</ul>\n<h3 id=\"JMeter压测结果分析与改进\"><a href=\"#JMeter压测结果分析与改进\" class=\"headerlink\" title=\"JMeter压测结果分析与改进\"></a>JMeter压测结果分析与改进</h3><h4 id=\"结果分析\"><a href=\"#结果分析\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h4><ul>\n<li>结果：日志显示：处理订单时发生未知异常；数据库信息显示：订单正常创建，但是库存数没有减少；存在<code>TransactionRequiredException</code>报错。</li>\n<li>分析：<ul>\n<li>订单正常创建：说明 orderRepository.save(order) 这行代码执行成功了，并且它的结果被提交到了数据库。</li>\n<li>库存数没有减少：说明 productRepository.deductStock(…) 这行代码没有成功，或者它的结果被回滚了。</li>\n<li>存在<code>TransactionRequiredException</code>报错：deductStock() 在执行时，没有找到一个正在运行的事务。</li>\n<li>即，orderRepository.save() 在一个事务里成功了（或者在没有事务的情况下自动提交了），而紧接着的 deductStock() 却发现自己不在任何事务里。但是这两个方法在同一个被@Transactional注解的方法里。所以真正的原因应该是，方法上的@Transactional注解没有生效。<strong>因为这个方法是通过this关键字进行的方法自调用，无法触发AOP代理</strong>。当startConsumer方法在 while 循环里调用 createOrderInDb(order) 时，它实际上是在调用 this.createOrderInDb(order)，绕过了AOP代理，所以无人发现@Transactional注解，事务没有被开启。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h4><ul>\n<li><p>注入服务自身，通过代理对象来调用方法。</p>\n</li>\n<li><p>修改<code>OrderConsumerService.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderConsumerService</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// ... 其他注入的属性 ...</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SeckillService seckillService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 注入自己（代理对象）</span></span><br><span class=\"line\">    <span class=\"comment\">// 使用 @Lazy 是为了解决循环依赖的潜在问题</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Lazy</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> OrderConsumerService self;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 应用启动后，开启一个后台线程</span></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startConsumer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> seckillService.getOrderQueue().take();</span><br><span class=\"line\">                    <span class=\"comment\">// 3. 【关键改动】通过 self 代理对象来调用事务方法</span></span><br><span class=\"line\">                    self.createOrderInDb(order);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// ...</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// ...</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个方法保持不变，但现在它能被正确地代理了</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createOrderInDb</span><span class=\"params\">(SeckillOrder order)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... 之前的数据库操作逻辑完全不变 ...</span></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;正在创建订单并扣减MySQL库存: &#123;&#125;&quot;</span>, order);</span><br><span class=\"line\">        orderRepository.save(order);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> productRepository.deductStock(order.getProductId());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;MySQL stock deduction failed for order: &quot;</span> + order);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;数据库订单创建成功&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>@Autowired private OrderConsumerService self; 注入的 self 变量，不是 this 对象，而是 Spring 创建的、包含了事务处理逻辑的代理对象。</p>\n</li>\n<li><p>当调用 self.createOrderInDb(order) 时，请求就从<code>startConsumer</code>发到了AOP代理那里。</p>\n</li>\n<li><p>AOP代理会正常地开启事务，然后再让真实对象去执行数据库操作。这样，@Transactional 就重新恢复了它的作用。</p>\n</li>\n<li><p>结果：数据库信息显示正常，库存正确减少，订单正确建立。</p>\n</li>\n</ul>\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h4><ul>\n<li>Redis是一个开源的、基于内存的、key-value结构的高性能数据库。<ul>\n<li>基于内存：是Redis高性能的根本原因。所有数据都存储在内存中，读写速度极快，远超基于磁盘的数据库。</li>\n<li>key-value：数据存储方式非常简单，像一个巨大的HashMap，通过一个唯一的Key来存取一个Value。</li>\n<li>不仅仅是缓存：除了被用于缓存外，也被广泛运用于数据库、消息队列等。</li>\n</ul>\n</li>\n<li>核心原理（为什么快）<ul>\n<li>纯内存操作：所有的操作都在内存中完成，完全避免了磁盘I&#x2F;O这个最耗时的环节。</li>\n<li>单线程模型：Redis的核心网络模型和命令处理是由一个单线程来完成的。无线程切换开销、无锁竞争、I&#x2F;O多路复用。</li>\n</ul>\n</li>\n<li>Redis的原子性与Lua脚本<ul>\n<li>Redis的单个命令是原子性的，但是多个命令组合在一起，就不是原子性的。</li>\n<li>但Redis允许将一段Lua脚本作为一个整体发送给服务器执行，Redis会保证这个脚本在执行期间不会被任何其他命令打断，从而实现了多个命令的原子性组合。</li>\n</ul>\n</li>\n<li>Redis的持久化机制<ul>\n<li>RDB：在指定的时间间隔内，将内存中的数据快照完整的写入到磁盘上的一个二进制文件中。恢复速度快，文件紧凑。但如果Redis在两次快照之间崩溃，会损失一部分数据。</li>\n<li>AOF：将每一条接受到的写命令，以追加的方式写入到一个日志文件中，恢复时，重新执行一遍文件中的所有写命令。数据的安全性更高（最多只丢失1秒的数据），单文件体积大，恢复速度相对较慢。</li>\n</ul>\n</li>\n<li>Redis的缓存经典问题<ul>\n<li>缓存穿透：查询一个数据库中根本不存在的数据，缓存中自然也没有，导致每次请求都直接打到数据库上，失去了缓存的意义。<ul>\n<li>缓存空对象：如果数据库查询结果为空，依然在Redis中缓存一个特殊的空值，并设置一个较短的过期时间。</li>\n<li>布隆过滤器：在Redis前再加一道屏障，用布隆过滤器快速判断请求的数据是否存在。</li>\n</ul>\n</li>\n<li>缓存击穿：一个热点Key在某个瞬间突然失效，导致海量的并发请求同时涌向这个Key，并全部穿透到数据库，导致数据库瞬时压力过大。<ul>\n<li>互斥锁：当缓存失效时，第一个查询请求获取一个互斥锁，然后去加载数据并回设缓存。其他线程则等待锁释放后，直接从缓存中获取数据。</li>\n<li>热点数据永不过期：对极热点的数据设置逻辑过期，由后台线程异步更新。</li>\n</ul>\n</li>\n<li>缓存雪崩：大量的key在同一时间集中失效，导致瞬时大量的请求都穿透到数据库。<ul>\n<li>随机化过期时间：在基础过期时间上，增加一个随机值，避免集中失效。</li>\n<li>高可用架构：通过Redis集群、限流降级等操作，保证即使缓存出现问题，数据库也不会被完全冲垮。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"}],"Post":[{"title":"1-秒杀项目1.0-丢失更新和锁失效","poster":{"topic":"标题上方的小字","headline":"大标题","caption":"标题下方的小字","color":"标题颜色"},"date":"2025-09-25T01:11:57.000Z","description":"重新起航版","cover":null,"banner":null,"sticky":null,"mermaid":null,"katex":null,"mathjax":null,"topic":null,"author":null,"references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n\n### 一、项目概述\n  - 项目名称：高并发-秒杀系统（1.0 单体应用原型）\n  - 项目目标：从零开始设计并实现一个功能完备的秒-杀业务原型，旨在深入理解高并发场景下常见的技术挑战，如数据一致性（超卖、重复下单）、性能瓶颈等，并通过多种技术手段进行分析和优化。\n  - 技术栈：\n    - 后端框架：Spring Boot\n    - 数据持久层：Spring Data JPA,Hibernate\n    - 数据库：MYSQL\n    - 构建工具：Maven\n    - 测试工具：JMeter\n\n### 二、项目搭建\n  #### 1. 环境搭建和初始化\n  - 使用 Spring Initializr 快速搭建了项目骨架，并集成 Spring Web、Spring Data JPA、MySQL Driver 等核心依赖。\n    > Spring Web:是构建Web应用程序的核心模块。内嵌Web服务器，提供Spring MVC框架，用于HTTP报文处理能力。负责监听网络接口，接受所有外来的HTTP请求，然后根据请求的URL和方法，精准的转接给后台相应的Controller去处理。\n    > Spring Data JPA：是一个用来极大简化数据库访问的框架。可以自动化SQL，进行对象-关系映射（ORM），并进行简化的自定义查询。\n  - 在 application.properties 中完成了数据库连接池的基础配置。\n  #### 2. 核心业务\n  - 设计核心数据表\n    - 商品表\n    ```SQL\n    CREATE TABLE `product` (\n    `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '商品ID',\n    `name` VARCHAR(100) NOT NULL COMMENT '商品名称',\n    `title` VARCHAR(255) NOT NULL COMMENT '商品标题',\n    `image` VARCHAR(255) DEFAULT '' COMMENT '商品图片URL',\n    `price` DECIMAL(10, 2) NOT NULL COMMENT '秒杀价格',\n    `stock` INT NOT NULL COMMENT '库存数量',\n    `start_time` DATETIME NOT NULL COMMENT '秒杀开始时间',\n    `end_time` DATETIME NOT NULL COMMENT '秒杀结束时间',\n    PRIMARY KEY (`id`)\n    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n    ```\n    - 订单表\n    在订单表的设计中加入了 (user_id, product_id)的唯一索引，即每个用户只能下一单。\n    ```SQL\n    CREATE TABLE `seckill_order` (\n    `id` BIGINT NOT NULL AUTO_INCREMENT,\n    `user_id` BIGINT NOT NULL COMMENT '用户ID',\n    `product_id` BIGINT NOT NULL COMMENT '商品ID',\n    `order_price` DECIMAL(10, 2) NOT NULL COMMENT '订单成交价格',\n    `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    PRIMARY KEY (`id`),\n    UNIQUE KEY `idx_user_product` (`user_id`, `product_id`) COMMENT '唯一索引，防止同一用户重复秒杀同一商品'\n    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n     ```\n\n#### 3. 基础功能实现\n- 采用标准的MVC分层架构，创建Controller, Service, Repository 层。\n  > Controller：作为应用的入口，直接处理外部的HTTP请求。\n  > Service：实现应用的核心业务逻辑。\n  > DAO：负责与数据库进行直接交互，完成数据的持久化操作。\n  > Model/Entity：数据的载体，定义了应用中的核心领域对象。\n\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251103013.png 请求过程 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251103013.png%}\n\n- 实现秒杀接口的核心业务逻辑。\n\n```Java\n@Transactional\npublic String processSeckill(Long productId, Long userId) {\n// 1. 从数据库读取 Product 对象到内存\nOptional<Product> productOpt = productRepository.findById(productId);\nProduct product = productOpt.get(); // 假设此时读到的 stock 是 100\n\n// ... 其他检查 ...\n\n// 2. 在内存中计算新库存\nproduct.setStock(product.getStock() - 1); // 内存中的 stock 变为 99\n\n// 3. 将内存中的 Product 对象保存回数据库\nproductRepository.save(product); \n\n// 4. 创建订单\nSeckillOrder order = new SeckillOrder();\n// ...\norderRepository.save(order);\n\nreturn \"秒杀成功！\";\n}\n```\n- 在初始版本中不加入任何的并发控制，后续会通过压力测试来暴露和分析最原始的并发问题。\n\n### 三、并发问题的分析与演进\n  #### 1. 库存设置与JMeter设置\n  - stock设置为100\n  - JMeter\n    - 线程数：200\n    - 1秒内同时发出200个并发请求\n    - 计数器自增UserId\n  #### 2. 实验结果\n  - 订单数增加了200个但是库存数只减少了20个\n    {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251245658.png 订单数 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251245658.png%}\n    {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251246389.png 库存数 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251246389.png%}\n\n  - 分析原因：事务和内存状态————Spring的@Transaction注解和JPA的工作机制\n    - 一级缓存：当第一个请求通过findById加载了ID为1的商品后，这个product对象会被放入当前事务的一级缓存中。\n    - 事务提交时才真正更新：productRepository.save(product)这个操作，并不是立即向数据库发送UPDATE语句，而要等到整个processSeckill方法执行完毕、事务准备提交时，才会生成并发送给数据库。\n  - 丢失的更新（stock=80）：前十个线程有可能都加载到了还没有提交的product，即此时读到的stock依然是100，后面的九次更新覆盖了第一次更新，所以最终结果和只更新一次是完全一样的（stock变成了99）。每次都有一批线程在竞争，但最后只有一个线程的更新“活”到了最后，导致库存最终只减少了大约20次。\n  - 订单的正常建立（新增order数=200）：orderRepository.save(order)这个操作，因为每个订单的主键都是自增的，并且（user_id,product_id）的组合也是唯一的，所以每一次订单的插入都能成功。\n  #### 3. 改进\n  ##### 第一次尝试-在 processSeckill 方法上加 synchronized 锁\n    \n  - 预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。\n\n  ```Java\n    @Transactional\n    public synchronized  String processSeckill(Long productId, Long userId) {\n    // 1. 从数据库读取 Product 对象到内存\n    Optional<Product> productOpt = productRepository.findById(productId);\n    Product product = productOpt.get(); // 假设此时读到的 stock 是 100\n\n    // ... 其他检查 ...\n\n    // 2. 在内存中计算新库存\n    product.setStock(product.getStock() - 1); // 内存中的 stock 变为 99\n\n    // 3. 将内存中的 Product 对象保存回数据库\n    productRepository.save(product); \n\n    // 4. 创建订单\n    SeckillOrder order = new SeckillOrder();\n    // ...\n    orderRepository.save(order);\n\n    return \"秒杀成功！\";\n    }\n  ```\n  - 结果：数据依然错误，订单数为200，库存数为79,而吞吐量和平均响应时间没有发生明显变化。\n  - 分析：@Transaction 与 synchronized 的冲突\n    - 当给一个方法加上@Transaction注解时，Spring为了能够控制事务的开启、提交和回滚，并不会让你直接调用这个方法，相反，Spring会在运行时创建一个该类的代理对象proxy。\n    - 事务先生效：即代理对象的同名方法会被触发，代理对象会先开启一个事务\n    - synchronized被绕过：它是Java原生关键字，作用于对象实例的锁，但Spring的代理机制在调用目标方法时，可能会导致锁机制失效，因为代理方法本身没有synchronized，调用父类（本身SeckillService）的方法时，锁的上下文可能已经丢失或不准确。\n  即，Spring的AOP代理与Java原生的锁关键字之间存在冲突，代理绕过了锁，导致synchronized锁机制未生效。\n\n  ##### 第二次尝试-在事务内使用ReentrantLock\n  - 预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。\n  ```Java\n    @Transactional\n    public String processSeckill(Long productId, Long userId) {  // 1. 事务由代理对象在这里开启\n        // 2. 在方法开始时手动加锁\n        lock.lock();\n        try {\n            // 所有业务逻辑都放在 try 块中\n            // 其他检查\n\n            product.setStock(product.getStock() - 1);\n            productRepository.save(product);\n\n            SeckillOrder order = new SeckillOrder();\n            // ...\n            orderRepository.save(order);\n\n            return \"秒杀成功！订单创建中...\";\n        } finally {\n            // 3. 【至关重要】在 finally 块中解锁，确保即使发生异常也能释放锁\n            lock.unlock();\n        }\n    }      // 4. 事务由代理对象在这里提交\n  ```\n  - 显示控制：lock.lock()是代码逻辑的一部分，在代理调用了实际方法之后，业务逻辑执行之前被调用。任何线程进入这个方法后，都必须先获取到这个锁才能继续执行。\n  - 安全释放：使用try...finally结构，确保无论业务逻辑是否成功，锁最终都会被释放，避免了“死锁”的风险。\n\n  - 结果：数据依然错误，订单数为200，库存数为79,而吞吐量和平均响应时间没有发生明显变化。\n  - 分析：锁的范围 VS 事务的范围\n    - 锁释放在前，事务提交在后，所以当线程A解锁后，UPDATE语句还没有提交进入数据库，而此时线程B立即取锁进入了方法，此时B读取到的库存数还是旧值。重演丢失更新问题。\n\n  ##### 第三次尝试-ReentrantLock + 手动事务\n  - 预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。\n\n  - 解决方案：将事务控制移入锁内\n    - 放弃@Transaction注解，因为这个注解无法精细控制提交时机，改用最经典、最原始的手动事务管理。\n    - 使用PlatformTransactionManager 来手动控制事务的开始、提交和回滚。将整个生命周期包裹在锁内。\n  ```Java\n    @Autowired\n    private PlatformTransactionManager transactionManager;\n\n    private final Lock lock = new ReentrantLock();\n\n    public String processSeckill(Long productId, Long userId) {\n        // 1. 上锁\n        lock.lock();\n        \n        DefaultTransactionDefinition def = new DefaultTransactionDefinition();\n        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n        // 2. 开启事务\n        TransactionStatus status = transactionManager.getTransaction(def);\n\n        try {\n            // ...所有业务逻辑，和之前一样\n            // 3. 【关键】在锁释放前，手动提交事务\n            transactionManager.commit(status);\n\n            return \"秒杀成功！订单创建中...\";\n        } catch (Exception e) {\n            //  如果发生任何异常，手动回滚事务\n            transactionManager.rollback(status);\n            // 将异常信息返回或记录日志\n            return e.getMessage(); \n        } finally {\n            // 4. 最后，释放锁\n            lock.unlock();\n        }\n    }\n  ```\n  - 结果:数据正确，库存为0，订单数为100，吞吐量没有下降，甚至比没有并发控制的1.0 版本还要高。\n  - 分析: 在高并发场景下，无序的并发混乱，有时远比有序的串行执行要慢。下表为初始版本和三次尝试版本的压测数据。\n\n| Label                                  | 样本 | 平均值 | 中位数 | 90% 百分位 | 95% 百分位 | 99% 百分位 | 最小值 | 最大值 | 异常 % | 吞吐量 | 接收 KB/sec | 发送 KB/sec |\n| -------------------------------------- | ---- | ------ | ------ | ---------- | ---------- | ---------- | ------ | ------ | ------ | ------ | ----------- | ----------- |\n| 1.0秒杀系统                            | 200  | 740    | 810    | 1044       | 1078       | 1083       | 254    | 1084   | 0.00%  | 95.92  | 18.27       | 20.51       |\n| 2.0秒杀系统_添加关键字synchronized     | 200  | 578    | 598    | 744        | 763        | 767        | 79     | 831    | 0.00%  | 113.38 | 21.59       | 24.24       |\n| 2.0秒杀系统_手动添加锁ReentrantLock    | 200  | 638    | 663    | 819        | 837        | 879        | 237    | 891    | 0.00%  | 105.76 | 20.14       | 22.62       |\n| 2.0秒杀系统_不使用@Transaction手动加锁 | 200  | 905    | 1024   | 1148       | 1160       | 1175       | 203    | 1178   | 0.00%  | 100.45 | 18.25       | 21.48       |\n  \n  - 无锁版虽然看似并行，但造成了数据库层面大量的行锁竞争、唯一键冲突错误、事务回滚，这些“无效”的数据库操作成为了真正的性能瓶颈。而加锁后的版本，虽然在应用层是串行的，但它保护了数据库，向数据库发送的是一连串干净、有效的请求，避免了数据库的内部冲突和错误处理开销，因此整体系统的有效吞吐量反而更高。\n\n### 学学八股\n  \n#### @Transaction注解 & 一个请求的生命周期\n- Controller接受请求，调用Service方法，但此时Service引用的是Spring的代理对象，而不是原始实例。代理对象的方法被触发，检查到方法上有@Transaction注解，代理对象向事务管理器（platformTransactionManager）请求开启一个新的事务。从数据库连接池中获取一个数据库连接，向MySQL服务器发送指令。此时一个数据库事务的“上下文”已经建立，但还没有任何实际的业务SQL被执行。在开启事务后，代理对象才会调用原始实例的方法，开始执行业务逻辑。但需要注意的是，这个阶段中是没有发生任何数据库操作的，只是告诉JPA的持久化上下文，标记了该对象，后续需要“留意”。\n- 所有代码都执行完毕后，到达return语句，准备将结果返回。此时代理对象接收到真实方法的返回值，因为没有捕获到任何异常，代理对象判断这次业务执行是成功的，通知事务管理器可以提交事务了。事务管理器执行数据库同步，在真正COMMIT之前，JPA会执行一次Flush，生成SQL语句，发送到MYSQL服务器并执行，直到COMMIT被成功执行了，这次更新才被永久地鞋屋数据库磁盘。\n- 代理对象将你方法的返回值传递给Controller，Controller再将其封装成HTTP响应返回给用户。\n\n\n#### 锁-初步\n1. Synchronized：Keyword、JVM内置的同步原语，简单、隐式的加锁和解锁机制。\n  - 使用方法：修饰实例方法、修饰静态方法、修饰代码块。\n  - 实现依赖于每个Java对象头部的Mark Word和JVM内部的Monitor对象监视器（当线程尝试获取锁时，JVM会执行Monitorenter字节码指令，尝试获得对象Monitor所有权。释放锁时即执行monitorexit）。\n  - 锁升级机制：偏向锁--->轻量级锁(当有第二个线程竞争时升级，竞争的线程通过自旋和CAS来尝试获取锁，不进入阻塞状态)--->重量级锁（竞争加剧，自旋失败，升级，未获取到锁的线程会被阻塞，由内核进行调度，性能开销最大）\n\n2. ReentrantLock：是JUC工具包的核心成员，显式加锁和解锁机制。\n  - 使用方法：标准的使用范式\n  ```Java\n    // 1. 在类中声明一个 Lock 实例\n    private final ReentrantLock lock = new ReentrantLock();\n         \n    public void someMethod() {\n    // 2. 在 try...finally 结构中进行加锁和解锁\n    lock.lock(); // 获取锁\n    try {\n    // 3. 保护的同步代码\n    } finally {\n    // 4. 必须在 finally 块中释放锁\n    lock.unlock();\n    }\n    }\n  ```\n  - 实现依赖于JUC的核心框架AQS，所有获取锁失败的线程，会被封装成节点放入一个CLH虚拟双向队列中进行排队等待。当锁被释放时，会从队列头部唤醒下一个等待的线程。整个过程都在用户态完成，避免了频繁的内核态切换。\n    > AQS 内部通过一个 `volatile` 的 `int` 类型的 `state` 变量来表示同步状态（0表示未锁定，>0表示已锁定），并使用 **CAS** 操作来原子性地修改这个 `state` 值。\n  - 功能丰富：等待可中断（等待锁的线程可被中断）、可实现公平锁（按线程请求的顺序获取锁）、可实现非公平锁（允许插队、吞吐量更高）、可尝试获取锁（可在指定时间内尝试获取锁，失败则返回）、可绑定多个条件（可分组唤醒等待的线程，实现更精细的线程通信）\n    \n选择问题：在绝大多数情况下，当并发冲突不激烈、同步逻辑简单时，优先选择Synchronized关键字，在特定的场景下，比如需要使用Synchronized不具备的高级功能时，或者是在我的秒杀项目中，需要将事务提交的完整过程都包裹在锁内，即手动控制锁时。","source":"_posts/1-秒杀项目1.0-丢失更新和锁失效.md","raw":"---\ntitle: 1-秒杀项目1.0-丢失更新和锁失效\ntags: [Spring Boot,高并发,JUC]\ncategories: [项目实战]\nposter:\n  topic: 标题上方的小字\n  headline: 大标题\n  caption: 标题下方的小字\n  color: 标题颜色\ndate: 2025-09-25 09:11:57\ndescription: 重新起航版\ncover:\nbanner:\nsticky:\nmermaid:\nkatex:\nmathjax:\ntopic:\nauthor:\nreferences:\ncomments:\nindexing:\nbreadcrumb:\nleftbar:\nrightbar:\nh1:\ntype: tech\n---\n\n\n### 一、项目概述\n  - 项目名称：高并发-秒杀系统（1.0 单体应用原型）\n  - 项目目标：从零开始设计并实现一个功能完备的秒-杀业务原型，旨在深入理解高并发场景下常见的技术挑战，如数据一致性（超卖、重复下单）、性能瓶颈等，并通过多种技术手段进行分析和优化。\n  - 技术栈：\n    - 后端框架：Spring Boot\n    - 数据持久层：Spring Data JPA,Hibernate\n    - 数据库：MYSQL\n    - 构建工具：Maven\n    - 测试工具：JMeter\n\n### 二、项目搭建\n  #### 1. 环境搭建和初始化\n  - 使用 Spring Initializr 快速搭建了项目骨架，并集成 Spring Web、Spring Data JPA、MySQL Driver 等核心依赖。\n    > Spring Web:是构建Web应用程序的核心模块。内嵌Web服务器，提供Spring MVC框架，用于HTTP报文处理能力。负责监听网络接口，接受所有外来的HTTP请求，然后根据请求的URL和方法，精准的转接给后台相应的Controller去处理。\n    > Spring Data JPA：是一个用来极大简化数据库访问的框架。可以自动化SQL，进行对象-关系映射（ORM），并进行简化的自定义查询。\n  - 在 application.properties 中完成了数据库连接池的基础配置。\n  #### 2. 核心业务\n  - 设计核心数据表\n    - 商品表\n    ```SQL\n    CREATE TABLE `product` (\n    `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '商品ID',\n    `name` VARCHAR(100) NOT NULL COMMENT '商品名称',\n    `title` VARCHAR(255) NOT NULL COMMENT '商品标题',\n    `image` VARCHAR(255) DEFAULT '' COMMENT '商品图片URL',\n    `price` DECIMAL(10, 2) NOT NULL COMMENT '秒杀价格',\n    `stock` INT NOT NULL COMMENT '库存数量',\n    `start_time` DATETIME NOT NULL COMMENT '秒杀开始时间',\n    `end_time` DATETIME NOT NULL COMMENT '秒杀结束时间',\n    PRIMARY KEY (`id`)\n    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n    ```\n    - 订单表\n    在订单表的设计中加入了 (user_id, product_id)的唯一索引，即每个用户只能下一单。\n    ```SQL\n    CREATE TABLE `seckill_order` (\n    `id` BIGINT NOT NULL AUTO_INCREMENT,\n    `user_id` BIGINT NOT NULL COMMENT '用户ID',\n    `product_id` BIGINT NOT NULL COMMENT '商品ID',\n    `order_price` DECIMAL(10, 2) NOT NULL COMMENT '订单成交价格',\n    `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    PRIMARY KEY (`id`),\n    UNIQUE KEY `idx_user_product` (`user_id`, `product_id`) COMMENT '唯一索引，防止同一用户重复秒杀同一商品'\n    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n     ```\n\n#### 3. 基础功能实现\n- 采用标准的MVC分层架构，创建Controller, Service, Repository 层。\n  > Controller：作为应用的入口，直接处理外部的HTTP请求。\n  > Service：实现应用的核心业务逻辑。\n  > DAO：负责与数据库进行直接交互，完成数据的持久化操作。\n  > Model/Entity：数据的载体，定义了应用中的核心领域对象。\n\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251103013.png 请求过程 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251103013.png%}\n\n- 实现秒杀接口的核心业务逻辑。\n\n```Java\n@Transactional\npublic String processSeckill(Long productId, Long userId) {\n// 1. 从数据库读取 Product 对象到内存\nOptional<Product> productOpt = productRepository.findById(productId);\nProduct product = productOpt.get(); // 假设此时读到的 stock 是 100\n\n// ... 其他检查 ...\n\n// 2. 在内存中计算新库存\nproduct.setStock(product.getStock() - 1); // 内存中的 stock 变为 99\n\n// 3. 将内存中的 Product 对象保存回数据库\nproductRepository.save(product); \n\n// 4. 创建订单\nSeckillOrder order = new SeckillOrder();\n// ...\norderRepository.save(order);\n\nreturn \"秒杀成功！\";\n}\n```\n- 在初始版本中不加入任何的并发控制，后续会通过压力测试来暴露和分析最原始的并发问题。\n\n### 三、并发问题的分析与演进\n  #### 1. 库存设置与JMeter设置\n  - stock设置为100\n  - JMeter\n    - 线程数：200\n    - 1秒内同时发出200个并发请求\n    - 计数器自增UserId\n  #### 2. 实验结果\n  - 订单数增加了200个但是库存数只减少了20个\n    {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251245658.png 订单数 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251245658.png%}\n    {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251246389.png 库存数 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251246389.png%}\n\n  - 分析原因：事务和内存状态————Spring的@Transaction注解和JPA的工作机制\n    - 一级缓存：当第一个请求通过findById加载了ID为1的商品后，这个product对象会被放入当前事务的一级缓存中。\n    - 事务提交时才真正更新：productRepository.save(product)这个操作，并不是立即向数据库发送UPDATE语句，而要等到整个processSeckill方法执行完毕、事务准备提交时，才会生成并发送给数据库。\n  - 丢失的更新（stock=80）：前十个线程有可能都加载到了还没有提交的product，即此时读到的stock依然是100，后面的九次更新覆盖了第一次更新，所以最终结果和只更新一次是完全一样的（stock变成了99）。每次都有一批线程在竞争，但最后只有一个线程的更新“活”到了最后，导致库存最终只减少了大约20次。\n  - 订单的正常建立（新增order数=200）：orderRepository.save(order)这个操作，因为每个订单的主键都是自增的，并且（user_id,product_id）的组合也是唯一的，所以每一次订单的插入都能成功。\n  #### 3. 改进\n  ##### 第一次尝试-在 processSeckill 方法上加 synchronized 锁\n    \n  - 预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。\n\n  ```Java\n    @Transactional\n    public synchronized  String processSeckill(Long productId, Long userId) {\n    // 1. 从数据库读取 Product 对象到内存\n    Optional<Product> productOpt = productRepository.findById(productId);\n    Product product = productOpt.get(); // 假设此时读到的 stock 是 100\n\n    // ... 其他检查 ...\n\n    // 2. 在内存中计算新库存\n    product.setStock(product.getStock() - 1); // 内存中的 stock 变为 99\n\n    // 3. 将内存中的 Product 对象保存回数据库\n    productRepository.save(product); \n\n    // 4. 创建订单\n    SeckillOrder order = new SeckillOrder();\n    // ...\n    orderRepository.save(order);\n\n    return \"秒杀成功！\";\n    }\n  ```\n  - 结果：数据依然错误，订单数为200，库存数为79,而吞吐量和平均响应时间没有发生明显变化。\n  - 分析：@Transaction 与 synchronized 的冲突\n    - 当给一个方法加上@Transaction注解时，Spring为了能够控制事务的开启、提交和回滚，并不会让你直接调用这个方法，相反，Spring会在运行时创建一个该类的代理对象proxy。\n    - 事务先生效：即代理对象的同名方法会被触发，代理对象会先开启一个事务\n    - synchronized被绕过：它是Java原生关键字，作用于对象实例的锁，但Spring的代理机制在调用目标方法时，可能会导致锁机制失效，因为代理方法本身没有synchronized，调用父类（本身SeckillService）的方法时，锁的上下文可能已经丢失或不准确。\n  即，Spring的AOP代理与Java原生的锁关键字之间存在冲突，代理绕过了锁，导致synchronized锁机制未生效。\n\n  ##### 第二次尝试-在事务内使用ReentrantLock\n  - 预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。\n  ```Java\n    @Transactional\n    public String processSeckill(Long productId, Long userId) {  // 1. 事务由代理对象在这里开启\n        // 2. 在方法开始时手动加锁\n        lock.lock();\n        try {\n            // 所有业务逻辑都放在 try 块中\n            // 其他检查\n\n            product.setStock(product.getStock() - 1);\n            productRepository.save(product);\n\n            SeckillOrder order = new SeckillOrder();\n            // ...\n            orderRepository.save(order);\n\n            return \"秒杀成功！订单创建中...\";\n        } finally {\n            // 3. 【至关重要】在 finally 块中解锁，确保即使发生异常也能释放锁\n            lock.unlock();\n        }\n    }      // 4. 事务由代理对象在这里提交\n  ```\n  - 显示控制：lock.lock()是代码逻辑的一部分，在代理调用了实际方法之后，业务逻辑执行之前被调用。任何线程进入这个方法后，都必须先获取到这个锁才能继续执行。\n  - 安全释放：使用try...finally结构，确保无论业务逻辑是否成功，锁最终都会被释放，避免了“死锁”的风险。\n\n  - 结果：数据依然错误，订单数为200，库存数为79,而吞吐量和平均响应时间没有发生明显变化。\n  - 分析：锁的范围 VS 事务的范围\n    - 锁释放在前，事务提交在后，所以当线程A解锁后，UPDATE语句还没有提交进入数据库，而此时线程B立即取锁进入了方法，此时B读取到的库存数还是旧值。重演丢失更新问题。\n\n  ##### 第三次尝试-ReentrantLock + 手动事务\n  - 预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。\n\n  - 解决方案：将事务控制移入锁内\n    - 放弃@Transaction注解，因为这个注解无法精细控制提交时机，改用最经典、最原始的手动事务管理。\n    - 使用PlatformTransactionManager 来手动控制事务的开始、提交和回滚。将整个生命周期包裹在锁内。\n  ```Java\n    @Autowired\n    private PlatformTransactionManager transactionManager;\n\n    private final Lock lock = new ReentrantLock();\n\n    public String processSeckill(Long productId, Long userId) {\n        // 1. 上锁\n        lock.lock();\n        \n        DefaultTransactionDefinition def = new DefaultTransactionDefinition();\n        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n        // 2. 开启事务\n        TransactionStatus status = transactionManager.getTransaction(def);\n\n        try {\n            // ...所有业务逻辑，和之前一样\n            // 3. 【关键】在锁释放前，手动提交事务\n            transactionManager.commit(status);\n\n            return \"秒杀成功！订单创建中...\";\n        } catch (Exception e) {\n            //  如果发生任何异常，手动回滚事务\n            transactionManager.rollback(status);\n            // 将异常信息返回或记录日志\n            return e.getMessage(); \n        } finally {\n            // 4. 最后，释放锁\n            lock.unlock();\n        }\n    }\n  ```\n  - 结果:数据正确，库存为0，订单数为100，吞吐量没有下降，甚至比没有并发控制的1.0 版本还要高。\n  - 分析: 在高并发场景下，无序的并发混乱，有时远比有序的串行执行要慢。下表为初始版本和三次尝试版本的压测数据。\n\n| Label                                  | 样本 | 平均值 | 中位数 | 90% 百分位 | 95% 百分位 | 99% 百分位 | 最小值 | 最大值 | 异常 % | 吞吐量 | 接收 KB/sec | 发送 KB/sec |\n| -------------------------------------- | ---- | ------ | ------ | ---------- | ---------- | ---------- | ------ | ------ | ------ | ------ | ----------- | ----------- |\n| 1.0秒杀系统                            | 200  | 740    | 810    | 1044       | 1078       | 1083       | 254    | 1084   | 0.00%  | 95.92  | 18.27       | 20.51       |\n| 2.0秒杀系统_添加关键字synchronized     | 200  | 578    | 598    | 744        | 763        | 767        | 79     | 831    | 0.00%  | 113.38 | 21.59       | 24.24       |\n| 2.0秒杀系统_手动添加锁ReentrantLock    | 200  | 638    | 663    | 819        | 837        | 879        | 237    | 891    | 0.00%  | 105.76 | 20.14       | 22.62       |\n| 2.0秒杀系统_不使用@Transaction手动加锁 | 200  | 905    | 1024   | 1148       | 1160       | 1175       | 203    | 1178   | 0.00%  | 100.45 | 18.25       | 21.48       |\n  \n  - 无锁版虽然看似并行，但造成了数据库层面大量的行锁竞争、唯一键冲突错误、事务回滚，这些“无效”的数据库操作成为了真正的性能瓶颈。而加锁后的版本，虽然在应用层是串行的，但它保护了数据库，向数据库发送的是一连串干净、有效的请求，避免了数据库的内部冲突和错误处理开销，因此整体系统的有效吞吐量反而更高。\n\n### 学学八股\n  \n#### @Transaction注解 & 一个请求的生命周期\n- Controller接受请求，调用Service方法，但此时Service引用的是Spring的代理对象，而不是原始实例。代理对象的方法被触发，检查到方法上有@Transaction注解，代理对象向事务管理器（platformTransactionManager）请求开启一个新的事务。从数据库连接池中获取一个数据库连接，向MySQL服务器发送指令。此时一个数据库事务的“上下文”已经建立，但还没有任何实际的业务SQL被执行。在开启事务后，代理对象才会调用原始实例的方法，开始执行业务逻辑。但需要注意的是，这个阶段中是没有发生任何数据库操作的，只是告诉JPA的持久化上下文，标记了该对象，后续需要“留意”。\n- 所有代码都执行完毕后，到达return语句，准备将结果返回。此时代理对象接收到真实方法的返回值，因为没有捕获到任何异常，代理对象判断这次业务执行是成功的，通知事务管理器可以提交事务了。事务管理器执行数据库同步，在真正COMMIT之前，JPA会执行一次Flush，生成SQL语句，发送到MYSQL服务器并执行，直到COMMIT被成功执行了，这次更新才被永久地鞋屋数据库磁盘。\n- 代理对象将你方法的返回值传递给Controller，Controller再将其封装成HTTP响应返回给用户。\n\n\n#### 锁-初步\n1. Synchronized：Keyword、JVM内置的同步原语，简单、隐式的加锁和解锁机制。\n  - 使用方法：修饰实例方法、修饰静态方法、修饰代码块。\n  - 实现依赖于每个Java对象头部的Mark Word和JVM内部的Monitor对象监视器（当线程尝试获取锁时，JVM会执行Monitorenter字节码指令，尝试获得对象Monitor所有权。释放锁时即执行monitorexit）。\n  - 锁升级机制：偏向锁--->轻量级锁(当有第二个线程竞争时升级，竞争的线程通过自旋和CAS来尝试获取锁，不进入阻塞状态)--->重量级锁（竞争加剧，自旋失败，升级，未获取到锁的线程会被阻塞，由内核进行调度，性能开销最大）\n\n2. ReentrantLock：是JUC工具包的核心成员，显式加锁和解锁机制。\n  - 使用方法：标准的使用范式\n  ```Java\n    // 1. 在类中声明一个 Lock 实例\n    private final ReentrantLock lock = new ReentrantLock();\n         \n    public void someMethod() {\n    // 2. 在 try...finally 结构中进行加锁和解锁\n    lock.lock(); // 获取锁\n    try {\n    // 3. 保护的同步代码\n    } finally {\n    // 4. 必须在 finally 块中释放锁\n    lock.unlock();\n    }\n    }\n  ```\n  - 实现依赖于JUC的核心框架AQS，所有获取锁失败的线程，会被封装成节点放入一个CLH虚拟双向队列中进行排队等待。当锁被释放时，会从队列头部唤醒下一个等待的线程。整个过程都在用户态完成，避免了频繁的内核态切换。\n    > AQS 内部通过一个 `volatile` 的 `int` 类型的 `state` 变量来表示同步状态（0表示未锁定，>0表示已锁定），并使用 **CAS** 操作来原子性地修改这个 `state` 值。\n  - 功能丰富：等待可中断（等待锁的线程可被中断）、可实现公平锁（按线程请求的顺序获取锁）、可实现非公平锁（允许插队、吞吐量更高）、可尝试获取锁（可在指定时间内尝试获取锁，失败则返回）、可绑定多个条件（可分组唤醒等待的线程，实现更精细的线程通信）\n    \n选择问题：在绝大多数情况下，当并发冲突不激烈、同步逻辑简单时，优先选择Synchronized关键字，在特定的场景下，比如需要使用Synchronized不具备的高级功能时，或者是在我的秒杀项目中，需要将事务提交的完整过程都包裹在锁内，即手动控制锁时。","slug":"1-秒杀项目1.0-丢失更新和锁失效","published":1,"updated":"2025-10-03T03:55:14.182Z","layout":"post","photos":[],"_id":"cmgdn5rgu00010wuz3dp5f2gk","content":"<h3 id=\"一、项目概述\"><a href=\"#一、项目概述\" class=\"headerlink\" title=\"一、项目概述\"></a>一、项目概述</h3><ul>\n<li>项目名称：高并发-秒杀系统（1.0 单体应用原型）</li>\n<li>项目目标：从零开始设计并实现一个功能完备的秒-杀业务原型，旨在深入理解高并发场景下常见的技术挑战，如数据一致性（超卖、重复下单）、性能瓶颈等，并通过多种技术手段进行分析和优化。</li>\n<li>技术栈：<ul>\n<li>后端框架：Spring Boot</li>\n<li>数据持久层：Spring Data JPA,Hibernate</li>\n<li>数据库：MYSQL</li>\n<li>构建工具：Maven</li>\n<li>测试工具：JMeter</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、项目搭建\"><a href=\"#二、项目搭建\" class=\"headerlink\" title=\"二、项目搭建\"></a>二、项目搭建</h3><h4 id=\"1-环境搭建和初始化\"><a href=\"#1-环境搭建和初始化\" class=\"headerlink\" title=\"1. 环境搭建和初始化\"></a>1. 环境搭建和初始化</h4><ul>\n<li>使用 Spring Initializr 快速搭建了项目骨架，并集成 Spring Web、Spring Data JPA、MySQL Driver 等核心依赖。<blockquote>\n<p>Spring Web:是构建Web应用程序的核心模块。内嵌Web服务器，提供Spring MVC框架，用于HTTP报文处理能力。负责监听网络接口，接受所有外来的HTTP请求，然后根据请求的URL和方法，精准的转接给后台相应的Controller去处理。<br>Spring Data JPA：是一个用来极大简化数据库访问的框架。可以自动化SQL，进行对象-关系映射（ORM），并进行简化的自定义查询。</p>\n</blockquote>\n</li>\n<li>在 application.properties 中完成了数据库连接池的基础配置。</li>\n</ul>\n<h4 id=\"2-核心业务\"><a href=\"#2-核心业务\" class=\"headerlink\" title=\"2. 核心业务\"></a>2. 核心业务</h4><ul>\n<li>设计核心数据表<ul>\n<li>商品表<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> `product` (</span><br><span class=\"line\">`id` <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT NULL</span> AUTO_INCREMENT COMMENT <span class=\"string\">&#x27;商品ID&#x27;</span>,</span><br><span class=\"line\">`name` <span class=\"type\">VARCHAR</span>(<span class=\"number\">100</span>) <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;商品名称&#x27;</span>,</span><br><span class=\"line\">`title` <span class=\"type\">VARCHAR</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;商品标题&#x27;</span>,</span><br><span class=\"line\">`image` <span class=\"type\">VARCHAR</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;&#x27;</span> COMMENT <span class=\"string\">&#x27;商品图片URL&#x27;</span>,</span><br><span class=\"line\">`price` <span class=\"type\">DECIMAL</span>(<span class=\"number\">10</span>, <span class=\"number\">2</span>) <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;秒杀价格&#x27;</span>,</span><br><span class=\"line\">`stock` <span class=\"type\">INT</span> <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;库存数量&#x27;</span>,</span><br><span class=\"line\">`start_time` DATETIME <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;秒杀开始时间&#x27;</span>,</span><br><span class=\"line\">`end_time` DATETIME <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;秒杀结束时间&#x27;</span>,</span><br><span class=\"line\"><span class=\"keyword\">PRIMARY KEY</span> (`id`)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4;</span><br></pre></td></tr></table></figure></li>\n<li>订单表<br>在订单表的设计中加入了 (user_id, product_id)的唯一索引，即每个用户只能下一单。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> `seckill_order` (</span><br><span class=\"line\">`id` <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">`user_id` <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;用户ID&#x27;</span>,</span><br><span class=\"line\">`product_id` <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;商品ID&#x27;</span>,</span><br><span class=\"line\">`order_price` <span class=\"type\">DECIMAL</span>(<span class=\"number\">10</span>, <span class=\"number\">2</span>) <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;订单成交价格&#x27;</span>,</span><br><span class=\"line\">`create_time` DATETIME <span class=\"keyword\">DEFAULT</span> <span class=\"built_in\">CURRENT_TIMESTAMP</span> COMMENT <span class=\"string\">&#x27;创建时间&#x27;</span>,</span><br><span class=\"line\"><span class=\"keyword\">PRIMARY KEY</span> (`id`),</span><br><span class=\"line\"><span class=\"keyword\">UNIQUE</span> KEY `idx_user_product` (`user_id`, `product_id`) COMMENT <span class=\"string\">&#x27;唯一索引，防止同一用户重复秒杀同一商品&#x27;</span></span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-基础功能实现\"><a href=\"#3-基础功能实现\" class=\"headerlink\" title=\"3. 基础功能实现\"></a>3. 基础功能实现</h4><ul>\n<li>采用标准的MVC分层架构，创建Controller, Service, Repository 层。<blockquote>\n<p>Controller：作为应用的入口，直接处理外部的HTTP请求。<br>Service：实现应用的核心业务逻辑。<br>DAO：负责与数据库进行直接交互，完成数据的持久化操作。<br>Model&#x2F;Entity：数据的载体，定义了应用中的核心领域对象。</p>\n</blockquote>\n</li>\n</ul>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251103013.png\" alt=\"请求过程\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"请求过程\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251103013.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">请求过程</span></div></div>\n\n<ul>\n<li>实现秒杀接口的核心业务逻辑。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 1. 从数据库读取 Product 对象到内存</span></span><br><span class=\"line\">Optional&lt;Product&gt; productOpt = productRepository.findById(productId);</span><br><span class=\"line\"><span class=\"type\">Product</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> productOpt.get(); <span class=\"comment\">// 假设此时读到的 stock 是 100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... 其他检查 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在内存中计算新库存</span></span><br><span class=\"line\">product.setStock(product.getStock() - <span class=\"number\">1</span>); <span class=\"comment\">// 内存中的 stock 变为 99</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 将内存中的 Product 对象保存回数据库</span></span><br><span class=\"line\">productRepository.save(product); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 创建订单</span></span><br><span class=\"line\"><span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SeckillOrder</span>();</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">orderRepository.save(order);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在初始版本中不加入任何的并发控制，后续会通过压力测试来暴露和分析最原始的并发问题。</li>\n</ul>\n<h3 id=\"三、并发问题的分析与演进\"><a href=\"#三、并发问题的分析与演进\" class=\"headerlink\" title=\"三、并发问题的分析与演进\"></a>三、并发问题的分析与演进</h3><h4 id=\"1-库存设置与JMeter设置\"><a href=\"#1-库存设置与JMeter设置\" class=\"headerlink\" title=\"1. 库存设置与JMeter设置\"></a>1. 库存设置与JMeter设置</h4><ul>\n<li>stock设置为100</li>\n<li>JMeter<ul>\n<li>线程数：200</li>\n<li>1秒内同时发出200个并发请求</li>\n<li>计数器自增UserId</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-实验结果\"><a href=\"#2-实验结果\" class=\"headerlink\" title=\"2. 实验结果\"></a>2. 实验结果</h4><ul>\n<li><p>订单数增加了200个但是库存数只减少了20个</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251245658.png\" alt=\"订单数\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"订单数\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251245658.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">订单数</span></div></div>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251246389.png\" alt=\"库存数\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"库存数\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251246389.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">库存数</span></div></div>\n</li>\n<li><p>分析原因：事务和内存状态————Spring的@Transaction注解和JPA的工作机制</p>\n<ul>\n<li>一级缓存：当第一个请求通过findById加载了ID为1的商品后，这个product对象会被放入当前事务的一级缓存中。</li>\n<li>事务提交时才真正更新：productRepository.save(product)这个操作，并不是立即向数据库发送UPDATE语句，而要等到整个processSeckill方法执行完毕、事务准备提交时，才会生成并发送给数据库。</li>\n</ul>\n</li>\n<li><p>丢失的更新（stock&#x3D;80）：前十个线程有可能都加载到了还没有提交的product，即此时读到的stock依然是100，后面的九次更新覆盖了第一次更新，所以最终结果和只更新一次是完全一样的（stock变成了99）。每次都有一批线程在竞争，但最后只有一个线程的更新“活”到了最后，导致库存最终只减少了大约20次。</p>\n</li>\n<li><p>订单的正常建立（新增order数&#x3D;200）：orderRepository.save(order)这个操作，因为每个订单的主键都是自增的，并且（user_id,product_id）的组合也是唯一的，所以每一次订单的插入都能成功。</p>\n</li>\n</ul>\n<h4 id=\"3-改进\"><a href=\"#3-改进\" class=\"headerlink\" title=\"3. 改进\"></a>3. 改进</h4><h5 id=\"第一次尝试-在-processSeckill-方法上加-synchronized-锁\"><a href=\"#第一次尝试-在-processSeckill-方法上加-synchronized-锁\" class=\"headerlink\" title=\"第一次尝试-在 processSeckill 方法上加 synchronized 锁\"></a>第一次尝试-在 processSeckill 方法上加 synchronized 锁</h5><ul>\n<li>预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。</li>\n</ul>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span>  String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 1. 从数据库读取 Product 对象到内存</span></span><br><span class=\"line\">Optional&lt;Product&gt; productOpt = productRepository.findById(productId);</span><br><span class=\"line\"><span class=\"type\">Product</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> productOpt.get(); <span class=\"comment\">// 假设此时读到的 stock 是 100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... 其他检查 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在内存中计算新库存</span></span><br><span class=\"line\">product.setStock(product.getStock() - <span class=\"number\">1</span>); <span class=\"comment\">// 内存中的 stock 变为 99</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 将内存中的 Product 对象保存回数据库</span></span><br><span class=\"line\">productRepository.save(product); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 创建订单</span></span><br><span class=\"line\"><span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SeckillOrder</span>();</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">orderRepository.save(order);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>结果：数据依然错误，订单数为200，库存数为79,而吞吐量和平均响应时间没有发生明显变化。</li>\n<li>分析：@Transaction 与 synchronized 的冲突<ul>\n<li>当给一个方法加上@Transaction注解时，Spring为了能够控制事务的开启、提交和回滚，并不会让你直接调用这个方法，相反，Spring会在运行时创建一个该类的代理对象proxy。</li>\n<li>事务先生效：即代理对象的同名方法会被触发，代理对象会先开启一个事务</li>\n<li>synchronized被绕过：它是Java原生关键字，作用于对象实例的锁，但Spring的代理机制在调用目标方法时，可能会导致锁机制失效，因为代理方法本身没有synchronized，调用父类（本身SeckillService）的方法时，锁的上下文可能已经丢失或不准确。<br>即，Spring的AOP代理与Java原生的锁关键字之间存在冲突，代理绕过了锁，导致synchronized锁机制未生效。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"第二次尝试-在事务内使用ReentrantLock\"><a href=\"#第二次尝试-在事务内使用ReentrantLock\" class=\"headerlink\" title=\"第二次尝试-在事务内使用ReentrantLock\"></a>第二次尝试-在事务内使用ReentrantLock</h5><ul>\n<li><p>预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;  <span class=\"comment\">// 1. 事务由代理对象在这里开启</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 在方法开始时手动加锁</span></span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 所有业务逻辑都放在 try 块中</span></span><br><span class=\"line\">        <span class=\"comment\">// 其他检查</span></span><br><span class=\"line\"></span><br><span class=\"line\">        product.setStock(product.getStock() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        productRepository.save(product);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SeckillOrder</span>();</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        orderRepository.save(order);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！订单创建中...&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3. 【至关重要】在 finally 块中解锁，确保即使发生异常也能释放锁</span></span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;      <span class=\"comment\">// 4. 事务由代理对象在这里提交</span></span><br></pre></td></tr></table></figure></li>\n<li><p>显示控制：lock.lock()是代码逻辑的一部分，在代理调用了实际方法之后，业务逻辑执行之前被调用。任何线程进入这个方法后，都必须先获取到这个锁才能继续执行。</p>\n</li>\n<li><p>安全释放：使用try…finally结构，确保无论业务逻辑是否成功，锁最终都会被释放，避免了“死锁”的风险。</p>\n</li>\n<li><p>结果：数据依然错误，订单数为200，库存数为79,而吞吐量和平均响应时间没有发生明显变化。</p>\n</li>\n<li><p>分析：锁的范围 VS 事务的范围</p>\n<ul>\n<li>锁释放在前，事务提交在后，所以当线程A解锁后，UPDATE语句还没有提交进入数据库，而此时线程B立即取锁进入了方法，此时B读取到的库存数还是旧值。重演丢失更新问题。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"第三次尝试-ReentrantLock-手动事务\"><a href=\"#第三次尝试-ReentrantLock-手动事务\" class=\"headerlink\" title=\"第三次尝试-ReentrantLock + 手动事务\"></a>第三次尝试-ReentrantLock + 手动事务</h5><ul>\n<li><p>预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。</p>\n</li>\n<li><p>解决方案：将事务控制移入锁内</p>\n<ul>\n<li>放弃@Transaction注解，因为这个注解无法精细控制提交时机，改用最经典、最原始的手动事务管理。</li>\n<li>使用PlatformTransactionManager 来手动控制事务的开始、提交和回滚。将整个生命周期包裹在锁内。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> PlatformTransactionManager transactionManager;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 上锁</span></span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">DefaultTransactionDefinition</span> <span class=\"variable\">def</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultTransactionDefinition</span>();</span><br><span class=\"line\">    def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class=\"line\">    <span class=\"comment\">// 2. 开启事务</span></span><br><span class=\"line\">    <span class=\"type\">TransactionStatus</span> <span class=\"variable\">status</span> <span class=\"operator\">=</span> transactionManager.getTransaction(def);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...所有业务逻辑，和之前一样</span></span><br><span class=\"line\">        <span class=\"comment\">// 3. 【关键】在锁释放前，手动提交事务</span></span><br><span class=\"line\">        transactionManager.commit(status);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！订单创建中...&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//  如果发生任何异常，手动回滚事务</span></span><br><span class=\"line\">        transactionManager.rollback(status);</span><br><span class=\"line\">        <span class=\"comment\">// 将异常信息返回或记录日志</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> e.getMessage(); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 4. 最后，释放锁</span></span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>结果:数据正确，库存为0，订单数为100，吞吐量没有下降，甚至比没有并发控制的1.0 版本还要高。</p>\n</li>\n<li><p>分析: 在高并发场景下，无序的并发混乱，有时远比有序的串行执行要慢。下表为初始版本和三次尝试版本的压测数据。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Label</th>\n<th>样本</th>\n<th>平均值</th>\n<th>中位数</th>\n<th>90% 百分位</th>\n<th>95% 百分位</th>\n<th>99% 百分位</th>\n<th>最小值</th>\n<th>最大值</th>\n<th>异常 %</th>\n<th>吞吐量</th>\n<th>接收 KB&#x2F;sec</th>\n<th>发送 KB&#x2F;sec</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1.0秒杀系统</td>\n<td>200</td>\n<td>740</td>\n<td>810</td>\n<td>1044</td>\n<td>1078</td>\n<td>1083</td>\n<td>254</td>\n<td>1084</td>\n<td>0.00%</td>\n<td>95.92</td>\n<td>18.27</td>\n<td>20.51</td>\n</tr>\n<tr>\n<td>2.0秒杀系统_添加关键字synchronized</td>\n<td>200</td>\n<td>578</td>\n<td>598</td>\n<td>744</td>\n<td>763</td>\n<td>767</td>\n<td>79</td>\n<td>831</td>\n<td>0.00%</td>\n<td>113.38</td>\n<td>21.59</td>\n<td>24.24</td>\n</tr>\n<tr>\n<td>2.0秒杀系统_手动添加锁ReentrantLock</td>\n<td>200</td>\n<td>638</td>\n<td>663</td>\n<td>819</td>\n<td>837</td>\n<td>879</td>\n<td>237</td>\n<td>891</td>\n<td>0.00%</td>\n<td>105.76</td>\n<td>20.14</td>\n<td>22.62</td>\n</tr>\n<tr>\n<td>2.0秒杀系统_不使用@Transaction手动加锁</td>\n<td>200</td>\n<td>905</td>\n<td>1024</td>\n<td>1148</td>\n<td>1160</td>\n<td>1175</td>\n<td>203</td>\n<td>1178</td>\n<td>0.00%</td>\n<td>100.45</td>\n<td>18.25</td>\n<td>21.48</td>\n</tr>\n</tbody></table>\n<ul>\n<li>无锁版虽然看似并行，但造成了数据库层面大量的行锁竞争、唯一键冲突错误、事务回滚，这些“无效”的数据库操作成为了真正的性能瓶颈。而加锁后的版本，虽然在应用层是串行的，但它保护了数据库，向数据库发送的是一连串干净、有效的请求，避免了数据库的内部冲突和错误处理开销，因此整体系统的有效吞吐量反而更高。</li>\n</ul>\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"Transaction注解-一个请求的生命周期\"><a href=\"#Transaction注解-一个请求的生命周期\" class=\"headerlink\" title=\"@Transaction注解 &amp; 一个请求的生命周期\"></a>@Transaction注解 &amp; 一个请求的生命周期</h4><ul>\n<li>Controller接受请求，调用Service方法，但此时Service引用的是Spring的代理对象，而不是原始实例。代理对象的方法被触发，检查到方法上有@Transaction注解，代理对象向事务管理器（platformTransactionManager）请求开启一个新的事务。从数据库连接池中获取一个数据库连接，向MySQL服务器发送指令。此时一个数据库事务的“上下文”已经建立，但还没有任何实际的业务SQL被执行。在开启事务后，代理对象才会调用原始实例的方法，开始执行业务逻辑。但需要注意的是，这个阶段中是没有发生任何数据库操作的，只是告诉JPA的持久化上下文，标记了该对象，后续需要“留意”。</li>\n<li>所有代码都执行完毕后，到达return语句，准备将结果返回。此时代理对象接收到真实方法的返回值，因为没有捕获到任何异常，代理对象判断这次业务执行是成功的，通知事务管理器可以提交事务了。事务管理器执行数据库同步，在真正COMMIT之前，JPA会执行一次Flush，生成SQL语句，发送到MYSQL服务器并执行，直到COMMIT被成功执行了，这次更新才被永久地鞋屋数据库磁盘。</li>\n<li>代理对象将你方法的返回值传递给Controller，Controller再将其封装成HTTP响应返回给用户。</li>\n</ul>\n<h4 id=\"锁-初步\"><a href=\"#锁-初步\" class=\"headerlink\" title=\"锁-初步\"></a>锁-初步</h4><ol>\n<li>Synchronized：Keyword、JVM内置的同步原语，简单、隐式的加锁和解锁机制。</li>\n</ol>\n<ul>\n<li>使用方法：修饰实例方法、修饰静态方法、修饰代码块。</li>\n<li>实现依赖于每个Java对象头部的Mark Word和JVM内部的Monitor对象监视器（当线程尝试获取锁时，JVM会执行Monitorenter字节码指令，尝试获得对象Monitor所有权。释放锁时即执行monitorexit）。</li>\n<li>锁升级机制：偏向锁—&gt;轻量级锁(当有第二个线程竞争时升级，竞争的线程通过自旋和CAS来尝试获取锁，不进入阻塞状态)—&gt;重量级锁（竞争加剧，自旋失败，升级，未获取到锁的线程会被阻塞，由内核进行调度，性能开销最大）</li>\n</ul>\n<ol start=\"2\">\n<li>ReentrantLock：是JUC工具包的核心成员，显式加锁和解锁机制。</li>\n</ol>\n<ul>\n<li>使用方法：标准的使用范式  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 在类中声明一个 Lock 实例</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">someMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 2. 在 try...finally 结构中进行加锁和解锁</span></span><br><span class=\"line\">lock.lock(); <span class=\"comment\">// 获取锁</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 3. 保护的同步代码</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 4. 必须在 finally 块中释放锁</span></span><br><span class=\"line\">lock.unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>实现依赖于JUC的核心框架AQS，所有获取锁失败的线程，会被封装成节点放入一个CLH虚拟双向队列中进行排队等待。当锁被释放时，会从队列头部唤醒下一个等待的线程。整个过程都在用户态完成，避免了频繁的内核态切换。<blockquote>\n<p>AQS 内部通过一个 <code>volatile</code> 的 <code>int</code> 类型的 <code>state</code> 变量来表示同步状态（0表示未锁定，&gt;0表示已锁定），并使用 <strong>CAS</strong> 操作来原子性地修改这个 <code>state</code> 值。</p>\n</blockquote>\n</li>\n<li>功能丰富：等待可中断（等待锁的线程可被中断）、可实现公平锁（按线程请求的顺序获取锁）、可实现非公平锁（允许插队、吞吐量更高）、可尝试获取锁（可在指定时间内尝试获取锁，失败则返回）、可绑定多个条件（可分组唤醒等待的线程，实现更精细的线程通信）</li>\n</ul>\n<p>选择问题：在绝大多数情况下，当并发冲突不激烈、同步逻辑简单时，优先选择Synchronized关键字，在特定的场景下，比如需要使用Synchronized不具备的高级功能时，或者是在我的秒杀项目中，需要将事务提交的完整过程都包裹在锁内，即手动控制锁时。</p>\n","excerpt":"","more":"<h3 id=\"一、项目概述\"><a href=\"#一、项目概述\" class=\"headerlink\" title=\"一、项目概述\"></a>一、项目概述</h3><ul>\n<li>项目名称：高并发-秒杀系统（1.0 单体应用原型）</li>\n<li>项目目标：从零开始设计并实现一个功能完备的秒-杀业务原型，旨在深入理解高并发场景下常见的技术挑战，如数据一致性（超卖、重复下单）、性能瓶颈等，并通过多种技术手段进行分析和优化。</li>\n<li>技术栈：<ul>\n<li>后端框架：Spring Boot</li>\n<li>数据持久层：Spring Data JPA,Hibernate</li>\n<li>数据库：MYSQL</li>\n<li>构建工具：Maven</li>\n<li>测试工具：JMeter</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二、项目搭建\"><a href=\"#二、项目搭建\" class=\"headerlink\" title=\"二、项目搭建\"></a>二、项目搭建</h3><h4 id=\"1-环境搭建和初始化\"><a href=\"#1-环境搭建和初始化\" class=\"headerlink\" title=\"1. 环境搭建和初始化\"></a>1. 环境搭建和初始化</h4><ul>\n<li>使用 Spring Initializr 快速搭建了项目骨架，并集成 Spring Web、Spring Data JPA、MySQL Driver 等核心依赖。<blockquote>\n<p>Spring Web:是构建Web应用程序的核心模块。内嵌Web服务器，提供Spring MVC框架，用于HTTP报文处理能力。负责监听网络接口，接受所有外来的HTTP请求，然后根据请求的URL和方法，精准的转接给后台相应的Controller去处理。<br>Spring Data JPA：是一个用来极大简化数据库访问的框架。可以自动化SQL，进行对象-关系映射（ORM），并进行简化的自定义查询。</p>\n</blockquote>\n</li>\n<li>在 application.properties 中完成了数据库连接池的基础配置。</li>\n</ul>\n<h4 id=\"2-核心业务\"><a href=\"#2-核心业务\" class=\"headerlink\" title=\"2. 核心业务\"></a>2. 核心业务</h4><ul>\n<li>设计核心数据表<ul>\n<li>商品表<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> `product` (</span><br><span class=\"line\">`id` <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT NULL</span> AUTO_INCREMENT COMMENT <span class=\"string\">&#x27;商品ID&#x27;</span>,</span><br><span class=\"line\">`name` <span class=\"type\">VARCHAR</span>(<span class=\"number\">100</span>) <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;商品名称&#x27;</span>,</span><br><span class=\"line\">`title` <span class=\"type\">VARCHAR</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;商品标题&#x27;</span>,</span><br><span class=\"line\">`image` <span class=\"type\">VARCHAR</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;&#x27;</span> COMMENT <span class=\"string\">&#x27;商品图片URL&#x27;</span>,</span><br><span class=\"line\">`price` <span class=\"type\">DECIMAL</span>(<span class=\"number\">10</span>, <span class=\"number\">2</span>) <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;秒杀价格&#x27;</span>,</span><br><span class=\"line\">`stock` <span class=\"type\">INT</span> <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;库存数量&#x27;</span>,</span><br><span class=\"line\">`start_time` DATETIME <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;秒杀开始时间&#x27;</span>,</span><br><span class=\"line\">`end_time` DATETIME <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;秒杀结束时间&#x27;</span>,</span><br><span class=\"line\"><span class=\"keyword\">PRIMARY KEY</span> (`id`)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4;</span><br></pre></td></tr></table></figure></li>\n<li>订单表<br>在订单表的设计中加入了 (user_id, product_id)的唯一索引，即每个用户只能下一单。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> `seckill_order` (</span><br><span class=\"line\">`id` <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">`user_id` <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;用户ID&#x27;</span>,</span><br><span class=\"line\">`product_id` <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;商品ID&#x27;</span>,</span><br><span class=\"line\">`order_price` <span class=\"type\">DECIMAL</span>(<span class=\"number\">10</span>, <span class=\"number\">2</span>) <span class=\"keyword\">NOT NULL</span> COMMENT <span class=\"string\">&#x27;订单成交价格&#x27;</span>,</span><br><span class=\"line\">`create_time` DATETIME <span class=\"keyword\">DEFAULT</span> <span class=\"built_in\">CURRENT_TIMESTAMP</span> COMMENT <span class=\"string\">&#x27;创建时间&#x27;</span>,</span><br><span class=\"line\"><span class=\"keyword\">PRIMARY KEY</span> (`id`),</span><br><span class=\"line\"><span class=\"keyword\">UNIQUE</span> KEY `idx_user_product` (`user_id`, `product_id`) COMMENT <span class=\"string\">&#x27;唯一索引，防止同一用户重复秒杀同一商品&#x27;</span></span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-基础功能实现\"><a href=\"#3-基础功能实现\" class=\"headerlink\" title=\"3. 基础功能实现\"></a>3. 基础功能实现</h4><ul>\n<li>采用标准的MVC分层架构，创建Controller, Service, Repository 层。<blockquote>\n<p>Controller：作为应用的入口，直接处理外部的HTTP请求。<br>Service：实现应用的核心业务逻辑。<br>DAO：负责与数据库进行直接交互，完成数据的持久化操作。<br>Model&#x2F;Entity：数据的载体，定义了应用中的核心领域对象。</p>\n</blockquote>\n</li>\n</ul>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251103013.png\" alt=\"请求过程\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"请求过程\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251103013.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">请求过程</span></div></div>\n\n<ul>\n<li>实现秒杀接口的核心业务逻辑。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 1. 从数据库读取 Product 对象到内存</span></span><br><span class=\"line\">Optional&lt;Product&gt; productOpt = productRepository.findById(productId);</span><br><span class=\"line\"><span class=\"type\">Product</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> productOpt.get(); <span class=\"comment\">// 假设此时读到的 stock 是 100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... 其他检查 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在内存中计算新库存</span></span><br><span class=\"line\">product.setStock(product.getStock() - <span class=\"number\">1</span>); <span class=\"comment\">// 内存中的 stock 变为 99</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 将内存中的 Product 对象保存回数据库</span></span><br><span class=\"line\">productRepository.save(product); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 创建订单</span></span><br><span class=\"line\"><span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SeckillOrder</span>();</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">orderRepository.save(order);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在初始版本中不加入任何的并发控制，后续会通过压力测试来暴露和分析最原始的并发问题。</li>\n</ul>\n<h3 id=\"三、并发问题的分析与演进\"><a href=\"#三、并发问题的分析与演进\" class=\"headerlink\" title=\"三、并发问题的分析与演进\"></a>三、并发问题的分析与演进</h3><h4 id=\"1-库存设置与JMeter设置\"><a href=\"#1-库存设置与JMeter设置\" class=\"headerlink\" title=\"1. 库存设置与JMeter设置\"></a>1. 库存设置与JMeter设置</h4><ul>\n<li>stock设置为100</li>\n<li>JMeter<ul>\n<li>线程数：200</li>\n<li>1秒内同时发出200个并发请求</li>\n<li>计数器自增UserId</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-实验结果\"><a href=\"#2-实验结果\" class=\"headerlink\" title=\"2. 实验结果\"></a>2. 实验结果</h4><ul>\n<li><p>订单数增加了200个但是库存数只减少了20个</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251245658.png\" alt=\"订单数\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"订单数\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251245658.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">订单数</span></div></div>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251246389.png\" alt=\"库存数\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"库存数\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509251246389.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">库存数</span></div></div>\n</li>\n<li><p>分析原因：事务和内存状态————Spring的@Transaction注解和JPA的工作机制</p>\n<ul>\n<li>一级缓存：当第一个请求通过findById加载了ID为1的商品后，这个product对象会被放入当前事务的一级缓存中。</li>\n<li>事务提交时才真正更新：productRepository.save(product)这个操作，并不是立即向数据库发送UPDATE语句，而要等到整个processSeckill方法执行完毕、事务准备提交时，才会生成并发送给数据库。</li>\n</ul>\n</li>\n<li><p>丢失的更新（stock&#x3D;80）：前十个线程有可能都加载到了还没有提交的product，即此时读到的stock依然是100，后面的九次更新覆盖了第一次更新，所以最终结果和只更新一次是完全一样的（stock变成了99）。每次都有一批线程在竞争，但最后只有一个线程的更新“活”到了最后，导致库存最终只减少了大约20次。</p>\n</li>\n<li><p>订单的正常建立（新增order数&#x3D;200）：orderRepository.save(order)这个操作，因为每个订单的主键都是自增的，并且（user_id,product_id）的组合也是唯一的，所以每一次订单的插入都能成功。</p>\n</li>\n</ul>\n<h4 id=\"3-改进\"><a href=\"#3-改进\" class=\"headerlink\" title=\"3. 改进\"></a>3. 改进</h4><h5 id=\"第一次尝试-在-processSeckill-方法上加-synchronized-锁\"><a href=\"#第一次尝试-在-processSeckill-方法上加-synchronized-锁\" class=\"headerlink\" title=\"第一次尝试-在 processSeckill 方法上加 synchronized 锁\"></a>第一次尝试-在 processSeckill 方法上加 synchronized 锁</h5><ul>\n<li>预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。</li>\n</ul>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span>  String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 1. 从数据库读取 Product 对象到内存</span></span><br><span class=\"line\">Optional&lt;Product&gt; productOpt = productRepository.findById(productId);</span><br><span class=\"line\"><span class=\"type\">Product</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> productOpt.get(); <span class=\"comment\">// 假设此时读到的 stock 是 100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ... 其他检查 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在内存中计算新库存</span></span><br><span class=\"line\">product.setStock(product.getStock() - <span class=\"number\">1</span>); <span class=\"comment\">// 内存中的 stock 变为 99</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 将内存中的 Product 对象保存回数据库</span></span><br><span class=\"line\">productRepository.save(product); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 创建订单</span></span><br><span class=\"line\"><span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SeckillOrder</span>();</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">orderRepository.save(order);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>结果：数据依然错误，订单数为200，库存数为79,而吞吐量和平均响应时间没有发生明显变化。</li>\n<li>分析：@Transaction 与 synchronized 的冲突<ul>\n<li>当给一个方法加上@Transaction注解时，Spring为了能够控制事务的开启、提交和回滚，并不会让你直接调用这个方法，相反，Spring会在运行时创建一个该类的代理对象proxy。</li>\n<li>事务先生效：即代理对象的同名方法会被触发，代理对象会先开启一个事务</li>\n<li>synchronized被绕过：它是Java原生关键字，作用于对象实例的锁，但Spring的代理机制在调用目标方法时，可能会导致锁机制失效，因为代理方法本身没有synchronized，调用父类（本身SeckillService）的方法时，锁的上下文可能已经丢失或不准确。<br>即，Spring的AOP代理与Java原生的锁关键字之间存在冲突，代理绕过了锁，导致synchronized锁机制未生效。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"第二次尝试-在事务内使用ReentrantLock\"><a href=\"#第二次尝试-在事务内使用ReentrantLock\" class=\"headerlink\" title=\"第二次尝试-在事务内使用ReentrantLock\"></a>第二次尝试-在事务内使用ReentrantLock</h5><ul>\n<li><p>预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;  <span class=\"comment\">// 1. 事务由代理对象在这里开启</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 在方法开始时手动加锁</span></span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 所有业务逻辑都放在 try 块中</span></span><br><span class=\"line\">        <span class=\"comment\">// 其他检查</span></span><br><span class=\"line\"></span><br><span class=\"line\">        product.setStock(product.getStock() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        productRepository.save(product);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SeckillOrder</span>();</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        orderRepository.save(order);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！订单创建中...&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3. 【至关重要】在 finally 块中解锁，确保即使发生异常也能释放锁</span></span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;      <span class=\"comment\">// 4. 事务由代理对象在这里提交</span></span><br></pre></td></tr></table></figure></li>\n<li><p>显示控制：lock.lock()是代码逻辑的一部分，在代理调用了实际方法之后，业务逻辑执行之前被调用。任何线程进入这个方法后，都必须先获取到这个锁才能继续执行。</p>\n</li>\n<li><p>安全释放：使用try…finally结构，确保无论业务逻辑是否成功，锁最终都会被释放，避免了“死锁”的风险。</p>\n</li>\n<li><p>结果：数据依然错误，订单数为200，库存数为79,而吞吐量和平均响应时间没有发生明显变化。</p>\n</li>\n<li><p>分析：锁的范围 VS 事务的范围</p>\n<ul>\n<li>锁释放在前，事务提交在后，所以当线程A解锁后，UPDATE语句还没有提交进入数据库，而此时线程B立即取锁进入了方法，此时B读取到的库存数还是旧值。重演丢失更新问题。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"第三次尝试-ReentrantLock-手动事务\"><a href=\"#第三次尝试-ReentrantLock-手动事务\" class=\"headerlink\" title=\"第三次尝试-ReentrantLock + 手动事务\"></a>第三次尝试-ReentrantLock + 手动事务</h5><ul>\n<li><p>预期结果:锁生效，200个线程变为串行处理，数据一致性得以保证。即库存数为0，订单数为100，但吞吐量降低，平均响应时间升高。</p>\n</li>\n<li><p>解决方案：将事务控制移入锁内</p>\n<ul>\n<li>放弃@Transaction注解，因为这个注解无法精细控制提交时机，改用最经典、最原始的手动事务管理。</li>\n<li>使用PlatformTransactionManager 来手动控制事务的开始、提交和回滚。将整个生命周期包裹在锁内。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> PlatformTransactionManager transactionManager;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 上锁</span></span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">DefaultTransactionDefinition</span> <span class=\"variable\">def</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultTransactionDefinition</span>();</span><br><span class=\"line\">    def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class=\"line\">    <span class=\"comment\">// 2. 开启事务</span></span><br><span class=\"line\">    <span class=\"type\">TransactionStatus</span> <span class=\"variable\">status</span> <span class=\"operator\">=</span> transactionManager.getTransaction(def);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...所有业务逻辑，和之前一样</span></span><br><span class=\"line\">        <span class=\"comment\">// 3. 【关键】在锁释放前，手动提交事务</span></span><br><span class=\"line\">        transactionManager.commit(status);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！订单创建中...&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//  如果发生任何异常，手动回滚事务</span></span><br><span class=\"line\">        transactionManager.rollback(status);</span><br><span class=\"line\">        <span class=\"comment\">// 将异常信息返回或记录日志</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> e.getMessage(); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 4. 最后，释放锁</span></span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>结果:数据正确，库存为0，订单数为100，吞吐量没有下降，甚至比没有并发控制的1.0 版本还要高。</p>\n</li>\n<li><p>分析: 在高并发场景下，无序的并发混乱，有时远比有序的串行执行要慢。下表为初始版本和三次尝试版本的压测数据。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Label</th>\n<th>样本</th>\n<th>平均值</th>\n<th>中位数</th>\n<th>90% 百分位</th>\n<th>95% 百分位</th>\n<th>99% 百分位</th>\n<th>最小值</th>\n<th>最大值</th>\n<th>异常 %</th>\n<th>吞吐量</th>\n<th>接收 KB&#x2F;sec</th>\n<th>发送 KB&#x2F;sec</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1.0秒杀系统</td>\n<td>200</td>\n<td>740</td>\n<td>810</td>\n<td>1044</td>\n<td>1078</td>\n<td>1083</td>\n<td>254</td>\n<td>1084</td>\n<td>0.00%</td>\n<td>95.92</td>\n<td>18.27</td>\n<td>20.51</td>\n</tr>\n<tr>\n<td>2.0秒杀系统_添加关键字synchronized</td>\n<td>200</td>\n<td>578</td>\n<td>598</td>\n<td>744</td>\n<td>763</td>\n<td>767</td>\n<td>79</td>\n<td>831</td>\n<td>0.00%</td>\n<td>113.38</td>\n<td>21.59</td>\n<td>24.24</td>\n</tr>\n<tr>\n<td>2.0秒杀系统_手动添加锁ReentrantLock</td>\n<td>200</td>\n<td>638</td>\n<td>663</td>\n<td>819</td>\n<td>837</td>\n<td>879</td>\n<td>237</td>\n<td>891</td>\n<td>0.00%</td>\n<td>105.76</td>\n<td>20.14</td>\n<td>22.62</td>\n</tr>\n<tr>\n<td>2.0秒杀系统_不使用@Transaction手动加锁</td>\n<td>200</td>\n<td>905</td>\n<td>1024</td>\n<td>1148</td>\n<td>1160</td>\n<td>1175</td>\n<td>203</td>\n<td>1178</td>\n<td>0.00%</td>\n<td>100.45</td>\n<td>18.25</td>\n<td>21.48</td>\n</tr>\n</tbody></table>\n<ul>\n<li>无锁版虽然看似并行，但造成了数据库层面大量的行锁竞争、唯一键冲突错误、事务回滚，这些“无效”的数据库操作成为了真正的性能瓶颈。而加锁后的版本，虽然在应用层是串行的，但它保护了数据库，向数据库发送的是一连串干净、有效的请求，避免了数据库的内部冲突和错误处理开销，因此整体系统的有效吞吐量反而更高。</li>\n</ul>\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"Transaction注解-一个请求的生命周期\"><a href=\"#Transaction注解-一个请求的生命周期\" class=\"headerlink\" title=\"@Transaction注解 &amp; 一个请求的生命周期\"></a>@Transaction注解 &amp; 一个请求的生命周期</h4><ul>\n<li>Controller接受请求，调用Service方法，但此时Service引用的是Spring的代理对象，而不是原始实例。代理对象的方法被触发，检查到方法上有@Transaction注解，代理对象向事务管理器（platformTransactionManager）请求开启一个新的事务。从数据库连接池中获取一个数据库连接，向MySQL服务器发送指令。此时一个数据库事务的“上下文”已经建立，但还没有任何实际的业务SQL被执行。在开启事务后，代理对象才会调用原始实例的方法，开始执行业务逻辑。但需要注意的是，这个阶段中是没有发生任何数据库操作的，只是告诉JPA的持久化上下文，标记了该对象，后续需要“留意”。</li>\n<li>所有代码都执行完毕后，到达return语句，准备将结果返回。此时代理对象接收到真实方法的返回值，因为没有捕获到任何异常，代理对象判断这次业务执行是成功的，通知事务管理器可以提交事务了。事务管理器执行数据库同步，在真正COMMIT之前，JPA会执行一次Flush，生成SQL语句，发送到MYSQL服务器并执行，直到COMMIT被成功执行了，这次更新才被永久地鞋屋数据库磁盘。</li>\n<li>代理对象将你方法的返回值传递给Controller，Controller再将其封装成HTTP响应返回给用户。</li>\n</ul>\n<h4 id=\"锁-初步\"><a href=\"#锁-初步\" class=\"headerlink\" title=\"锁-初步\"></a>锁-初步</h4><ol>\n<li>Synchronized：Keyword、JVM内置的同步原语，简单、隐式的加锁和解锁机制。</li>\n</ol>\n<ul>\n<li>使用方法：修饰实例方法、修饰静态方法、修饰代码块。</li>\n<li>实现依赖于每个Java对象头部的Mark Word和JVM内部的Monitor对象监视器（当线程尝试获取锁时，JVM会执行Monitorenter字节码指令，尝试获得对象Monitor所有权。释放锁时即执行monitorexit）。</li>\n<li>锁升级机制：偏向锁—&gt;轻量级锁(当有第二个线程竞争时升级，竞争的线程通过自旋和CAS来尝试获取锁，不进入阻塞状态)—&gt;重量级锁（竞争加剧，自旋失败，升级，未获取到锁的线程会被阻塞，由内核进行调度，性能开销最大）</li>\n</ul>\n<ol start=\"2\">\n<li>ReentrantLock：是JUC工具包的核心成员，显式加锁和解锁机制。</li>\n</ol>\n<ul>\n<li>使用方法：标准的使用范式  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 在类中声明一个 Lock 实例</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">someMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 2. 在 try...finally 结构中进行加锁和解锁</span></span><br><span class=\"line\">lock.lock(); <span class=\"comment\">// 获取锁</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 3. 保护的同步代码</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 4. 必须在 finally 块中释放锁</span></span><br><span class=\"line\">lock.unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>实现依赖于JUC的核心框架AQS，所有获取锁失败的线程，会被封装成节点放入一个CLH虚拟双向队列中进行排队等待。当锁被释放时，会从队列头部唤醒下一个等待的线程。整个过程都在用户态完成，避免了频繁的内核态切换。<blockquote>\n<p>AQS 内部通过一个 <code>volatile</code> 的 <code>int</code> 类型的 <code>state</code> 变量来表示同步状态（0表示未锁定，&gt;0表示已锁定），并使用 <strong>CAS</strong> 操作来原子性地修改这个 <code>state</code> 值。</p>\n</blockquote>\n</li>\n<li>功能丰富：等待可中断（等待锁的线程可被中断）、可实现公平锁（按线程请求的顺序获取锁）、可实现非公平锁（允许插队、吞吐量更高）、可尝试获取锁（可在指定时间内尝试获取锁，失败则返回）、可绑定多个条件（可分组唤醒等待的线程，实现更精细的线程通信）</li>\n</ul>\n<p>选择问题：在绝大多数情况下，当并发冲突不激烈、同步逻辑简单时，优先选择Synchronized关键字，在特定的场景下，比如需要使用Synchronized不具备的高级功能时，或者是在我的秒杀项目中，需要将事务提交的完整过程都包裹在锁内，即手动控制锁时。</p>\n"},{"title":"1-秒杀项目1.1-读写分离","poster":{"topic":"标题上方的小字","headline":"大标题","caption":"标题下方的小字","color":"标题颜色"},"date":"2025-10-01T08:44:13.000Z","description":"重新起航版","cover":null,"banner":null,"sticky":null,"mermaid":null,"katex":null,"mathjax":null,"topic":null,"author":null,"references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n### 一、最初的构想：引入读写锁\n- 在秒杀开始前，有成千上万的用户疯狂刷新商品详情页，他们只是想看看库存还剩下多少，即进行读操作。在当前的实现下，大量的读请求也必须排队等待获取ReentrantLock，严重影响了用户体验。这是一个典型的“读多写少”的场景，所以引入读写锁。\n#### 改写代码\n- 重构SeckillService，将业务逻辑拆分出两个核心方法：\n  - checkStock(): 专门用于查询库存，使用读锁。\n  \n  ```Java\n  /*\n    * 新增方法，用于查询商品库存，专门用于处理读请求\n    * 使用读写锁中的读锁，允许并发读取，互不堵塞\n  */\n  public Integer checkStock(Long productId) {\n    log.info(\"线程 {} 尝试获取读锁...\", Thread.currentThread().getName());\n    readLock.lock(); // 读操作上读锁\n    log.info(\"线程 {} 成功获取到读锁\", Thread.currentThread().getName());\n    try {\n        Optional<Product> productOpt = productRepository.findById(productId);\n        if (!productOpt.isPresent()) {\n            throw new RuntimeException(\"商品不存在\");\n        }\n        log.info(\"线程 {} 读取库存为: {}\", Thread.currentThread().getName(), productOpt.get().getStock());\n        return productOpt.get().getStock();\n    } finally {\n        log.info(\"线程 {} 准备释放读锁.\", Thread.currentThread().getName());\n        readLock.unlock();\n    }\n  }\n  ```\n  - processSeckill(): 负责执行秒杀下单，使用写锁\n   ```Java\n    public String processSeckill(Long productId, Long userId) {\n        log.info(\"线程 {} 尝试获取写锁...\", Thread.currentThread().getName());\n        writeLock.lock(); // 2. 秒杀操作上写锁，确保互斥\n        log.info(\"线程 {} 成功获取到写锁\", Thread.currentThread().getName());\n        // 3. 定义事务\n        DefaultTransactionDefinition def = new DefaultTransactionDefinition();\n        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n        // 4. 开启事务\n        TransactionStatus status = transactionManager.getTransaction(def);\n\n        try {\n            // ...所有业务逻辑，和之前一样\n            // 5. 【关键】在锁释放前，手动提交事务\n            transactionManager.commit(status);\n            log.info(\"线程 {} 秒杀成功，提交事务。\", Thread.currentThread().getName());\n\n            return \"秒杀成功！订单创建中...\";\n        } catch (Exception e) {\n            // 6. 如果发生任何异常，手动回滚事务\n            transactionManager.rollback(status);\n            log.error(\"线程 {} 秒杀失败: {}\", Thread.currentThread().getName(), e.getMessage());\n            // 将异常信息返回或记录日志\n            return e.getMessage();\n        } finally {\n            // 7. 最后，释放锁\n            log.info(\"线程 {} 准备释放写锁.\", Thread.currentThread().getName());\n            writeLock.unlock();\n        }\n    }\n  ```\n- 同时，我也在 Controller 层为查询库存新增了一个 GET 方式的 API 接口。\n\n#### JMeter设置\n- **线程组一：读请求**\n  - **线程数：**  **500**。\n  - **Ramp-up:** 1\n  - **循环次数:** 10 \n  - 在该线程组下，创建一个 HTTP 请求，指向**读接口**：`GET /seckill/stock/1`\n- **线程组二：写请求**\n  - **线程数：**  **200** \n  - **Ramp-up:** 1\n  - **循环次数:** 1\n  - 在该线程组下，创建之前配置好的、带计数器的 HTTP 请求，指向**写接口**：`POST /seckill/1?userId=${uniqueUserId}`\n**同时启动压测**：在 JMeter 中，同时运行多个线程组。\n\n#### 压测结果与分析\n- 结果：读请求均为库存为0;写请求正常，数据库显示，库存数为0，订单数新建100。\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510011912013.png 读请求 %}\n- 分析： 瞬时的大量写请求，在一个极端的时间窗口内将库存扣减完毕。读请求因为写锁被阻塞，等到它们能够被执行时，秒杀已经结束。\n### 二、改进：并发测试场景设计\n#### 调整JMeter设置\n  由于200个/500个线程数太多，在日志中无法回看到最初的日志信息，所以修改线程数，便于观察。\n**“写请求”线程组：**\n- **线程数:** 20\n- **Ramp-up Period:** 从 `1` 改成 `20`。\n  - **作用：** 这意味着 JMeter 会在20秒内“缓慢地”启动这200个线程，大约每1秒启动一个。这给了读请求在两个写请求之间“插进来”的机会。\n- **循环次数 (Loop Count):** 1 \n\n**“读请求”线程组：**\n\n- **线程数:** 50\n- **Ramp-up Period:** 也改成 `20`。\n- **循环次数:** 保持在 `10` 。\n\n**【关键】为两个线程组设置“调度器”：**\n- 在两个线程组的配置界面下方，找到并勾选 **“调度器”**。\n- 在“**持续时间**”中，输入 `30`。\n  - **作用：** 这会强制两个线程组都在运行30秒后自动停止。这能确保读写请求在同一个时间窗口内并发执行。\n#### 压测结果与分析\n- 结果：读请求在日志中能够显示出库存数逐渐减少，写请求正常，且日志有如下模式，体现了读写锁“读共享、写独占”的理论：\n一次写 -> 一大批读（读到的值都一样） -> 又一次写 -> 又一大批读（读到的新值都一样）...\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510011920654.png 日志信息 %}\n\n### 学学八股\n#### ReentrantReadWriteLock\n- 是一个读写锁的实现，在内部维护了一对关联的锁：一个共享的读锁和一个独占的写锁。在”读多写少“的场景下，如果使用ReentrantLock这种普通互斥锁，会因为大量的饿读操作也必须串行执行而导致性能低下。读写锁则允许多个读线程并发访问，极大提升了这类场景下的系统吞吐量。\n\n  - 读锁：如果当前没有任何线程持有写锁，那么任意数量的线程都可以成功获取并持有读锁。即读-读共享。\n  - 写锁：只有在没有任何线程持有读锁或写锁的情况下，一个线程才有可能成功获取写锁。即写-写互斥，写-读互斥。\n\n- 可能的问题\n  - **“写饥饿”问题：** 在非公平、高并发读的场景下，如果读请求源源不断，写线程可能很难有机会获取到写锁，因为它总能看到有线程持有读锁。这就是所谓的“写饥饿”。**使用公平锁**是缓解这个问题的一种方式。\n  - **性能并非总是更优：** `ReentrantReadWriteLock` 的内部机制比 `ReentrantLock` 复杂得多，因此在**读写竞争不明显**或者**并发度不高**的情况下，它的开销可能会比简单的互斥锁更大。不要盲目使用，只有在明确的“读多写少”且存在性能瓶颈的场景下，它才是最佳选择。","source":"_posts/1-秒杀项目1.1-读写分离.md","raw":"---\ntitle: 1-秒杀项目1.1-读写分离\ntags: [Spring Boot,高并发,JUC]\ncategories: [项目实战]\nposter:\n  topic: 标题上方的小字\n  headline: 大标题\n  caption: 标题下方的小字\n  color: 标题颜色\ndate: 2025-10-01 16:44:13\ndescription: 重新起航版\ncover:\nbanner:\nsticky:\nmermaid:\nkatex:\nmathjax:\ntopic:\nauthor:\nreferences:\ncomments:\nindexing:\nbreadcrumb:\nleftbar:\nrightbar:\nh1:\ntype: tech\n---\n\n### 一、最初的构想：引入读写锁\n- 在秒杀开始前，有成千上万的用户疯狂刷新商品详情页，他们只是想看看库存还剩下多少，即进行读操作。在当前的实现下，大量的读请求也必须排队等待获取ReentrantLock，严重影响了用户体验。这是一个典型的“读多写少”的场景，所以引入读写锁。\n#### 改写代码\n- 重构SeckillService，将业务逻辑拆分出两个核心方法：\n  - checkStock(): 专门用于查询库存，使用读锁。\n  \n  ```Java\n  /*\n    * 新增方法，用于查询商品库存，专门用于处理读请求\n    * 使用读写锁中的读锁，允许并发读取，互不堵塞\n  */\n  public Integer checkStock(Long productId) {\n    log.info(\"线程 {} 尝试获取读锁...\", Thread.currentThread().getName());\n    readLock.lock(); // 读操作上读锁\n    log.info(\"线程 {} 成功获取到读锁\", Thread.currentThread().getName());\n    try {\n        Optional<Product> productOpt = productRepository.findById(productId);\n        if (!productOpt.isPresent()) {\n            throw new RuntimeException(\"商品不存在\");\n        }\n        log.info(\"线程 {} 读取库存为: {}\", Thread.currentThread().getName(), productOpt.get().getStock());\n        return productOpt.get().getStock();\n    } finally {\n        log.info(\"线程 {} 准备释放读锁.\", Thread.currentThread().getName());\n        readLock.unlock();\n    }\n  }\n  ```\n  - processSeckill(): 负责执行秒杀下单，使用写锁\n   ```Java\n    public String processSeckill(Long productId, Long userId) {\n        log.info(\"线程 {} 尝试获取写锁...\", Thread.currentThread().getName());\n        writeLock.lock(); // 2. 秒杀操作上写锁，确保互斥\n        log.info(\"线程 {} 成功获取到写锁\", Thread.currentThread().getName());\n        // 3. 定义事务\n        DefaultTransactionDefinition def = new DefaultTransactionDefinition();\n        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n        // 4. 开启事务\n        TransactionStatus status = transactionManager.getTransaction(def);\n\n        try {\n            // ...所有业务逻辑，和之前一样\n            // 5. 【关键】在锁释放前，手动提交事务\n            transactionManager.commit(status);\n            log.info(\"线程 {} 秒杀成功，提交事务。\", Thread.currentThread().getName());\n\n            return \"秒杀成功！订单创建中...\";\n        } catch (Exception e) {\n            // 6. 如果发生任何异常，手动回滚事务\n            transactionManager.rollback(status);\n            log.error(\"线程 {} 秒杀失败: {}\", Thread.currentThread().getName(), e.getMessage());\n            // 将异常信息返回或记录日志\n            return e.getMessage();\n        } finally {\n            // 7. 最后，释放锁\n            log.info(\"线程 {} 准备释放写锁.\", Thread.currentThread().getName());\n            writeLock.unlock();\n        }\n    }\n  ```\n- 同时，我也在 Controller 层为查询库存新增了一个 GET 方式的 API 接口。\n\n#### JMeter设置\n- **线程组一：读请求**\n  - **线程数：**  **500**。\n  - **Ramp-up:** 1\n  - **循环次数:** 10 \n  - 在该线程组下，创建一个 HTTP 请求，指向**读接口**：`GET /seckill/stock/1`\n- **线程组二：写请求**\n  - **线程数：**  **200** \n  - **Ramp-up:** 1\n  - **循环次数:** 1\n  - 在该线程组下，创建之前配置好的、带计数器的 HTTP 请求，指向**写接口**：`POST /seckill/1?userId=${uniqueUserId}`\n**同时启动压测**：在 JMeter 中，同时运行多个线程组。\n\n#### 压测结果与分析\n- 结果：读请求均为库存为0;写请求正常，数据库显示，库存数为0，订单数新建100。\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510011912013.png 读请求 %}\n- 分析： 瞬时的大量写请求，在一个极端的时间窗口内将库存扣减完毕。读请求因为写锁被阻塞，等到它们能够被执行时，秒杀已经结束。\n### 二、改进：并发测试场景设计\n#### 调整JMeter设置\n  由于200个/500个线程数太多，在日志中无法回看到最初的日志信息，所以修改线程数，便于观察。\n**“写请求”线程组：**\n- **线程数:** 20\n- **Ramp-up Period:** 从 `1` 改成 `20`。\n  - **作用：** 这意味着 JMeter 会在20秒内“缓慢地”启动这200个线程，大约每1秒启动一个。这给了读请求在两个写请求之间“插进来”的机会。\n- **循环次数 (Loop Count):** 1 \n\n**“读请求”线程组：**\n\n- **线程数:** 50\n- **Ramp-up Period:** 也改成 `20`。\n- **循环次数:** 保持在 `10` 。\n\n**【关键】为两个线程组设置“调度器”：**\n- 在两个线程组的配置界面下方，找到并勾选 **“调度器”**。\n- 在“**持续时间**”中，输入 `30`。\n  - **作用：** 这会强制两个线程组都在运行30秒后自动停止。这能确保读写请求在同一个时间窗口内并发执行。\n#### 压测结果与分析\n- 结果：读请求在日志中能够显示出库存数逐渐减少，写请求正常，且日志有如下模式，体现了读写锁“读共享、写独占”的理论：\n一次写 -> 一大批读（读到的值都一样） -> 又一次写 -> 又一大批读（读到的新值都一样）...\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510011920654.png 日志信息 %}\n\n### 学学八股\n#### ReentrantReadWriteLock\n- 是一个读写锁的实现，在内部维护了一对关联的锁：一个共享的读锁和一个独占的写锁。在”读多写少“的场景下，如果使用ReentrantLock这种普通互斥锁，会因为大量的饿读操作也必须串行执行而导致性能低下。读写锁则允许多个读线程并发访问，极大提升了这类场景下的系统吞吐量。\n\n  - 读锁：如果当前没有任何线程持有写锁，那么任意数量的线程都可以成功获取并持有读锁。即读-读共享。\n  - 写锁：只有在没有任何线程持有读锁或写锁的情况下，一个线程才有可能成功获取写锁。即写-写互斥，写-读互斥。\n\n- 可能的问题\n  - **“写饥饿”问题：** 在非公平、高并发读的场景下，如果读请求源源不断，写线程可能很难有机会获取到写锁，因为它总能看到有线程持有读锁。这就是所谓的“写饥饿”。**使用公平锁**是缓解这个问题的一种方式。\n  - **性能并非总是更优：** `ReentrantReadWriteLock` 的内部机制比 `ReentrantLock` 复杂得多，因此在**读写竞争不明显**或者**并发度不高**的情况下，它的开销可能会比简单的互斥锁更大。不要盲目使用，只有在明确的“读多写少”且存在性能瓶颈的场景下，它才是最佳选择。","slug":"1-秒杀项目1.1-读写分离","published":1,"updated":"2025-10-01T11:38:36.755Z","layout":"post","photos":[],"_id":"cmgdn5rgy00030wuzg5ph6qm6","content":"<h3 id=\"一、最初的构想：引入读写锁\"><a href=\"#一、最初的构想：引入读写锁\" class=\"headerlink\" title=\"一、最初的构想：引入读写锁\"></a>一、最初的构想：引入读写锁</h3><ul>\n<li>在秒杀开始前，有成千上万的用户疯狂刷新商品详情页，他们只是想看看库存还剩下多少，即进行读操作。在当前的实现下，大量的读请求也必须排队等待获取ReentrantLock，严重影响了用户体验。这是一个典型的“读多写少”的场景，所以引入读写锁。</li>\n</ul>\n<h4 id=\"改写代码\"><a href=\"#改写代码\" class=\"headerlink\" title=\"改写代码\"></a>改写代码</h4><ul>\n<li><p>重构SeckillService，将业务逻辑拆分出两个核心方法：</p>\n<ul>\n<li>checkStock(): 专门用于查询库存，使用读锁。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  * 新增方法，用于查询商品库存，专门用于处理读请求</span></span><br><span class=\"line\"><span class=\"comment\">  * 使用读写锁中的读锁，允许并发读取，互不堵塞</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Integer <span class=\"title function_\">checkStock</span><span class=\"params\">(Long productId)</span> &#123;</span><br><span class=\"line\">  log.info(<span class=\"string\">&quot;线程 &#123;&#125; 尝试获取读锁...&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">  readLock.lock(); <span class=\"comment\">// 读操作上读锁</span></span><br><span class=\"line\">  log.info(<span class=\"string\">&quot;线程 &#123;&#125; 成功获取到读锁&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      Optional&lt;Product&gt; productOpt = productRepository.findById(productId);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!productOpt.isPresent()) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;商品不存在&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      log.info(<span class=\"string\">&quot;线程 &#123;&#125; 读取库存为: &#123;&#125;&quot;</span>, Thread.currentThread().getName(), productOpt.get().getStock());</span><br><span class=\"line\">      <span class=\"keyword\">return</span> productOpt.get().getStock();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      log.info(<span class=\"string\">&quot;线程 &#123;&#125; 准备释放读锁.&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">      readLock.unlock();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>processSeckill(): 负责执行秒杀下单，使用写锁 <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;线程 &#123;&#125; 尝试获取写锁...&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">    writeLock.lock(); <span class=\"comment\">// 2. 秒杀操作上写锁，确保互斥</span></span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;线程 &#123;&#125; 成功获取到写锁&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">    <span class=\"comment\">// 3. 定义事务</span></span><br><span class=\"line\">    <span class=\"type\">DefaultTransactionDefinition</span> <span class=\"variable\">def</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultTransactionDefinition</span>();</span><br><span class=\"line\">    def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class=\"line\">    <span class=\"comment\">// 4. 开启事务</span></span><br><span class=\"line\">    <span class=\"type\">TransactionStatus</span> <span class=\"variable\">status</span> <span class=\"operator\">=</span> transactionManager.getTransaction(def);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...所有业务逻辑，和之前一样</span></span><br><span class=\"line\">        <span class=\"comment\">// 5. 【关键】在锁释放前，手动提交事务</span></span><br><span class=\"line\">        transactionManager.commit(status);</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;线程 &#123;&#125; 秒杀成功，提交事务。&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！订单创建中...&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 6. 如果发生任何异常，手动回滚事务</span></span><br><span class=\"line\">        transactionManager.rollback(status);</span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;线程 &#123;&#125; 秒杀失败: &#123;&#125;&quot;</span>, Thread.currentThread().getName(), e.getMessage());</span><br><span class=\"line\">        <span class=\"comment\">// 将异常信息返回或记录日志</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> e.getMessage();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 7. 最后，释放锁</span></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;线程 &#123;&#125; 准备释放写锁.&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">        writeLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>同时，我也在 Controller 层为查询库存新增了一个 GET 方式的 API 接口。</p>\n</li>\n</ul>\n<h4 id=\"JMeter设置\"><a href=\"#JMeter设置\" class=\"headerlink\" title=\"JMeter设置\"></a>JMeter设置</h4><ul>\n<li><strong>线程组一：读请求</strong><ul>\n<li><strong>线程数：</strong>  <strong>500</strong>。</li>\n<li><strong>Ramp-up:</strong> 1</li>\n<li><strong>循环次数:</strong> 10 </li>\n<li>在该线程组下，创建一个 HTTP 请求，指向<strong>读接口</strong>：<code>GET /seckill/stock/1</code></li>\n</ul>\n</li>\n<li><strong>线程组二：写请求</strong><ul>\n<li><strong>线程数：</strong>  <strong>200</strong> </li>\n<li><strong>Ramp-up:</strong> 1</li>\n<li><strong>循环次数:</strong> 1</li>\n<li>在该线程组下，创建之前配置好的、带计数器的 HTTP 请求，指向<strong>写接口</strong>：<code>POST /seckill/1?userId=$&#123;uniqueUserId&#125;</code><br><strong>同时启动压测</strong>：在 JMeter 中，同时运行多个线程组。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"压测结果与分析\"><a href=\"#压测结果与分析\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li>结果：读请求均为库存为0;写请求正常，数据库显示，库存数为0，订单数新建100。<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510011912013.png\" alt=\"读请求\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">读请求</span></div></div></li>\n<li>分析： 瞬时的大量写请求，在一个极端的时间窗口内将库存扣减完毕。读请求因为写锁被阻塞，等到它们能够被执行时，秒杀已经结束。</li>\n</ul>\n<h3 id=\"二、改进：并发测试场景设计\"><a href=\"#二、改进：并发测试场景设计\" class=\"headerlink\" title=\"二、改进：并发测试场景设计\"></a>二、改进：并发测试场景设计</h3><h4 id=\"调整JMeter设置\"><a href=\"#调整JMeter设置\" class=\"headerlink\" title=\"调整JMeter设置\"></a>调整JMeter设置</h4><p>  由于200个&#x2F;500个线程数太多，在日志中无法回看到最初的日志信息，所以修改线程数，便于观察。<br><strong>“写请求”线程组：</strong></p>\n<ul>\n<li><strong>线程数:</strong> 20</li>\n<li><strong>Ramp-up Period:</strong> 从 <code>1</code> 改成 <code>20</code>。<ul>\n<li><strong>作用：</strong> 这意味着 JMeter 会在20秒内“缓慢地”启动这200个线程，大约每1秒启动一个。这给了读请求在两个写请求之间“插进来”的机会。</li>\n</ul>\n</li>\n<li><strong>循环次数 (Loop Count):</strong> 1</li>\n</ul>\n<p><strong>“读请求”线程组：</strong></p>\n<ul>\n<li><strong>线程数:</strong> 50</li>\n<li><strong>Ramp-up Period:</strong> 也改成 <code>20</code>。</li>\n<li><strong>循环次数:</strong> 保持在 <code>10</code> 。</li>\n</ul>\n<p><strong>【关键】为两个线程组设置“调度器”：</strong></p>\n<ul>\n<li>在两个线程组的配置界面下方，找到并勾选 <strong>“调度器”</strong>。</li>\n<li>在“<strong>持续时间</strong>”中，输入 <code>30</code>。<ul>\n<li><strong>作用：</strong> 这会强制两个线程组都在运行30秒后自动停止。这能确保读写请求在同一个时间窗口内并发执行。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"压测结果与分析-1\"><a href=\"#压测结果与分析-1\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li>结果：读请求在日志中能够显示出库存数逐渐减少，写请求正常，且日志有如下模式，体现了读写锁“读共享、写独占”的理论：<br>一次写 -&gt; 一大批读（读到的值都一样） -&gt; 又一次写 -&gt; 又一大批读（读到的新值都一样）…<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510011920654.png\" alt=\"日志信息\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">日志信息</span></div></div></li>\n</ul>\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"ReentrantReadWriteLock\"><a href=\"#ReentrantReadWriteLock\" class=\"headerlink\" title=\"ReentrantReadWriteLock\"></a>ReentrantReadWriteLock</h4><ul>\n<li><p>是一个读写锁的实现，在内部维护了一对关联的锁：一个共享的读锁和一个独占的写锁。在”读多写少“的场景下，如果使用ReentrantLock这种普通互斥锁，会因为大量的饿读操作也必须串行执行而导致性能低下。读写锁则允许多个读线程并发访问，极大提升了这类场景下的系统吞吐量。</p>\n<ul>\n<li>读锁：如果当前没有任何线程持有写锁，那么任意数量的线程都可以成功获取并持有读锁。即读-读共享。</li>\n<li>写锁：只有在没有任何线程持有读锁或写锁的情况下，一个线程才有可能成功获取写锁。即写-写互斥，写-读互斥。</li>\n</ul>\n</li>\n<li><p>可能的问题</p>\n<ul>\n<li><strong>“写饥饿”问题：</strong> 在非公平、高并发读的场景下，如果读请求源源不断，写线程可能很难有机会获取到写锁，因为它总能看到有线程持有读锁。这就是所谓的“写饥饿”。<strong>使用公平锁</strong>是缓解这个问题的一种方式。</li>\n<li><strong>性能并非总是更优：</strong> <code>ReentrantReadWriteLock</code> 的内部机制比 <code>ReentrantLock</code> 复杂得多，因此在<strong>读写竞争不明显</strong>或者<strong>并发度不高</strong>的情况下，它的开销可能会比简单的互斥锁更大。不要盲目使用，只有在明确的“读多写少”且存在性能瓶颈的场景下，它才是最佳选择。</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"一、最初的构想：引入读写锁\"><a href=\"#一、最初的构想：引入读写锁\" class=\"headerlink\" title=\"一、最初的构想：引入读写锁\"></a>一、最初的构想：引入读写锁</h3><ul>\n<li>在秒杀开始前，有成千上万的用户疯狂刷新商品详情页，他们只是想看看库存还剩下多少，即进行读操作。在当前的实现下，大量的读请求也必须排队等待获取ReentrantLock，严重影响了用户体验。这是一个典型的“读多写少”的场景，所以引入读写锁。</li>\n</ul>\n<h4 id=\"改写代码\"><a href=\"#改写代码\" class=\"headerlink\" title=\"改写代码\"></a>改写代码</h4><ul>\n<li><p>重构SeckillService，将业务逻辑拆分出两个核心方法：</p>\n<ul>\n<li>checkStock(): 专门用于查询库存，使用读锁。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  * 新增方法，用于查询商品库存，专门用于处理读请求</span></span><br><span class=\"line\"><span class=\"comment\">  * 使用读写锁中的读锁，允许并发读取，互不堵塞</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Integer <span class=\"title function_\">checkStock</span><span class=\"params\">(Long productId)</span> &#123;</span><br><span class=\"line\">  log.info(<span class=\"string\">&quot;线程 &#123;&#125; 尝试获取读锁...&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">  readLock.lock(); <span class=\"comment\">// 读操作上读锁</span></span><br><span class=\"line\">  log.info(<span class=\"string\">&quot;线程 &#123;&#125; 成功获取到读锁&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      Optional&lt;Product&gt; productOpt = productRepository.findById(productId);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!productOpt.isPresent()) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;商品不存在&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      log.info(<span class=\"string\">&quot;线程 &#123;&#125; 读取库存为: &#123;&#125;&quot;</span>, Thread.currentThread().getName(), productOpt.get().getStock());</span><br><span class=\"line\">      <span class=\"keyword\">return</span> productOpt.get().getStock();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      log.info(<span class=\"string\">&quot;线程 &#123;&#125; 准备释放读锁.&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">      readLock.unlock();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>processSeckill(): 负责执行秒杀下单，使用写锁 <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;线程 &#123;&#125; 尝试获取写锁...&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">    writeLock.lock(); <span class=\"comment\">// 2. 秒杀操作上写锁，确保互斥</span></span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;线程 &#123;&#125; 成功获取到写锁&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">    <span class=\"comment\">// 3. 定义事务</span></span><br><span class=\"line\">    <span class=\"type\">DefaultTransactionDefinition</span> <span class=\"variable\">def</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultTransactionDefinition</span>();</span><br><span class=\"line\">    def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class=\"line\">    <span class=\"comment\">// 4. 开启事务</span></span><br><span class=\"line\">    <span class=\"type\">TransactionStatus</span> <span class=\"variable\">status</span> <span class=\"operator\">=</span> transactionManager.getTransaction(def);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...所有业务逻辑，和之前一样</span></span><br><span class=\"line\">        <span class=\"comment\">// 5. 【关键】在锁释放前，手动提交事务</span></span><br><span class=\"line\">        transactionManager.commit(status);</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;线程 &#123;&#125; 秒杀成功，提交事务。&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;秒杀成功！订单创建中...&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 6. 如果发生任何异常，手动回滚事务</span></span><br><span class=\"line\">        transactionManager.rollback(status);</span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;线程 &#123;&#125; 秒杀失败: &#123;&#125;&quot;</span>, Thread.currentThread().getName(), e.getMessage());</span><br><span class=\"line\">        <span class=\"comment\">// 将异常信息返回或记录日志</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> e.getMessage();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 7. 最后，释放锁</span></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;线程 &#123;&#125; 准备释放写锁.&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">        writeLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>同时，我也在 Controller 层为查询库存新增了一个 GET 方式的 API 接口。</p>\n</li>\n</ul>\n<h4 id=\"JMeter设置\"><a href=\"#JMeter设置\" class=\"headerlink\" title=\"JMeter设置\"></a>JMeter设置</h4><ul>\n<li><strong>线程组一：读请求</strong><ul>\n<li><strong>线程数：</strong>  <strong>500</strong>。</li>\n<li><strong>Ramp-up:</strong> 1</li>\n<li><strong>循环次数:</strong> 10 </li>\n<li>在该线程组下，创建一个 HTTP 请求，指向<strong>读接口</strong>：<code>GET /seckill/stock/1</code></li>\n</ul>\n</li>\n<li><strong>线程组二：写请求</strong><ul>\n<li><strong>线程数：</strong>  <strong>200</strong> </li>\n<li><strong>Ramp-up:</strong> 1</li>\n<li><strong>循环次数:</strong> 1</li>\n<li>在该线程组下，创建之前配置好的、带计数器的 HTTP 请求，指向<strong>写接口</strong>：<code>POST /seckill/1?userId=$&#123;uniqueUserId&#125;</code><br><strong>同时启动压测</strong>：在 JMeter 中，同时运行多个线程组。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"压测结果与分析\"><a href=\"#压测结果与分析\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li>结果：读请求均为库存为0;写请求正常，数据库显示，库存数为0，订单数新建100。<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510011912013.png\" alt=\"读请求\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">读请求</span></div></div></li>\n<li>分析： 瞬时的大量写请求，在一个极端的时间窗口内将库存扣减完毕。读请求因为写锁被阻塞，等到它们能够被执行时，秒杀已经结束。</li>\n</ul>\n<h3 id=\"二、改进：并发测试场景设计\"><a href=\"#二、改进：并发测试场景设计\" class=\"headerlink\" title=\"二、改进：并发测试场景设计\"></a>二、改进：并发测试场景设计</h3><h4 id=\"调整JMeter设置\"><a href=\"#调整JMeter设置\" class=\"headerlink\" title=\"调整JMeter设置\"></a>调整JMeter设置</h4><p>  由于200个&#x2F;500个线程数太多，在日志中无法回看到最初的日志信息，所以修改线程数，便于观察。<br><strong>“写请求”线程组：</strong></p>\n<ul>\n<li><strong>线程数:</strong> 20</li>\n<li><strong>Ramp-up Period:</strong> 从 <code>1</code> 改成 <code>20</code>。<ul>\n<li><strong>作用：</strong> 这意味着 JMeter 会在20秒内“缓慢地”启动这200个线程，大约每1秒启动一个。这给了读请求在两个写请求之间“插进来”的机会。</li>\n</ul>\n</li>\n<li><strong>循环次数 (Loop Count):</strong> 1</li>\n</ul>\n<p><strong>“读请求”线程组：</strong></p>\n<ul>\n<li><strong>线程数:</strong> 50</li>\n<li><strong>Ramp-up Period:</strong> 也改成 <code>20</code>。</li>\n<li><strong>循环次数:</strong> 保持在 <code>10</code> 。</li>\n</ul>\n<p><strong>【关键】为两个线程组设置“调度器”：</strong></p>\n<ul>\n<li>在两个线程组的配置界面下方，找到并勾选 <strong>“调度器”</strong>。</li>\n<li>在“<strong>持续时间</strong>”中，输入 <code>30</code>。<ul>\n<li><strong>作用：</strong> 这会强制两个线程组都在运行30秒后自动停止。这能确保读写请求在同一个时间窗口内并发执行。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"压测结果与分析-1\"><a href=\"#压测结果与分析-1\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li>结果：读请求在日志中能够显示出库存数逐渐减少，写请求正常，且日志有如下模式，体现了读写锁“读共享、写独占”的理论：<br>一次写 -&gt; 一大批读（读到的值都一样） -&gt; 又一次写 -&gt; 又一大批读（读到的新值都一样）…<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510011920654.png\" alt=\"日志信息\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">日志信息</span></div></div></li>\n</ul>\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"ReentrantReadWriteLock\"><a href=\"#ReentrantReadWriteLock\" class=\"headerlink\" title=\"ReentrantReadWriteLock\"></a>ReentrantReadWriteLock</h4><ul>\n<li><p>是一个读写锁的实现，在内部维护了一对关联的锁：一个共享的读锁和一个独占的写锁。在”读多写少“的场景下，如果使用ReentrantLock这种普通互斥锁，会因为大量的饿读操作也必须串行执行而导致性能低下。读写锁则允许多个读线程并发访问，极大提升了这类场景下的系统吞吐量。</p>\n<ul>\n<li>读锁：如果当前没有任何线程持有写锁，那么任意数量的线程都可以成功获取并持有读锁。即读-读共享。</li>\n<li>写锁：只有在没有任何线程持有读锁或写锁的情况下，一个线程才有可能成功获取写锁。即写-写互斥，写-读互斥。</li>\n</ul>\n</li>\n<li><p>可能的问题</p>\n<ul>\n<li><strong>“写饥饿”问题：</strong> 在非公平、高并发读的场景下，如果读请求源源不断，写线程可能很难有机会获取到写锁，因为它总能看到有线程持有读锁。这就是所谓的“写饥饿”。<strong>使用公平锁</strong>是缓解这个问题的一种方式。</li>\n<li><strong>性能并非总是更优：</strong> <code>ReentrantReadWriteLock</code> 的内部机制比 <code>ReentrantLock</code> 复杂得多，因此在<strong>读写竞争不明显</strong>或者<strong>并发度不高</strong>的情况下，它的开销可能会比简单的互斥锁更大。不要盲目使用，只有在明确的“读多写少”且存在性能瓶颈的场景下，它才是最佳选择。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"1-秒杀项目1.2-流量控制","poster":{"topic":"标题上方的小字","headline":"大标题","caption":"标题下方的小字","color":"标题颜色"},"date":"2025-10-03T03:54:25.000Z","description":"重新起航版","cover":null,"banner":null,"sticky":null,"mermaid":null,"katex":null,"mathjax":null,"topic":null,"author":null,"references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n### 场景升级：引入流量控制\n- 在V1.1中，通过读写锁优化了系统的读性能，但留下了一个隐患，如果秒杀的“写”操作本身很耗时（比如需要调用外部API、复杂的数据库操作等），那么大量的写请求会在WriteLock.lock()处排起长队。这些排队的线程会持续占用着宝贵的服务器线程资源，当数量过多时，足以耗尽资源导致整个应用崩溃。\n- V1.2的核心目标就是，在进入核心业务逻辑之前，先进行流量控制，只允许有限数量的请求进入，从而保护系统不被瞬时流量冲垮。\n#### 代码改写\n- 加入semaphore信号量\n- 加入`Thread.sleep(1000)`,模拟耗时的写操作。\n```Java\n  public String processSeckill(Long productId, Long userId) {\n    try {\n      // 带超时的尝试获取：在指定时间内获取不到，就放弃，避免无限等待\n      if (!semaphore.tryAcquire(3, TimeUnit.SECONDS)) {\n        return \"服务器繁忙，请稍后再试！\";\n      }\n      // 这模拟了这样一种场景：比如，每个秒杀请求都需要先调用一个外部、\n      // 独立的、耗时1秒的API（如风控验证），这个API调用本身是可以并行的。\n      try {\n          Thread.sleep(1000); \n      } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      writeLock.lock();\n      try {\n        // ... 之前的完整手动事务逻辑 ...\n      } finally {\n          writeLock.unlock();\n        }\n    } catch (InterruptedException e) {\n        // 线程在等待许可时被中断\n        Thread.currentThread().interrupt(); // 重新设置中断状态\n        return \"请求被中断，请重试。\";\n      } finally {\n          semaphore.release();\n        }               \n  }\n```\n- 最多10个线程可以同时获取到Semaphore许可。\n- 这十个线程同时开始执行Thread.sleep(1000)，模拟10个并行的慢操作。\n- 1秒后，这10个线程几乎同时结束sleep，然后去竞争writeLock。\n- WriteLock会确保他们一个一个地串行地完成数据库操作。\n#### JMeter设置\n- 保留写请求线程组\n- 线程数：50\n- Ramp-up Period : 1（模拟瞬时的大流量）\n- 循环次数：1\n#### 压测结果与分析\n- 预期结果：吞吐量应该为10/sec左右，即一秒钟内可以处理大约10个（由Semaphore信号量控制，而获取写锁之后的业务逻辑耗时极短）请求。\n- 结果：吞吐量为19.8/sec\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510031245633.png JMeter聚合报告%}\n- 分析：信号量泄漏-代码中的逻辑bug\n - 当其中的某一个线程获取许可失败，会`return \"服务器繁忙，请稍后再试！`，而无论try块中的代码是否正常结束，finally块中的代码都一定正常执行：`semaphore.release();`，也就是说，不管线程是否申请到了许可，都会执行finally块，即Semaphore内部的可用许可量可能会持续增加到10个以上。\n - 使最后的结果显示——吞吐量：19.8/sec。\n### 改进：代码中的逻辑bug\n#### 调整代码\n- 修复：只有在成功获取到资源后，才能进入释放资源的finally块。\n```Java\n  // 简化结构\n  public String processSeckill(...) {\n    if (semaphore.tryAcquire(...)) { // 1. 先过“信号量”这道门（10个并发名额）\n        try {\n            Thread.sleep(1000);      // 2. 执行耗时1秒的【可并行】操作\n            \n            writeLock.lock();        // 3. 再过“写锁”这道门（1个并发名额）\n            try {\n                // 4. 执行耗时极短的【串行】数据库操作\n            } finally {\n                writeLock.unlock();\n            }\n        } finally {\n            semaphore.release();\n        }\n    }\n}\n```\n#### 压测结果与分析\n- 结果：吞吐量为11.1/sec\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510031307073.png JMeter聚合报告 %}\n- 分析：\n  - 流程: 10个线程并行 sleep -> 串行 writeLock\n  - 总耗时 (处理50个请求): 50/10 批 * 1秒/批 ≈ 5秒\n  - 吞吐量: 50 / 5s ≈ 10/sec\n- 当没有Semaphore时，吞吐量为20/sec。\n  - 流程: 50个线程并行 sleep -> 串行 writeLock\n  - 总耗时 (处理50个请求): 1秒 (并行sleep) + 50 * 数据库耗时 ≈ 2~3秒\n  - 吞吐量: 50 / ~2.5s ≈ 20/sec\n\n- 证明了Semaphore流量控制的功能是生效的，它的作用不是提升性能，而是约束性能，防止过多的并发请求将系统资源耗尽，从而保证系统的稳定性。\n### 学学八股\n#### Semaphore\n- 是JUC包提供的一个并发流程控制工具，在内部维护了一组“许可”，线程在执行前必须先获取一个许可，执行完毕后再归还许可。当许可被全部分发完毕后，其他没有获取到许可的线程就必须等待，直到有线程释放许可。\n- 核心思想：通过有限的许可，来控制同一时间能够访问特定资源或执行特定代码块的线程数量。\n- 核心方法：\n  - `acquire()`:阻塞式的获取一个许可。如果当前没有可用的许可，线程将进入休眠状态并排队等待，直到有其他线程调用release()。\n  - `release()`:释放一个许可。信号量内部的许可计数会+1，如果此时有等待的线程，队列中的第一个线程将被唤醒。\n  - `tryAcquire()`:非阻塞式的尝试获取许可。立即返回，成功为true，失败为false。\n  - `tryAcquire(long timeout,TimeUnit unit)`:在指定时间内获取许可，如果超时仍未获取到，则返回false。\n- 底层原理：和ReentrantLock一样，Semaphore的底层也是基于AQS构建\n  - state：AQS内部的int state 变量，在Semaphore中代表了当前可用的许可数量。\n  - 获取许可：对应AQS的共享模式获取，线程会通过CAS操作尝试将state-1，如果减1之后state的值仍然大于等于0，则获取成功。否则获取失败，线程会被打包成节点放入等待队列中并挂起、\n  - 释放许可：对应AQS的共享模式释放，线程会通过CAS操作将state+1，释放成功后，会唤醒等待队列中的后继线程。\n- 关键特性与使用场景：\n  - Semaphore支持公平和非公平两种模式。\n  - 核心使用场景\n    - 流量控制/限流：防止瞬时大量请求冲垮下游服务。\n    - 管理有限的资源池：比如控制同时访问数据库的连接数，或者控制同时使用某个昂贵计算资源的任务数。","source":"_posts/1-秒杀项目1.2-流量控制.md","raw":"---\ntitle: 1-秒杀项目1.2-流量控制\ntags: [Spring Boot,高并发,JUC]\ncategories: [项目实战]\nposter:\n  topic: 标题上方的小字\n  headline: 大标题\n  caption: 标题下方的小字\n  color: 标题颜色\ndate: 2025-10-03 11:54:25\ndescription: 重新起航版\ncover:\nbanner:\nsticky:\nmermaid:\nkatex:\nmathjax:\ntopic:\nauthor:\nreferences:\ncomments:\nindexing:\nbreadcrumb:\nleftbar:\nrightbar:\nh1:\ntype: tech\n---\n\n### 场景升级：引入流量控制\n- 在V1.1中，通过读写锁优化了系统的读性能，但留下了一个隐患，如果秒杀的“写”操作本身很耗时（比如需要调用外部API、复杂的数据库操作等），那么大量的写请求会在WriteLock.lock()处排起长队。这些排队的线程会持续占用着宝贵的服务器线程资源，当数量过多时，足以耗尽资源导致整个应用崩溃。\n- V1.2的核心目标就是，在进入核心业务逻辑之前，先进行流量控制，只允许有限数量的请求进入，从而保护系统不被瞬时流量冲垮。\n#### 代码改写\n- 加入semaphore信号量\n- 加入`Thread.sleep(1000)`,模拟耗时的写操作。\n```Java\n  public String processSeckill(Long productId, Long userId) {\n    try {\n      // 带超时的尝试获取：在指定时间内获取不到，就放弃，避免无限等待\n      if (!semaphore.tryAcquire(3, TimeUnit.SECONDS)) {\n        return \"服务器繁忙，请稍后再试！\";\n      }\n      // 这模拟了这样一种场景：比如，每个秒杀请求都需要先调用一个外部、\n      // 独立的、耗时1秒的API（如风控验证），这个API调用本身是可以并行的。\n      try {\n          Thread.sleep(1000); \n      } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      writeLock.lock();\n      try {\n        // ... 之前的完整手动事务逻辑 ...\n      } finally {\n          writeLock.unlock();\n        }\n    } catch (InterruptedException e) {\n        // 线程在等待许可时被中断\n        Thread.currentThread().interrupt(); // 重新设置中断状态\n        return \"请求被中断，请重试。\";\n      } finally {\n          semaphore.release();\n        }               \n  }\n```\n- 最多10个线程可以同时获取到Semaphore许可。\n- 这十个线程同时开始执行Thread.sleep(1000)，模拟10个并行的慢操作。\n- 1秒后，这10个线程几乎同时结束sleep，然后去竞争writeLock。\n- WriteLock会确保他们一个一个地串行地完成数据库操作。\n#### JMeter设置\n- 保留写请求线程组\n- 线程数：50\n- Ramp-up Period : 1（模拟瞬时的大流量）\n- 循环次数：1\n#### 压测结果与分析\n- 预期结果：吞吐量应该为10/sec左右，即一秒钟内可以处理大约10个（由Semaphore信号量控制，而获取写锁之后的业务逻辑耗时极短）请求。\n- 结果：吞吐量为19.8/sec\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510031245633.png JMeter聚合报告%}\n- 分析：信号量泄漏-代码中的逻辑bug\n - 当其中的某一个线程获取许可失败，会`return \"服务器繁忙，请稍后再试！`，而无论try块中的代码是否正常结束，finally块中的代码都一定正常执行：`semaphore.release();`，也就是说，不管线程是否申请到了许可，都会执行finally块，即Semaphore内部的可用许可量可能会持续增加到10个以上。\n - 使最后的结果显示——吞吐量：19.8/sec。\n### 改进：代码中的逻辑bug\n#### 调整代码\n- 修复：只有在成功获取到资源后，才能进入释放资源的finally块。\n```Java\n  // 简化结构\n  public String processSeckill(...) {\n    if (semaphore.tryAcquire(...)) { // 1. 先过“信号量”这道门（10个并发名额）\n        try {\n            Thread.sleep(1000);      // 2. 执行耗时1秒的【可并行】操作\n            \n            writeLock.lock();        // 3. 再过“写锁”这道门（1个并发名额）\n            try {\n                // 4. 执行耗时极短的【串行】数据库操作\n            } finally {\n                writeLock.unlock();\n            }\n        } finally {\n            semaphore.release();\n        }\n    }\n}\n```\n#### 压测结果与分析\n- 结果：吞吐量为11.1/sec\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510031307073.png JMeter聚合报告 %}\n- 分析：\n  - 流程: 10个线程并行 sleep -> 串行 writeLock\n  - 总耗时 (处理50个请求): 50/10 批 * 1秒/批 ≈ 5秒\n  - 吞吐量: 50 / 5s ≈ 10/sec\n- 当没有Semaphore时，吞吐量为20/sec。\n  - 流程: 50个线程并行 sleep -> 串行 writeLock\n  - 总耗时 (处理50个请求): 1秒 (并行sleep) + 50 * 数据库耗时 ≈ 2~3秒\n  - 吞吐量: 50 / ~2.5s ≈ 20/sec\n\n- 证明了Semaphore流量控制的功能是生效的，它的作用不是提升性能，而是约束性能，防止过多的并发请求将系统资源耗尽，从而保证系统的稳定性。\n### 学学八股\n#### Semaphore\n- 是JUC包提供的一个并发流程控制工具，在内部维护了一组“许可”，线程在执行前必须先获取一个许可，执行完毕后再归还许可。当许可被全部分发完毕后，其他没有获取到许可的线程就必须等待，直到有线程释放许可。\n- 核心思想：通过有限的许可，来控制同一时间能够访问特定资源或执行特定代码块的线程数量。\n- 核心方法：\n  - `acquire()`:阻塞式的获取一个许可。如果当前没有可用的许可，线程将进入休眠状态并排队等待，直到有其他线程调用release()。\n  - `release()`:释放一个许可。信号量内部的许可计数会+1，如果此时有等待的线程，队列中的第一个线程将被唤醒。\n  - `tryAcquire()`:非阻塞式的尝试获取许可。立即返回，成功为true，失败为false。\n  - `tryAcquire(long timeout,TimeUnit unit)`:在指定时间内获取许可，如果超时仍未获取到，则返回false。\n- 底层原理：和ReentrantLock一样，Semaphore的底层也是基于AQS构建\n  - state：AQS内部的int state 变量，在Semaphore中代表了当前可用的许可数量。\n  - 获取许可：对应AQS的共享模式获取，线程会通过CAS操作尝试将state-1，如果减1之后state的值仍然大于等于0，则获取成功。否则获取失败，线程会被打包成节点放入等待队列中并挂起、\n  - 释放许可：对应AQS的共享模式释放，线程会通过CAS操作将state+1，释放成功后，会唤醒等待队列中的后继线程。\n- 关键特性与使用场景：\n  - Semaphore支持公平和非公平两种模式。\n  - 核心使用场景\n    - 流量控制/限流：防止瞬时大量请求冲垮下游服务。\n    - 管理有限的资源池：比如控制同时访问数据库的连接数，或者控制同时使用某个昂贵计算资源的任务数。","slug":"1-秒杀项目1.2-流量控制","published":1,"updated":"2025-10-03T05:41:11.847Z","layout":"post","photos":[],"_id":"cmgdn5rh100070wuzdsb4ef7s","content":"<h3 id=\"场景升级：引入流量控制\"><a href=\"#场景升级：引入流量控制\" class=\"headerlink\" title=\"场景升级：引入流量控制\"></a>场景升级：引入流量控制</h3><ul>\n<li>在V1.1中，通过读写锁优化了系统的读性能，但留下了一个隐患，如果秒杀的“写”操作本身很耗时（比如需要调用外部API、复杂的数据库操作等），那么大量的写请求会在WriteLock.lock()处排起长队。这些排队的线程会持续占用着宝贵的服务器线程资源，当数量过多时，足以耗尽资源导致整个应用崩溃。</li>\n<li>V1.2的核心目标就是，在进入核心业务逻辑之前，先进行流量控制，只允许有限数量的请求进入，从而保护系统不被瞬时流量冲垮。</li>\n</ul>\n<h4 id=\"代码改写\"><a href=\"#代码改写\" class=\"headerlink\" title=\"代码改写\"></a>代码改写</h4><ul>\n<li>加入semaphore信号量</li>\n<li>加入<code>Thread.sleep(1000)</code>,模拟耗时的写操作。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 带超时的尝试获取：在指定时间内获取不到，就放弃，避免无限等待</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!semaphore.tryAcquire(<span class=\"number\">3</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;服务器繁忙，请稍后再试！&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这模拟了这样一种场景：比如，每个秒杀请求都需要先调用一个外部、</span></span><br><span class=\"line\">    <span class=\"comment\">// 独立的、耗时1秒的API（如风控验证），这个API调用本身是可以并行的。</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        Thread.currentThread().interrupt();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    writeLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... 之前的完整手动事务逻辑 ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        writeLock.unlock();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 线程在等待许可时被中断</span></span><br><span class=\"line\">      Thread.currentThread().interrupt(); <span class=\"comment\">// 重新设置中断状态</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;请求被中断，请重试。&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        semaphore.release();</span><br><span class=\"line\">      &#125;               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>最多10个线程可以同时获取到Semaphore许可。</li>\n<li>这十个线程同时开始执行Thread.sleep(1000)，模拟10个并行的慢操作。</li>\n<li>1秒后，这10个线程几乎同时结束sleep，然后去竞争writeLock。</li>\n<li>WriteLock会确保他们一个一个地串行地完成数据库操作。</li>\n</ul>\n<h4 id=\"JMeter设置\"><a href=\"#JMeter设置\" class=\"headerlink\" title=\"JMeter设置\"></a>JMeter设置</h4><ul>\n<li>保留写请求线程组</li>\n<li>线程数：50</li>\n<li>Ramp-up Period : 1（模拟瞬时的大流量）</li>\n<li>循环次数：1</li>\n</ul>\n<h4 id=\"压测结果与分析\"><a href=\"#压测结果与分析\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li>预期结果：吞吐量应该为10&#x2F;sec左右，即一秒钟内可以处理大约10个（由Semaphore信号量控制，而获取写锁之后的业务逻辑耗时极短）请求。</li>\n<li>结果：吞吐量为19.8&#x2F;sec<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510031245633.png\" alt=\"JMeter聚合报告\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">JMeter聚合报告</span></div></div></li>\n<li>分析：信号量泄漏-代码中的逻辑bug</li>\n<li>当其中的某一个线程获取许可失败，会<code>return &quot;服务器繁忙，请稍后再试！</code>，而无论try块中的代码是否正常结束，finally块中的代码都一定正常执行：<code>semaphore.release();</code>，也就是说，不管线程是否申请到了许可，都会执行finally块，即Semaphore内部的可用许可量可能会持续增加到10个以上。</li>\n<li>使最后的结果显示——吞吐量：19.8&#x2F;sec。</li>\n</ul>\n<h3 id=\"改进：代码中的逻辑bug\"><a href=\"#改进：代码中的逻辑bug\" class=\"headerlink\" title=\"改进：代码中的逻辑bug\"></a>改进：代码中的逻辑bug</h3><h4 id=\"调整代码\"><a href=\"#调整代码\" class=\"headerlink\" title=\"调整代码\"></a>调整代码</h4><ul>\n<li>修复：只有在成功获取到资源后，才能进入释放资源的finally块。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 简化结构</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (semaphore.tryAcquire(...)) &#123; <span class=\"comment\">// 1. 先过“信号量”这道门（10个并发名额）</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);      <span class=\"comment\">// 2. 执行耗时1秒的【可并行】操作</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            writeLock.lock();        <span class=\"comment\">// 3. 再过“写锁”这道门（1个并发名额）</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 4. 执行耗时极短的【串行】数据库操作</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                writeLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            semaphore.release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"压测结果与分析-1\"><a href=\"#压测结果与分析-1\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li><p>结果：吞吐量为11.1&#x2F;sec</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510031307073.png\" alt=\"JMeter聚合报告\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">JMeter聚合报告</span></div></div></li>\n<li><p>分析：</p>\n<ul>\n<li>流程: 10个线程并行 sleep -&gt; 串行 writeLock</li>\n<li>总耗时 (处理50个请求): 50&#x2F;10 批 * 1秒&#x2F;批 ≈ 5秒</li>\n<li>吞吐量: 50 &#x2F; 5s ≈ 10&#x2F;sec</li>\n</ul>\n</li>\n<li><p>当没有Semaphore时，吞吐量为20&#x2F;sec。</p>\n<ul>\n<li>流程: 50个线程并行 sleep -&gt; 串行 writeLock</li>\n<li>总耗时 (处理50个请求): 1秒 (并行sleep) + 50 * 数据库耗时 ≈ 2~3秒</li>\n<li>吞吐量: 50 &#x2F; ~2.5s ≈ 20&#x2F;sec</li>\n</ul>\n</li>\n<li><p>证明了Semaphore流量控制的功能是生效的，它的作用不是提升性能，而是约束性能，防止过多的并发请求将系统资源耗尽，从而保证系统的稳定性。</p>\n</li>\n</ul>\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h4><ul>\n<li>是JUC包提供的一个并发流程控制工具，在内部维护了一组“许可”，线程在执行前必须先获取一个许可，执行完毕后再归还许可。当许可被全部分发完毕后，其他没有获取到许可的线程就必须等待，直到有线程释放许可。</li>\n<li>核心思想：通过有限的许可，来控制同一时间能够访问特定资源或执行特定代码块的线程数量。</li>\n<li>核心方法：<ul>\n<li><code>acquire()</code>:阻塞式的获取一个许可。如果当前没有可用的许可，线程将进入休眠状态并排队等待，直到有其他线程调用release()。</li>\n<li><code>release()</code>:释放一个许可。信号量内部的许可计数会+1，如果此时有等待的线程，队列中的第一个线程将被唤醒。</li>\n<li><code>tryAcquire()</code>:非阻塞式的尝试获取许可。立即返回，成功为true，失败为false。</li>\n<li><code>tryAcquire(long timeout,TimeUnit unit)</code>:在指定时间内获取许可，如果超时仍未获取到，则返回false。</li>\n</ul>\n</li>\n<li>底层原理：和ReentrantLock一样，Semaphore的底层也是基于AQS构建<ul>\n<li>state：AQS内部的int state 变量，在Semaphore中代表了当前可用的许可数量。</li>\n<li>获取许可：对应AQS的共享模式获取，线程会通过CAS操作尝试将state-1，如果减1之后state的值仍然大于等于0，则获取成功。否则获取失败，线程会被打包成节点放入等待队列中并挂起、</li>\n<li>释放许可：对应AQS的共享模式释放，线程会通过CAS操作将state+1，释放成功后，会唤醒等待队列中的后继线程。</li>\n</ul>\n</li>\n<li>关键特性与使用场景：<ul>\n<li>Semaphore支持公平和非公平两种模式。</li>\n<li>核心使用场景<ul>\n<li>流量控制&#x2F;限流：防止瞬时大量请求冲垮下游服务。</li>\n<li>管理有限的资源池：比如控制同时访问数据库的连接数，或者控制同时使用某个昂贵计算资源的任务数。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"场景升级：引入流量控制\"><a href=\"#场景升级：引入流量控制\" class=\"headerlink\" title=\"场景升级：引入流量控制\"></a>场景升级：引入流量控制</h3><ul>\n<li>在V1.1中，通过读写锁优化了系统的读性能，但留下了一个隐患，如果秒杀的“写”操作本身很耗时（比如需要调用外部API、复杂的数据库操作等），那么大量的写请求会在WriteLock.lock()处排起长队。这些排队的线程会持续占用着宝贵的服务器线程资源，当数量过多时，足以耗尽资源导致整个应用崩溃。</li>\n<li>V1.2的核心目标就是，在进入核心业务逻辑之前，先进行流量控制，只允许有限数量的请求进入，从而保护系统不被瞬时流量冲垮。</li>\n</ul>\n<h4 id=\"代码改写\"><a href=\"#代码改写\" class=\"headerlink\" title=\"代码改写\"></a>代码改写</h4><ul>\n<li>加入semaphore信号量</li>\n<li>加入<code>Thread.sleep(1000)</code>,模拟耗时的写操作。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 带超时的尝试获取：在指定时间内获取不到，就放弃，避免无限等待</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!semaphore.tryAcquire(<span class=\"number\">3</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;服务器繁忙，请稍后再试！&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这模拟了这样一种场景：比如，每个秒杀请求都需要先调用一个外部、</span></span><br><span class=\"line\">    <span class=\"comment\">// 独立的、耗时1秒的API（如风控验证），这个API调用本身是可以并行的。</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        Thread.currentThread().interrupt();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    writeLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ... 之前的完整手动事务逻辑 ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        writeLock.unlock();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 线程在等待许可时被中断</span></span><br><span class=\"line\">      Thread.currentThread().interrupt(); <span class=\"comment\">// 重新设置中断状态</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;请求被中断，请重试。&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        semaphore.release();</span><br><span class=\"line\">      &#125;               </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>最多10个线程可以同时获取到Semaphore许可。</li>\n<li>这十个线程同时开始执行Thread.sleep(1000)，模拟10个并行的慢操作。</li>\n<li>1秒后，这10个线程几乎同时结束sleep，然后去竞争writeLock。</li>\n<li>WriteLock会确保他们一个一个地串行地完成数据库操作。</li>\n</ul>\n<h4 id=\"JMeter设置\"><a href=\"#JMeter设置\" class=\"headerlink\" title=\"JMeter设置\"></a>JMeter设置</h4><ul>\n<li>保留写请求线程组</li>\n<li>线程数：50</li>\n<li>Ramp-up Period : 1（模拟瞬时的大流量）</li>\n<li>循环次数：1</li>\n</ul>\n<h4 id=\"压测结果与分析\"><a href=\"#压测结果与分析\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li>预期结果：吞吐量应该为10&#x2F;sec左右，即一秒钟内可以处理大约10个（由Semaphore信号量控制，而获取写锁之后的业务逻辑耗时极短）请求。</li>\n<li>结果：吞吐量为19.8&#x2F;sec<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510031245633.png\" alt=\"JMeter聚合报告\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">JMeter聚合报告</span></div></div></li>\n<li>分析：信号量泄漏-代码中的逻辑bug</li>\n<li>当其中的某一个线程获取许可失败，会<code>return &quot;服务器繁忙，请稍后再试！</code>，而无论try块中的代码是否正常结束，finally块中的代码都一定正常执行：<code>semaphore.release();</code>，也就是说，不管线程是否申请到了许可，都会执行finally块，即Semaphore内部的可用许可量可能会持续增加到10个以上。</li>\n<li>使最后的结果显示——吞吐量：19.8&#x2F;sec。</li>\n</ul>\n<h3 id=\"改进：代码中的逻辑bug\"><a href=\"#改进：代码中的逻辑bug\" class=\"headerlink\" title=\"改进：代码中的逻辑bug\"></a>改进：代码中的逻辑bug</h3><h4 id=\"调整代码\"><a href=\"#调整代码\" class=\"headerlink\" title=\"调整代码\"></a>调整代码</h4><ul>\n<li>修复：只有在成功获取到资源后，才能进入释放资源的finally块。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 简化结构</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">processSeckill</span><span class=\"params\">(...)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (semaphore.tryAcquire(...)) &#123; <span class=\"comment\">// 1. 先过“信号量”这道门（10个并发名额）</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);      <span class=\"comment\">// 2. 执行耗时1秒的【可并行】操作</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            writeLock.lock();        <span class=\"comment\">// 3. 再过“写锁”这道门（1个并发名额）</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 4. 执行耗时极短的【串行】数据库操作</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                writeLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            semaphore.release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"压测结果与分析-1\"><a href=\"#压测结果与分析-1\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li><p>结果：吞吐量为11.1&#x2F;sec</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202510031307073.png\" alt=\"JMeter聚合报告\"/></div><div class=\"image-meta\"><span class=\"image-caption center\">JMeter聚合报告</span></div></div></li>\n<li><p>分析：</p>\n<ul>\n<li>流程: 10个线程并行 sleep -&gt; 串行 writeLock</li>\n<li>总耗时 (处理50个请求): 50&#x2F;10 批 * 1秒&#x2F;批 ≈ 5秒</li>\n<li>吞吐量: 50 &#x2F; 5s ≈ 10&#x2F;sec</li>\n</ul>\n</li>\n<li><p>当没有Semaphore时，吞吐量为20&#x2F;sec。</p>\n<ul>\n<li>流程: 50个线程并行 sleep -&gt; 串行 writeLock</li>\n<li>总耗时 (处理50个请求): 1秒 (并行sleep) + 50 * 数据库耗时 ≈ 2~3秒</li>\n<li>吞吐量: 50 &#x2F; ~2.5s ≈ 20&#x2F;sec</li>\n</ul>\n</li>\n<li><p>证明了Semaphore流量控制的功能是生效的，它的作用不是提升性能，而是约束性能，防止过多的并发请求将系统资源耗尽，从而保证系统的稳定性。</p>\n</li>\n</ul>\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h4><ul>\n<li>是JUC包提供的一个并发流程控制工具，在内部维护了一组“许可”，线程在执行前必须先获取一个许可，执行完毕后再归还许可。当许可被全部分发完毕后，其他没有获取到许可的线程就必须等待，直到有线程释放许可。</li>\n<li>核心思想：通过有限的许可，来控制同一时间能够访问特定资源或执行特定代码块的线程数量。</li>\n<li>核心方法：<ul>\n<li><code>acquire()</code>:阻塞式的获取一个许可。如果当前没有可用的许可，线程将进入休眠状态并排队等待，直到有其他线程调用release()。</li>\n<li><code>release()</code>:释放一个许可。信号量内部的许可计数会+1，如果此时有等待的线程，队列中的第一个线程将被唤醒。</li>\n<li><code>tryAcquire()</code>:非阻塞式的尝试获取许可。立即返回，成功为true，失败为false。</li>\n<li><code>tryAcquire(long timeout,TimeUnit unit)</code>:在指定时间内获取许可，如果超时仍未获取到，则返回false。</li>\n</ul>\n</li>\n<li>底层原理：和ReentrantLock一样，Semaphore的底层也是基于AQS构建<ul>\n<li>state：AQS内部的int state 变量，在Semaphore中代表了当前可用的许可数量。</li>\n<li>获取许可：对应AQS的共享模式获取，线程会通过CAS操作尝试将state-1，如果减1之后state的值仍然大于等于0，则获取成功。否则获取失败，线程会被打包成节点放入等待队列中并挂起、</li>\n<li>释放许可：对应AQS的共享模式释放，线程会通过CAS操作将state+1，释放成功后，会唤醒等待队列中的后继线程。</li>\n</ul>\n</li>\n<li>关键特性与使用场景：<ul>\n<li>Semaphore支持公平和非公平两种模式。</li>\n<li>核心使用场景<ul>\n<li>流量控制&#x2F;限流：防止瞬时大量请求冲垮下游服务。</li>\n<li>管理有限的资源池：比如控制同时访问数据库的连接数，或者控制同时使用某个昂贵计算资源的任务数。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"1-秒杀项目1.3-异步处理和优化","poster":{"topic":"标题上方的小字","headline":"大标题","caption":"标题下方的小字","color":"标题颜色"},"date":"2025-10-03T12:58:06.000Z","description":"重新起航版","cover":null,"banner":null,"sticky":null,"mermaid":null,"katex":null,"mathjax":null,"topic":null,"author":null,"references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n### 用户体验：引入异步处理\n- 在V1.1和V1.2，通过读写锁和信号量，构建了一个数据相对正确，流量可控的秒杀系统。尽管后端相对稳定，但用户体验糟糕，同步阻塞的模式，意味着用户必须在浏览器前“转圈圈”，等待后端的耗时操作。\n- 在V1.3中，实现异步化，将用户请求与后端耗时任务解耦，实现用户的及时响应。\n#### 代码改写\n- 线程池，创建`ThreadPoolConfig.java`\n```Java\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport java.util.concurrent.*;\n\n@Configuration\npublic class ThreadPoolConfig {\n\n    @Bean\n    public ExecutorService seckillExecutorService() {\n    \n        // 手动实现一个简单的 ThreadFactory\n        ThreadFactory namedThreadFactory = r -> new Thread(\"seckill-thread-\" + r.hashCode());\n\n        // 创建线程池\n        ExecutorService pool = new ThreadPoolExecutor(\n                10,     // corePoolSize: 核心线程数，即长期保持的线程数\n                20,     // maximumPoolSize: 最大线程数\n                60L,    // keepAliveTime: 空闲线程的存活时间\n                TimeUnit.SECONDS, // 时间单位\n                new LinkedBlockingQueue<>(100), // workQueue: 任务队列，容量为100\n                namedThreadFactory, // threadFactory: 线程工厂，用于给线程命名\n                new ThreadPoolExecutor.AbortPolicy() // rejectedExecutionHandler: 拒绝策略\n        );\n        return pool;\n    }\n}\n```\n- 重构SeckillService，分离提交与执行\n```Java\n@Service\npublic class SeckillService {\n\n    @Autowired\n    private ExecutorService seckillExecutorService; // 1. 注入我们创建的线程池\n\n    // ... 其他属性保持不变 ...\n\n    /**\n     * 新的入口方法：负责接收请求并提交到线程池\n     * 这个方法会【立刻】返回，不会等待后台线程执行完毕\n     */\n    public String submitSeckillOrder(Long productId, Long userId) {\n        \n        // 2. 创建一个任务（Runnable）\n        Runnable task = () -> {\n            // 在这个任务中，调用我们之前那个耗时的、带锁的真实秒杀逻辑\n            executeSeckill(productId, userId);\n        };\n\n        // 3. 将任务提交给线程池\n        seckillExecutorService.submit(task);\n        \n        return \"请求已接收，正在排队处理中，请稍后查看订单状态。\";\n    }\n\n    /**\n     * 真实的秒杀执行逻辑，现在是一个私有方法\n     * 它会被后台线程池中的线程调用\n     * @param productId\n     * @param userId\n     */\n    private void executeSeckill(Long productId, Long userId) {\n        boolean acquired = false;\n        try {\n            acquired = semaphore.tryAcquire(3, TimeUnit.SECONDS);\n            if (!acquired) {\n                log.warn(\"线程 {} 获取信号量许可超时\", Thread.currentThread().getName());\n                return; // 获取不到许可，直接结束任务\n            }\n            // ... 省略了之前完整的、带 writeLock 和手动事务的业务逻辑 ...\n            // 注意：因为这个方法现在没有返回值了，你需要通过日志来记录成功或失败\n            // 比如在 commit 后 log.info(\"订单创建成功...\")\n            // 在 rollback 后 log.error(\"订单创建失败...\")\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            log.error(\"线程 {} 被中断\", Thread.currentThread().getName());\n        } finally {\n            if (acquired) {\n                semaphore.release();\n            }\n        }\n    }\n}\n```\n- 更新 SeckillController，调用新的“提交”方法。\n#### 压测结果与分析\n- JMeter设置与之前的版本相同，只执行写请求。\n- 结果：有120个线程成功请求到了线程池，80个失败请求。没有任何的库存减少和新订单的建立，并且在日志中没有任何关于申请信号量许可的信息。\n- 分析：\n  - 120个成功请求和80个失败请求：系统能够容纳的瞬时任务上限是20（正在执行）+100（排队等待）=120个，而剩下的80个失败请求对应的是因为线程池已满而被拒绝。\n  - 没有库存减少和新订单的建立：120个被线程池接收的任务，没有一个成功完成数据库操作。\n  - 日志中没有见到任何申请信号量许可的信息：甚至有可能没有进入`executeSeckill()`方法。类似于“当第200个请求被拒绝后，所有200个请求都结束了”\n- 原因：“守护线程”的提前退场\n  - 用户线程：通常创建的、执行核心任务的“前台线程”。JVM规则：只要还有一个用户线程没有执行完毕，JVM进程就必须等待，不能退出。\n  - 守护线程：特殊的“后台线程”，为其他线程服务。JVM规则：当程序中只剩下守护线程在运行时，JVM会认为所有核心工作已经全部完成，于是会退出并且终止所有仍在运行的守护线程。\n- 由于某种原因，在seckillExecutorService中创建的工作线程，被设置为了守护线程。\n#### 改进\n- 在创建线程时，明确设置为“用户线程”。\n```Java\n@Configuration\npublic class ThreadPoolConfig {\n\n    @Bean\n    public ExecutorService seckillExecutorService() {\n        ThreadFactory namedThreadFactory = r -> {\n            Thread t = new Thread(r);\n            // 【关键改动】将线程设置为非守护线程\n            t.setDaemon(false); \n            t.setName(\"seckill-thread-\" + t.hashCode());\n            return t;\n        };\n\n        // 创建线程池的其余代码保持不变\n        ExecutorService pool = new ThreadPoolExecutor(\n                10,\n                20,\n                60L,\n                TimeUnit.SECONDS,\n                new LinkedBlockingQueue<>(100),\n                namedThreadFactory,\n                new ThreadPoolExecutor.AbortPolicy()\n        );\n        return pool;\n    }\n}\n```\n- 在手动创建 Thread 对象后，调用了 t.setDaemon(false);。false 表示它是一个用户线程（非守护线程），这是 Java 线程的默认行为，但在这里我们明确地指定它，以覆盖任何可能的默认设置，确保万无一失。\n\n- 结果：库存减少至0，新增订单数100，数据正常。日志显示正常。\n\n### 单体应用的性能优化\n#### 数据库原子化更新、引入内存售罄标记\n- 使用“原子化SQL更新”替代Java锁，将检查库存和扣减库存合并为同一条SQL语句，并且引入内存售罄标记。数据库原子化更新利用了数据库的行锁来保证原子性，性能远高于在Java应用层加锁。引入内存售罄标记，直接拒绝已知的无效流量，保护了后端服务。\n- 修改 ProductRepository.java\n```Java\n@Repository\npublic interface ProductRepository extends JpaRepository<Product, Long> {\n\n    /**\n     * 【新增】原子化扣减库存的方法\n     * 使用 @Modifying 注解来告诉 Spring Data JPA 这是一个“修改”操作\n     * 使用 @Query 注解来定义我们的 JPQL 语句\n     * WHERE 子句中的 \"p.stock > 0\" 是关键，它在数据库层面保证了不会超卖\n     * @param productId 商品ID\n     * @return 返回受影响的行数，如果 > 0 表示更新成功，= 0 表示库存不足或商品不存在\n     */\n    @Modifying\n    @Query(\"UPDATE Product p SET p.stock = p.stock - 1 WHERE p.id = :productId AND p.stock > 0\")\n    int deductStock(@Param(\"productId\") Long productId);\n}\n```\n\n- 重构 SeckillService.java 的核心逻辑\n```Java\n@Service\npublic class SeckillService {\n    // ... 其他属性 ...\n\n    // 【移除】不再需要写锁了！\n    // private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock(true);\n    // private final Lock writeLock = rwLock.writeLock();\n\n    // ...\n\n    // 【新增】内存售罄标记\n    private volatile boolean isSoldOut = false;\n\n    public String submitSeckillOrder(Long productId, Long userId) {\n        // 【优化】在所有逻辑之前，先检查内存标记\n        if (isSoldOut) {\n            return \"商品已售罄（内存标记拦截）\";\n        }\n\n        // ... 之前的提交到线程池的逻辑保持不变 ...\n        // ...\n    }\n\n    private void executeSeckill(Long productId, Long userId) {\n        // ... Semaphore 的获取和释放逻辑保持不变 ...\n        boolean acquired = false;\n        try {\n            acquired = semaphore.tryAcquire(3, TimeUnit.SECONDS);\n            if (!acquired) {\n                // ...\n                return;\n            }\n\n            // 【移除】不再需要 Thread.sleep()\n            // Thread.sleep(1000);\n\n            // 【重构】调用新的、无锁的数据库操作方法\n            executeDbOperationsWithoutLock(productId, userId);\n\n        } catch (InterruptedException e) {\n            // ...\n        } finally {\n            if (acquired) {\n                semaphore.release();\n            }\n        }\n    }\n\n    // 【重构】创建一个新的、无锁的数据库操作方法\n    private void executeDbOperationsWithoutLock(Long productId, Long userId) {\n        // 【移除】不再需要 writeLock.lock()\n        DefaultTransactionDefinition def = new DefaultTransactionDefinition();\n        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n        TransactionStatus status = transactionManager.getTransaction(def);\n        try {\n            // 前置检查（重复下单等）依然可以保留\n            if (orderRepository.findByUserIdAndProductId(userId, productId) != null) {\n                throw new RuntimeException(\"您已秒杀过此商品，请勿重复下单\");\n            }\n            \n            // 1. 【核心改动】直接调用原子更新方法扣减库存\n            int result = productRepository.deductStock(productId);\n\n            // 2. 检查结果\n            if (result == 0) {\n                // 如果更新行数为0，说明库存不足\n                isSoldOut = true; // 【优化】设置内存售罄标记\n                throw new RuntimeException(\"商品已售罄\");\n            }\n\n            // 3. 如果扣减成功，才创建订单...\n\n            transactionManager.commit(status);\n            log.info(\"线程 {} 秒杀成功，提交事务。\", Thread.currentThread().getName());\n\n        } catch (Exception e) {\n            transactionManager.rollback(status);\n            log.error(\"线程 {} 秒杀失败，回滚事务: {}\", Thread.currentThread().getName(), e.getMessage());\n        }\n        // 【移除】不再需要 finally { writeLock.unlock() }\n    }\n}\n```\n#### 集成Spring Boot Actuator\n- 修改 pom.xml 文件\n- 在 <dependencies> 标签内，添加 Actuator 的 starter 依赖：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n- 修改 src/main/resources/application.properties 文件\n添加以下配置，来暴露所有的监控端点 (endpoints) 以供访问：\n\n```Properties\n# Spring Boot Actuator 配置\n# 暴露所有 Web 端点（在生产环境中应按需暴露，* 是为了开发方便）\nmanagement.endpoints.web.exposure.include=*\n# (可选) 让 health 端点总是显示详细信息\nmanagement.endpoint.health.show-details=always\n```\n\n### 学学八股\n#### ThreadPoolExecutor 线程池\n- 核心作用\n  - 降低资源消耗：通过复用已创建的线程，避免了频繁创建和销毁线程的巨大开销。\n  - 提高响应速度：任务到达时，可以直接使用池中的线程执行，省去了创建线程的时间。\n  - 提高客观理性：可以对线程进行统一的分配、监控和调优，防止无限制的创建线程耗尽系统资源。\n- 核心参数\n  - corePoolSize ：核心线程数，线程池长期维持的线程数量，即使它们处于空闲状态。\n  - maximumPoolSize ：最大线程数，线程池能够容纳的最大线程数量。当任务队列满了，且当前线程数小于最大线程数时，才会创建新线程。\n  - KeepAliveTime：空闲线程存活时间，当线程池中的数量大于corePoolSize时，多余的空闲线程在等待新任务时能够存活的最长时间。\n  - unit：时间单位\n  - workQueue：任务队列，用于存放等待执行的任务的阻塞队列。\n  - threadFactory： 线程工厂，用于创建新线程的工厂。\n  - rejectedExecutionHandler：拒绝策略，当任务队列和线程池都满了，新任务到来时所采取的策略。\n#### 原子化SQL更新\n- 核心思想：放弃在 Java 应用层使用锁（如 ReentrantLock）来保证“读-改-写”的原子性，而是将这个职责下推到数据库层面。\n- 底层原理：数据库的 InnoDB 引擎 会对符合 WHERE 条件的行加上行锁 (Row Lock)，从而天然地保证了该操作的原子性。\n#### Spring Boot Actuator\n- 核心作用：通过一系列的HTTP端点，暴露应用的内部运行情况。\n- Actuator 是构建可观测性系统的第一步。通过它暴露的 metrics 端点，可以与 Prometheus (数据采集) 和 Grafana (数据可视化) 等工具链集成，搭建出专业的监控仪表盘，实时监控 JVM 状态、数据库连接池、线程池活跃度等关键指标。","source":"_posts/1-秒杀项目1.3-异步处理和优化.md","raw":"---\ntitle: 1-秒杀项目1.3-异步处理和优化\ntags: [Spring Boot,高并发,JUC]\ncategories: [项目实战]\nposter:\n  topic: 标题上方的小字\n  headline: 大标题\n  caption: 标题下方的小字\n  color: 标题颜色\ndate: 2025-10-03 20:58:06\ndescription: 重新起航版\ncover:\nbanner:\nsticky:\nmermaid:\nkatex:\nmathjax:\ntopic:\nauthor:\nreferences:\ncomments:\nindexing:\nbreadcrumb:\nleftbar:\nrightbar:\nh1:\ntype: tech\n---\n\n### 用户体验：引入异步处理\n- 在V1.1和V1.2，通过读写锁和信号量，构建了一个数据相对正确，流量可控的秒杀系统。尽管后端相对稳定，但用户体验糟糕，同步阻塞的模式，意味着用户必须在浏览器前“转圈圈”，等待后端的耗时操作。\n- 在V1.3中，实现异步化，将用户请求与后端耗时任务解耦，实现用户的及时响应。\n#### 代码改写\n- 线程池，创建`ThreadPoolConfig.java`\n```Java\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport java.util.concurrent.*;\n\n@Configuration\npublic class ThreadPoolConfig {\n\n    @Bean\n    public ExecutorService seckillExecutorService() {\n    \n        // 手动实现一个简单的 ThreadFactory\n        ThreadFactory namedThreadFactory = r -> new Thread(\"seckill-thread-\" + r.hashCode());\n\n        // 创建线程池\n        ExecutorService pool = new ThreadPoolExecutor(\n                10,     // corePoolSize: 核心线程数，即长期保持的线程数\n                20,     // maximumPoolSize: 最大线程数\n                60L,    // keepAliveTime: 空闲线程的存活时间\n                TimeUnit.SECONDS, // 时间单位\n                new LinkedBlockingQueue<>(100), // workQueue: 任务队列，容量为100\n                namedThreadFactory, // threadFactory: 线程工厂，用于给线程命名\n                new ThreadPoolExecutor.AbortPolicy() // rejectedExecutionHandler: 拒绝策略\n        );\n        return pool;\n    }\n}\n```\n- 重构SeckillService，分离提交与执行\n```Java\n@Service\npublic class SeckillService {\n\n    @Autowired\n    private ExecutorService seckillExecutorService; // 1. 注入我们创建的线程池\n\n    // ... 其他属性保持不变 ...\n\n    /**\n     * 新的入口方法：负责接收请求并提交到线程池\n     * 这个方法会【立刻】返回，不会等待后台线程执行完毕\n     */\n    public String submitSeckillOrder(Long productId, Long userId) {\n        \n        // 2. 创建一个任务（Runnable）\n        Runnable task = () -> {\n            // 在这个任务中，调用我们之前那个耗时的、带锁的真实秒杀逻辑\n            executeSeckill(productId, userId);\n        };\n\n        // 3. 将任务提交给线程池\n        seckillExecutorService.submit(task);\n        \n        return \"请求已接收，正在排队处理中，请稍后查看订单状态。\";\n    }\n\n    /**\n     * 真实的秒杀执行逻辑，现在是一个私有方法\n     * 它会被后台线程池中的线程调用\n     * @param productId\n     * @param userId\n     */\n    private void executeSeckill(Long productId, Long userId) {\n        boolean acquired = false;\n        try {\n            acquired = semaphore.tryAcquire(3, TimeUnit.SECONDS);\n            if (!acquired) {\n                log.warn(\"线程 {} 获取信号量许可超时\", Thread.currentThread().getName());\n                return; // 获取不到许可，直接结束任务\n            }\n            // ... 省略了之前完整的、带 writeLock 和手动事务的业务逻辑 ...\n            // 注意：因为这个方法现在没有返回值了，你需要通过日志来记录成功或失败\n            // 比如在 commit 后 log.info(\"订单创建成功...\")\n            // 在 rollback 后 log.error(\"订单创建失败...\")\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            log.error(\"线程 {} 被中断\", Thread.currentThread().getName());\n        } finally {\n            if (acquired) {\n                semaphore.release();\n            }\n        }\n    }\n}\n```\n- 更新 SeckillController，调用新的“提交”方法。\n#### 压测结果与分析\n- JMeter设置与之前的版本相同，只执行写请求。\n- 结果：有120个线程成功请求到了线程池，80个失败请求。没有任何的库存减少和新订单的建立，并且在日志中没有任何关于申请信号量许可的信息。\n- 分析：\n  - 120个成功请求和80个失败请求：系统能够容纳的瞬时任务上限是20（正在执行）+100（排队等待）=120个，而剩下的80个失败请求对应的是因为线程池已满而被拒绝。\n  - 没有库存减少和新订单的建立：120个被线程池接收的任务，没有一个成功完成数据库操作。\n  - 日志中没有见到任何申请信号量许可的信息：甚至有可能没有进入`executeSeckill()`方法。类似于“当第200个请求被拒绝后，所有200个请求都结束了”\n- 原因：“守护线程”的提前退场\n  - 用户线程：通常创建的、执行核心任务的“前台线程”。JVM规则：只要还有一个用户线程没有执行完毕，JVM进程就必须等待，不能退出。\n  - 守护线程：特殊的“后台线程”，为其他线程服务。JVM规则：当程序中只剩下守护线程在运行时，JVM会认为所有核心工作已经全部完成，于是会退出并且终止所有仍在运行的守护线程。\n- 由于某种原因，在seckillExecutorService中创建的工作线程，被设置为了守护线程。\n#### 改进\n- 在创建线程时，明确设置为“用户线程”。\n```Java\n@Configuration\npublic class ThreadPoolConfig {\n\n    @Bean\n    public ExecutorService seckillExecutorService() {\n        ThreadFactory namedThreadFactory = r -> {\n            Thread t = new Thread(r);\n            // 【关键改动】将线程设置为非守护线程\n            t.setDaemon(false); \n            t.setName(\"seckill-thread-\" + t.hashCode());\n            return t;\n        };\n\n        // 创建线程池的其余代码保持不变\n        ExecutorService pool = new ThreadPoolExecutor(\n                10,\n                20,\n                60L,\n                TimeUnit.SECONDS,\n                new LinkedBlockingQueue<>(100),\n                namedThreadFactory,\n                new ThreadPoolExecutor.AbortPolicy()\n        );\n        return pool;\n    }\n}\n```\n- 在手动创建 Thread 对象后，调用了 t.setDaemon(false);。false 表示它是一个用户线程（非守护线程），这是 Java 线程的默认行为，但在这里我们明确地指定它，以覆盖任何可能的默认设置，确保万无一失。\n\n- 结果：库存减少至0，新增订单数100，数据正常。日志显示正常。\n\n### 单体应用的性能优化\n#### 数据库原子化更新、引入内存售罄标记\n- 使用“原子化SQL更新”替代Java锁，将检查库存和扣减库存合并为同一条SQL语句，并且引入内存售罄标记。数据库原子化更新利用了数据库的行锁来保证原子性，性能远高于在Java应用层加锁。引入内存售罄标记，直接拒绝已知的无效流量，保护了后端服务。\n- 修改 ProductRepository.java\n```Java\n@Repository\npublic interface ProductRepository extends JpaRepository<Product, Long> {\n\n    /**\n     * 【新增】原子化扣减库存的方法\n     * 使用 @Modifying 注解来告诉 Spring Data JPA 这是一个“修改”操作\n     * 使用 @Query 注解来定义我们的 JPQL 语句\n     * WHERE 子句中的 \"p.stock > 0\" 是关键，它在数据库层面保证了不会超卖\n     * @param productId 商品ID\n     * @return 返回受影响的行数，如果 > 0 表示更新成功，= 0 表示库存不足或商品不存在\n     */\n    @Modifying\n    @Query(\"UPDATE Product p SET p.stock = p.stock - 1 WHERE p.id = :productId AND p.stock > 0\")\n    int deductStock(@Param(\"productId\") Long productId);\n}\n```\n\n- 重构 SeckillService.java 的核心逻辑\n```Java\n@Service\npublic class SeckillService {\n    // ... 其他属性 ...\n\n    // 【移除】不再需要写锁了！\n    // private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock(true);\n    // private final Lock writeLock = rwLock.writeLock();\n\n    // ...\n\n    // 【新增】内存售罄标记\n    private volatile boolean isSoldOut = false;\n\n    public String submitSeckillOrder(Long productId, Long userId) {\n        // 【优化】在所有逻辑之前，先检查内存标记\n        if (isSoldOut) {\n            return \"商品已售罄（内存标记拦截）\";\n        }\n\n        // ... 之前的提交到线程池的逻辑保持不变 ...\n        // ...\n    }\n\n    private void executeSeckill(Long productId, Long userId) {\n        // ... Semaphore 的获取和释放逻辑保持不变 ...\n        boolean acquired = false;\n        try {\n            acquired = semaphore.tryAcquire(3, TimeUnit.SECONDS);\n            if (!acquired) {\n                // ...\n                return;\n            }\n\n            // 【移除】不再需要 Thread.sleep()\n            // Thread.sleep(1000);\n\n            // 【重构】调用新的、无锁的数据库操作方法\n            executeDbOperationsWithoutLock(productId, userId);\n\n        } catch (InterruptedException e) {\n            // ...\n        } finally {\n            if (acquired) {\n                semaphore.release();\n            }\n        }\n    }\n\n    // 【重构】创建一个新的、无锁的数据库操作方法\n    private void executeDbOperationsWithoutLock(Long productId, Long userId) {\n        // 【移除】不再需要 writeLock.lock()\n        DefaultTransactionDefinition def = new DefaultTransactionDefinition();\n        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n        TransactionStatus status = transactionManager.getTransaction(def);\n        try {\n            // 前置检查（重复下单等）依然可以保留\n            if (orderRepository.findByUserIdAndProductId(userId, productId) != null) {\n                throw new RuntimeException(\"您已秒杀过此商品，请勿重复下单\");\n            }\n            \n            // 1. 【核心改动】直接调用原子更新方法扣减库存\n            int result = productRepository.deductStock(productId);\n\n            // 2. 检查结果\n            if (result == 0) {\n                // 如果更新行数为0，说明库存不足\n                isSoldOut = true; // 【优化】设置内存售罄标记\n                throw new RuntimeException(\"商品已售罄\");\n            }\n\n            // 3. 如果扣减成功，才创建订单...\n\n            transactionManager.commit(status);\n            log.info(\"线程 {} 秒杀成功，提交事务。\", Thread.currentThread().getName());\n\n        } catch (Exception e) {\n            transactionManager.rollback(status);\n            log.error(\"线程 {} 秒杀失败，回滚事务: {}\", Thread.currentThread().getName(), e.getMessage());\n        }\n        // 【移除】不再需要 finally { writeLock.unlock() }\n    }\n}\n```\n#### 集成Spring Boot Actuator\n- 修改 pom.xml 文件\n- 在 <dependencies> 标签内，添加 Actuator 的 starter 依赖：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n- 修改 src/main/resources/application.properties 文件\n添加以下配置，来暴露所有的监控端点 (endpoints) 以供访问：\n\n```Properties\n# Spring Boot Actuator 配置\n# 暴露所有 Web 端点（在生产环境中应按需暴露，* 是为了开发方便）\nmanagement.endpoints.web.exposure.include=*\n# (可选) 让 health 端点总是显示详细信息\nmanagement.endpoint.health.show-details=always\n```\n\n### 学学八股\n#### ThreadPoolExecutor 线程池\n- 核心作用\n  - 降低资源消耗：通过复用已创建的线程，避免了频繁创建和销毁线程的巨大开销。\n  - 提高响应速度：任务到达时，可以直接使用池中的线程执行，省去了创建线程的时间。\n  - 提高客观理性：可以对线程进行统一的分配、监控和调优，防止无限制的创建线程耗尽系统资源。\n- 核心参数\n  - corePoolSize ：核心线程数，线程池长期维持的线程数量，即使它们处于空闲状态。\n  - maximumPoolSize ：最大线程数，线程池能够容纳的最大线程数量。当任务队列满了，且当前线程数小于最大线程数时，才会创建新线程。\n  - KeepAliveTime：空闲线程存活时间，当线程池中的数量大于corePoolSize时，多余的空闲线程在等待新任务时能够存活的最长时间。\n  - unit：时间单位\n  - workQueue：任务队列，用于存放等待执行的任务的阻塞队列。\n  - threadFactory： 线程工厂，用于创建新线程的工厂。\n  - rejectedExecutionHandler：拒绝策略，当任务队列和线程池都满了，新任务到来时所采取的策略。\n#### 原子化SQL更新\n- 核心思想：放弃在 Java 应用层使用锁（如 ReentrantLock）来保证“读-改-写”的原子性，而是将这个职责下推到数据库层面。\n- 底层原理：数据库的 InnoDB 引擎 会对符合 WHERE 条件的行加上行锁 (Row Lock)，从而天然地保证了该操作的原子性。\n#### Spring Boot Actuator\n- 核心作用：通过一系列的HTTP端点，暴露应用的内部运行情况。\n- Actuator 是构建可观测性系统的第一步。通过它暴露的 metrics 端点，可以与 Prometheus (数据采集) 和 Grafana (数据可视化) 等工具链集成，搭建出专业的监控仪表盘，实时监控 JVM 状态、数据库连接池、线程池活跃度等关键指标。","slug":"1-秒杀项目1.3-异步处理和优化","published":1,"updated":"2025-10-03T14:09:57.498Z","layout":"post","photos":[],"_id":"cmgdn5rh200090wuz55woc9bg","content":"<h3 id=\"用户体验：引入异步处理\"><a href=\"#用户体验：引入异步处理\" class=\"headerlink\" title=\"用户体验：引入异步处理\"></a>用户体验：引入异步处理</h3><ul>\n<li>在V1.1和V1.2，通过读写锁和信号量，构建了一个数据相对正确，流量可控的秒杀系统。尽管后端相对稳定，但用户体验糟糕，同步阻塞的模式，意味着用户必须在浏览器前“转圈圈”，等待后端的耗时操作。</li>\n<li>在V1.3中，实现异步化，将用户请求与后端耗时任务解耦，实现用户的及时响应。</li>\n</ul>\n<h4 id=\"代码改写\"><a href=\"#代码改写\" class=\"headerlink\" title=\"代码改写\"></a>代码改写</h4><ul>\n<li>线程池，创建<code>ThreadPoolConfig.java</code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPoolConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ExecutorService <span class=\"title function_\">seckillExecutorService</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 手动实现一个简单的 ThreadFactory</span></span><br><span class=\"line\">        <span class=\"type\">ThreadFactory</span> <span class=\"variable\">namedThreadFactory</span> <span class=\"operator\">=</span> r -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"string\">&quot;seckill-thread-&quot;</span> + r.hashCode());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建线程池</span></span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">pool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(</span><br><span class=\"line\">                <span class=\"number\">10</span>,     <span class=\"comment\">// corePoolSize: 核心线程数，即长期保持的线程数</span></span><br><span class=\"line\">                <span class=\"number\">20</span>,     <span class=\"comment\">// maximumPoolSize: 最大线程数</span></span><br><span class=\"line\">                <span class=\"number\">60L</span>,    <span class=\"comment\">// keepAliveTime: 空闲线程的存活时间</span></span><br><span class=\"line\">                TimeUnit.SECONDS, <span class=\"comment\">// 时间单位</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;(<span class=\"number\">100</span>), <span class=\"comment\">// workQueue: 任务队列，容量为100</span></span><br><span class=\"line\">                namedThreadFactory, <span class=\"comment\">// threadFactory: 线程工厂，用于给线程命名</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>.AbortPolicy() <span class=\"comment\">// rejectedExecutionHandler: 拒绝策略</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>重构SeckillService，分离提交与执行<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SeckillService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ExecutorService seckillExecutorService; <span class=\"comment\">// 1. 注入我们创建的线程池</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ... 其他属性保持不变 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 新的入口方法：负责接收请求并提交到线程池</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个方法会【立刻】返回，不会等待后台线程执行完毕</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">submitSeckillOrder</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 2. 创建一个任务（Runnable）</span></span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在这个任务中，调用我们之前那个耗时的、带锁的真实秒杀逻辑</span></span><br><span class=\"line\">            executeSeckill(productId, userId);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. 将任务提交给线程池</span></span><br><span class=\"line\">        seckillExecutorService.submit(task);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;请求已接收，正在排队处理中，请稍后查看订单状态。&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 真实的秒杀执行逻辑，现在是一个私有方法</span></span><br><span class=\"line\"><span class=\"comment\">     * 它会被后台线程池中的线程调用</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> productId</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> userId</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">acquired</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            acquired = semaphore.tryAcquire(<span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!acquired) &#123;</span><br><span class=\"line\">                log.warn(<span class=\"string\">&quot;线程 &#123;&#125; 获取信号量许可超时&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">                <span class=\"keyword\">return</span>; <span class=\"comment\">// 获取不到许可，直接结束任务</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// ... 省略了之前完整的、带 writeLock 和手动事务的业务逻辑 ...</span></span><br><span class=\"line\">            <span class=\"comment\">// 注意：因为这个方法现在没有返回值了，你需要通过日志来记录成功或失败</span></span><br><span class=\"line\">            <span class=\"comment\">// 比如在 commit 后 log.info(&quot;订单创建成功...&quot;)</span></span><br><span class=\"line\">            <span class=\"comment\">// 在 rollback 后 log.error(&quot;订单创建失败...&quot;)</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            Thread.currentThread().interrupt();</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;线程 &#123;&#125; 被中断&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (acquired) &#123;</span><br><span class=\"line\">                semaphore.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>更新 SeckillController，调用新的“提交”方法。</li>\n</ul>\n<h4 id=\"压测结果与分析\"><a href=\"#压测结果与分析\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li>JMeter设置与之前的版本相同，只执行写请求。</li>\n<li>结果：有120个线程成功请求到了线程池，80个失败请求。没有任何的库存减少和新订单的建立，并且在日志中没有任何关于申请信号量许可的信息。</li>\n<li>分析：<ul>\n<li>120个成功请求和80个失败请求：系统能够容纳的瞬时任务上限是20（正在执行）+100（排队等待）&#x3D;120个，而剩下的80个失败请求对应的是因为线程池已满而被拒绝。</li>\n<li>没有库存减少和新订单的建立：120个被线程池接收的任务，没有一个成功完成数据库操作。</li>\n<li>日志中没有见到任何申请信号量许可的信息：甚至有可能没有进入<code>executeSeckill()</code>方法。类似于“当第200个请求被拒绝后，所有200个请求都结束了”</li>\n</ul>\n</li>\n<li>原因：“守护线程”的提前退场<ul>\n<li>用户线程：通常创建的、执行核心任务的“前台线程”。JVM规则：只要还有一个用户线程没有执行完毕，JVM进程就必须等待，不能退出。</li>\n<li>守护线程：特殊的“后台线程”，为其他线程服务。JVM规则：当程序中只剩下守护线程在运行时，JVM会认为所有核心工作已经全部完成，于是会退出并且终止所有仍在运行的守护线程。</li>\n</ul>\n</li>\n<li>由于某种原因，在seckillExecutorService中创建的工作线程，被设置为了守护线程。</li>\n</ul>\n<h4 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h4><ul>\n<li><p>在创建线程时，明确设置为“用户线程”。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPoolConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ExecutorService <span class=\"title function_\">seckillExecutorService</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ThreadFactory</span> <span class=\"variable\">namedThreadFactory</span> <span class=\"operator\">=</span> r -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(r);</span><br><span class=\"line\">            <span class=\"comment\">// 【关键改动】将线程设置为非守护线程</span></span><br><span class=\"line\">            t.setDaemon(<span class=\"literal\">false</span>); </span><br><span class=\"line\">            t.setName(<span class=\"string\">&quot;seckill-thread-&quot;</span> + t.hashCode());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建线程池的其余代码保持不变</span></span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">pool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(</span><br><span class=\"line\">                <span class=\"number\">10</span>,</span><br><span class=\"line\">                <span class=\"number\">20</span>,</span><br><span class=\"line\">                <span class=\"number\">60L</span>,</span><br><span class=\"line\">                TimeUnit.SECONDS,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;(<span class=\"number\">100</span>),</span><br><span class=\"line\">                namedThreadFactory,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>在手动创建 Thread 对象后，调用了 t.setDaemon(false);。false 表示它是一个用户线程（非守护线程），这是 Java 线程的默认行为，但在这里我们明确地指定它，以覆盖任何可能的默认设置，确保万无一失。</p>\n</li>\n<li><p>结果：库存减少至0，新增订单数100，数据正常。日志显示正常。</p>\n</li>\n</ul>\n<h3 id=\"单体应用的性能优化\"><a href=\"#单体应用的性能优化\" class=\"headerlink\" title=\"单体应用的性能优化\"></a>单体应用的性能优化</h3><h4 id=\"数据库原子化更新、引入内存售罄标记\"><a href=\"#数据库原子化更新、引入内存售罄标记\" class=\"headerlink\" title=\"数据库原子化更新、引入内存售罄标记\"></a>数据库原子化更新、引入内存售罄标记</h4><ul>\n<li><p>使用“原子化SQL更新”替代Java锁，将检查库存和扣减库存合并为同一条SQL语句，并且引入内存售罄标记。数据库原子化更新利用了数据库的行锁来保证原子性，性能远高于在Java应用层加锁。引入内存售罄标记，直接拒绝已知的无效流量，保护了后端服务。</p>\n</li>\n<li><p>修改 ProductRepository.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ProductRepository</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">JpaRepository</span>&lt;Product, Long&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 【新增】原子化扣减库存的方法</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用 <span class=\"doctag\">@Modifying</span> 注解来告诉 Spring Data JPA 这是一个“修改”操作</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用 <span class=\"doctag\">@Query</span> 注解来定义我们的 JPQL 语句</span></span><br><span class=\"line\"><span class=\"comment\">     * WHERE 子句中的 &quot;p.stock &gt; 0&quot; 是关键，它在数据库层面保证了不会超卖</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> productId 商品ID</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 返回受影响的行数，如果 &gt; 0 表示更新成功，= 0 表示库存不足或商品不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Modifying</span></span><br><span class=\"line\">    <span class=\"meta\">@Query(&quot;UPDATE Product p SET p.stock = p.stock - 1 WHERE p.id = :productId AND p.stock &gt; 0&quot;)</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">deductStock</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;productId&quot;)</span> Long productId)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重构 SeckillService.java 的核心逻辑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SeckillService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... 其他属性 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 【移除】不再需要写锁了！</span></span><br><span class=\"line\">    <span class=\"comment\">// private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock(true);</span></span><br><span class=\"line\">    <span class=\"comment\">// private final Lock writeLock = rwLock.writeLock();</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 【新增】内存售罄标记</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">isSoldOut</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">submitSeckillOrder</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 【优化】在所有逻辑之前，先检查内存标记</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isSoldOut) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;商品已售罄（内存标记拦截）&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ... 之前的提交到线程池的逻辑保持不变 ...</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... Semaphore 的获取和释放逻辑保持不变 ...</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">acquired</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            acquired = semaphore.tryAcquire(<span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!acquired) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 【移除】不再需要 Thread.sleep()</span></span><br><span class=\"line\">            <span class=\"comment\">// Thread.sleep(1000);</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 【重构】调用新的、无锁的数据库操作方法</span></span><br><span class=\"line\">            executeDbOperationsWithoutLock(productId, userId);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (acquired) &#123;</span><br><span class=\"line\">                semaphore.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 【重构】创建一个新的、无锁的数据库操作方法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeDbOperationsWithoutLock</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 【移除】不再需要 writeLock.lock()</span></span><br><span class=\"line\">        <span class=\"type\">DefaultTransactionDefinition</span> <span class=\"variable\">def</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultTransactionDefinition</span>();</span><br><span class=\"line\">        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class=\"line\">        <span class=\"type\">TransactionStatus</span> <span class=\"variable\">status</span> <span class=\"operator\">=</span> transactionManager.getTransaction(def);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 前置检查（重复下单等）依然可以保留</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (orderRepository.findByUserIdAndProductId(userId, productId) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;您已秒杀过此商品，请勿重复下单&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 1. 【核心改动】直接调用原子更新方法扣减库存</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> productRepository.deductStock(productId);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 2. 检查结果</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果更新行数为0，说明库存不足</span></span><br><span class=\"line\">                isSoldOut = <span class=\"literal\">true</span>; <span class=\"comment\">// 【优化】设置内存售罄标记</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;商品已售罄&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 3. 如果扣减成功，才创建订单...</span></span><br><span class=\"line\"></span><br><span class=\"line\">            transactionManager.commit(status);</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;线程 &#123;&#125; 秒杀成功，提交事务。&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            transactionManager.rollback(status);</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;线程 &#123;&#125; 秒杀失败，回滚事务: &#123;&#125;&quot;</span>, Thread.currentThread().getName(), e.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 【移除】不再需要 finally &#123; writeLock.unlock() &#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"集成Spring-Boot-Actuator\"><a href=\"#集成Spring-Boot-Actuator\" class=\"headerlink\" title=\"集成Spring Boot Actuator\"></a>集成Spring Boot Actuator</h4><ul>\n<li><p>修改 pom.xml 文件</p>\n</li>\n<li><p>在 <dependencies> 标签内，添加 Actuator 的 starter 依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改 src&#x2F;main&#x2F;resources&#x2F;application.properties 文件<br>添加以下配置，来暴露所有的监控端点 (endpoints) 以供访问：</p>\n</li>\n</ul>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Spring Boot Actuator 配置</span></span><br><span class=\"line\"><span class=\"comment\"># 暴露所有 Web 端点（在生产环境中应按需暴露，* 是为了开发方便）</span></span><br><span class=\"line\"><span class=\"attr\">management.endpoints.web.exposure.include</span>=<span class=\"string\">*</span></span><br><span class=\"line\"><span class=\"comment\"># (可选) 让 health 端点总是显示详细信息</span></span><br><span class=\"line\"><span class=\"attr\">management.endpoint.health.show-details</span>=<span class=\"string\">always</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"ThreadPoolExecutor-线程池\"><a href=\"#ThreadPoolExecutor-线程池\" class=\"headerlink\" title=\"ThreadPoolExecutor 线程池\"></a>ThreadPoolExecutor 线程池</h4><ul>\n<li>核心作用<ul>\n<li>降低资源消耗：通过复用已创建的线程，避免了频繁创建和销毁线程的巨大开销。</li>\n<li>提高响应速度：任务到达时，可以直接使用池中的线程执行，省去了创建线程的时间。</li>\n<li>提高客观理性：可以对线程进行统一的分配、监控和调优，防止无限制的创建线程耗尽系统资源。</li>\n</ul>\n</li>\n<li>核心参数<ul>\n<li>corePoolSize ：核心线程数，线程池长期维持的线程数量，即使它们处于空闲状态。</li>\n<li>maximumPoolSize ：最大线程数，线程池能够容纳的最大线程数量。当任务队列满了，且当前线程数小于最大线程数时，才会创建新线程。</li>\n<li>KeepAliveTime：空闲线程存活时间，当线程池中的数量大于corePoolSize时，多余的空闲线程在等待新任务时能够存活的最长时间。</li>\n<li>unit：时间单位</li>\n<li>workQueue：任务队列，用于存放等待执行的任务的阻塞队列。</li>\n<li>threadFactory： 线程工厂，用于创建新线程的工厂。</li>\n<li>rejectedExecutionHandler：拒绝策略，当任务队列和线程池都满了，新任务到来时所采取的策略。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"原子化SQL更新\"><a href=\"#原子化SQL更新\" class=\"headerlink\" title=\"原子化SQL更新\"></a>原子化SQL更新</h4><ul>\n<li>核心思想：放弃在 Java 应用层使用锁（如 ReentrantLock）来保证“读-改-写”的原子性，而是将这个职责下推到数据库层面。</li>\n<li>底层原理：数据库的 InnoDB 引擎 会对符合 WHERE 条件的行加上行锁 (Row Lock)，从而天然地保证了该操作的原子性。</li>\n</ul>\n<h4 id=\"Spring-Boot-Actuator\"><a href=\"#Spring-Boot-Actuator\" class=\"headerlink\" title=\"Spring Boot Actuator\"></a>Spring Boot Actuator</h4><ul>\n<li>核心作用：通过一系列的HTTP端点，暴露应用的内部运行情况。</li>\n<li>Actuator 是构建可观测性系统的第一步。通过它暴露的 metrics 端点，可以与 Prometheus (数据采集) 和 Grafana (数据可视化) 等工具链集成，搭建出专业的监控仪表盘，实时监控 JVM 状态、数据库连接池、线程池活跃度等关键指标。</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"用户体验：引入异步处理\"><a href=\"#用户体验：引入异步处理\" class=\"headerlink\" title=\"用户体验：引入异步处理\"></a>用户体验：引入异步处理</h3><ul>\n<li>在V1.1和V1.2，通过读写锁和信号量，构建了一个数据相对正确，流量可控的秒杀系统。尽管后端相对稳定，但用户体验糟糕，同步阻塞的模式，意味着用户必须在浏览器前“转圈圈”，等待后端的耗时操作。</li>\n<li>在V1.3中，实现异步化，将用户请求与后端耗时任务解耦，实现用户的及时响应。</li>\n</ul>\n<h4 id=\"代码改写\"><a href=\"#代码改写\" class=\"headerlink\" title=\"代码改写\"></a>代码改写</h4><ul>\n<li>线程池，创建<code>ThreadPoolConfig.java</code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPoolConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ExecutorService <span class=\"title function_\">seckillExecutorService</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 手动实现一个简单的 ThreadFactory</span></span><br><span class=\"line\">        <span class=\"type\">ThreadFactory</span> <span class=\"variable\">namedThreadFactory</span> <span class=\"operator\">=</span> r -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"string\">&quot;seckill-thread-&quot;</span> + r.hashCode());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建线程池</span></span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">pool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(</span><br><span class=\"line\">                <span class=\"number\">10</span>,     <span class=\"comment\">// corePoolSize: 核心线程数，即长期保持的线程数</span></span><br><span class=\"line\">                <span class=\"number\">20</span>,     <span class=\"comment\">// maximumPoolSize: 最大线程数</span></span><br><span class=\"line\">                <span class=\"number\">60L</span>,    <span class=\"comment\">// keepAliveTime: 空闲线程的存活时间</span></span><br><span class=\"line\">                TimeUnit.SECONDS, <span class=\"comment\">// 时间单位</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;(<span class=\"number\">100</span>), <span class=\"comment\">// workQueue: 任务队列，容量为100</span></span><br><span class=\"line\">                namedThreadFactory, <span class=\"comment\">// threadFactory: 线程工厂，用于给线程命名</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>.AbortPolicy() <span class=\"comment\">// rejectedExecutionHandler: 拒绝策略</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>重构SeckillService，分离提交与执行<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SeckillService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ExecutorService seckillExecutorService; <span class=\"comment\">// 1. 注入我们创建的线程池</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ... 其他属性保持不变 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 新的入口方法：负责接收请求并提交到线程池</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个方法会【立刻】返回，不会等待后台线程执行完毕</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">submitSeckillOrder</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 2. 创建一个任务（Runnable）</span></span><br><span class=\"line\">        <span class=\"type\">Runnable</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在这个任务中，调用我们之前那个耗时的、带锁的真实秒杀逻辑</span></span><br><span class=\"line\">            executeSeckill(productId, userId);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. 将任务提交给线程池</span></span><br><span class=\"line\">        seckillExecutorService.submit(task);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;请求已接收，正在排队处理中，请稍后查看订单状态。&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 真实的秒杀执行逻辑，现在是一个私有方法</span></span><br><span class=\"line\"><span class=\"comment\">     * 它会被后台线程池中的线程调用</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> productId</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> userId</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">acquired</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            acquired = semaphore.tryAcquire(<span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!acquired) &#123;</span><br><span class=\"line\">                log.warn(<span class=\"string\">&quot;线程 &#123;&#125; 获取信号量许可超时&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">                <span class=\"keyword\">return</span>; <span class=\"comment\">// 获取不到许可，直接结束任务</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// ... 省略了之前完整的、带 writeLock 和手动事务的业务逻辑 ...</span></span><br><span class=\"line\">            <span class=\"comment\">// 注意：因为这个方法现在没有返回值了，你需要通过日志来记录成功或失败</span></span><br><span class=\"line\">            <span class=\"comment\">// 比如在 commit 后 log.info(&quot;订单创建成功...&quot;)</span></span><br><span class=\"line\">            <span class=\"comment\">// 在 rollback 后 log.error(&quot;订单创建失败...&quot;)</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            Thread.currentThread().interrupt();</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;线程 &#123;&#125; 被中断&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (acquired) &#123;</span><br><span class=\"line\">                semaphore.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>更新 SeckillController，调用新的“提交”方法。</li>\n</ul>\n<h4 id=\"压测结果与分析\"><a href=\"#压测结果与分析\" class=\"headerlink\" title=\"压测结果与分析\"></a>压测结果与分析</h4><ul>\n<li>JMeter设置与之前的版本相同，只执行写请求。</li>\n<li>结果：有120个线程成功请求到了线程池，80个失败请求。没有任何的库存减少和新订单的建立，并且在日志中没有任何关于申请信号量许可的信息。</li>\n<li>分析：<ul>\n<li>120个成功请求和80个失败请求：系统能够容纳的瞬时任务上限是20（正在执行）+100（排队等待）&#x3D;120个，而剩下的80个失败请求对应的是因为线程池已满而被拒绝。</li>\n<li>没有库存减少和新订单的建立：120个被线程池接收的任务，没有一个成功完成数据库操作。</li>\n<li>日志中没有见到任何申请信号量许可的信息：甚至有可能没有进入<code>executeSeckill()</code>方法。类似于“当第200个请求被拒绝后，所有200个请求都结束了”</li>\n</ul>\n</li>\n<li>原因：“守护线程”的提前退场<ul>\n<li>用户线程：通常创建的、执行核心任务的“前台线程”。JVM规则：只要还有一个用户线程没有执行完毕，JVM进程就必须等待，不能退出。</li>\n<li>守护线程：特殊的“后台线程”，为其他线程服务。JVM规则：当程序中只剩下守护线程在运行时，JVM会认为所有核心工作已经全部完成，于是会退出并且终止所有仍在运行的守护线程。</li>\n</ul>\n</li>\n<li>由于某种原因，在seckillExecutorService中创建的工作线程，被设置为了守护线程。</li>\n</ul>\n<h4 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h4><ul>\n<li><p>在创建线程时，明确设置为“用户线程”。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPoolConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ExecutorService <span class=\"title function_\">seckillExecutorService</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ThreadFactory</span> <span class=\"variable\">namedThreadFactory</span> <span class=\"operator\">=</span> r -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(r);</span><br><span class=\"line\">            <span class=\"comment\">// 【关键改动】将线程设置为非守护线程</span></span><br><span class=\"line\">            t.setDaemon(<span class=\"literal\">false</span>); </span><br><span class=\"line\">            t.setName(<span class=\"string\">&quot;seckill-thread-&quot;</span> + t.hashCode());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建线程池的其余代码保持不变</span></span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">pool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(</span><br><span class=\"line\">                <span class=\"number\">10</span>,</span><br><span class=\"line\">                <span class=\"number\">20</span>,</span><br><span class=\"line\">                <span class=\"number\">60L</span>,</span><br><span class=\"line\">                TimeUnit.SECONDS,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;(<span class=\"number\">100</span>),</span><br><span class=\"line\">                namedThreadFactory,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>在手动创建 Thread 对象后，调用了 t.setDaemon(false);。false 表示它是一个用户线程（非守护线程），这是 Java 线程的默认行为，但在这里我们明确地指定它，以覆盖任何可能的默认设置，确保万无一失。</p>\n</li>\n<li><p>结果：库存减少至0，新增订单数100，数据正常。日志显示正常。</p>\n</li>\n</ul>\n<h3 id=\"单体应用的性能优化\"><a href=\"#单体应用的性能优化\" class=\"headerlink\" title=\"单体应用的性能优化\"></a>单体应用的性能优化</h3><h4 id=\"数据库原子化更新、引入内存售罄标记\"><a href=\"#数据库原子化更新、引入内存售罄标记\" class=\"headerlink\" title=\"数据库原子化更新、引入内存售罄标记\"></a>数据库原子化更新、引入内存售罄标记</h4><ul>\n<li><p>使用“原子化SQL更新”替代Java锁，将检查库存和扣减库存合并为同一条SQL语句，并且引入内存售罄标记。数据库原子化更新利用了数据库的行锁来保证原子性，性能远高于在Java应用层加锁。引入内存售罄标记，直接拒绝已知的无效流量，保护了后端服务。</p>\n</li>\n<li><p>修改 ProductRepository.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ProductRepository</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">JpaRepository</span>&lt;Product, Long&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 【新增】原子化扣减库存的方法</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用 <span class=\"doctag\">@Modifying</span> 注解来告诉 Spring Data JPA 这是一个“修改”操作</span></span><br><span class=\"line\"><span class=\"comment\">     * 使用 <span class=\"doctag\">@Query</span> 注解来定义我们的 JPQL 语句</span></span><br><span class=\"line\"><span class=\"comment\">     * WHERE 子句中的 &quot;p.stock &gt; 0&quot; 是关键，它在数据库层面保证了不会超卖</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> productId 商品ID</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 返回受影响的行数，如果 &gt; 0 表示更新成功，= 0 表示库存不足或商品不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Modifying</span></span><br><span class=\"line\">    <span class=\"meta\">@Query(&quot;UPDATE Product p SET p.stock = p.stock - 1 WHERE p.id = :productId AND p.stock &gt; 0&quot;)</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">deductStock</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;productId&quot;)</span> Long productId)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重构 SeckillService.java 的核心逻辑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SeckillService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... 其他属性 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 【移除】不再需要写锁了！</span></span><br><span class=\"line\">    <span class=\"comment\">// private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock(true);</span></span><br><span class=\"line\">    <span class=\"comment\">// private final Lock writeLock = rwLock.writeLock();</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 【新增】内存售罄标记</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">isSoldOut</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">submitSeckillOrder</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 【优化】在所有逻辑之前，先检查内存标记</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isSoldOut) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;商品已售罄（内存标记拦截）&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ... 之前的提交到线程池的逻辑保持不变 ...</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... Semaphore 的获取和释放逻辑保持不变 ...</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">acquired</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            acquired = semaphore.tryAcquire(<span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!acquired) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ...</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 【移除】不再需要 Thread.sleep()</span></span><br><span class=\"line\">            <span class=\"comment\">// Thread.sleep(1000);</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 【重构】调用新的、无锁的数据库操作方法</span></span><br><span class=\"line\">            executeDbOperationsWithoutLock(productId, userId);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (acquired) &#123;</span><br><span class=\"line\">                semaphore.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 【重构】创建一个新的、无锁的数据库操作方法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeDbOperationsWithoutLock</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 【移除】不再需要 writeLock.lock()</span></span><br><span class=\"line\">        <span class=\"type\">DefaultTransactionDefinition</span> <span class=\"variable\">def</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultTransactionDefinition</span>();</span><br><span class=\"line\">        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class=\"line\">        <span class=\"type\">TransactionStatus</span> <span class=\"variable\">status</span> <span class=\"operator\">=</span> transactionManager.getTransaction(def);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 前置检查（重复下单等）依然可以保留</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (orderRepository.findByUserIdAndProductId(userId, productId) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;您已秒杀过此商品，请勿重复下单&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 1. 【核心改动】直接调用原子更新方法扣减库存</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> productRepository.deductStock(productId);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 2. 检查结果</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果更新行数为0，说明库存不足</span></span><br><span class=\"line\">                isSoldOut = <span class=\"literal\">true</span>; <span class=\"comment\">// 【优化】设置内存售罄标记</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;商品已售罄&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 3. 如果扣减成功，才创建订单...</span></span><br><span class=\"line\"></span><br><span class=\"line\">            transactionManager.commit(status);</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;线程 &#123;&#125; 秒杀成功，提交事务。&quot;</span>, Thread.currentThread().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            transactionManager.rollback(status);</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;线程 &#123;&#125; 秒杀失败，回滚事务: &#123;&#125;&quot;</span>, Thread.currentThread().getName(), e.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 【移除】不再需要 finally &#123; writeLock.unlock() &#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"集成Spring-Boot-Actuator\"><a href=\"#集成Spring-Boot-Actuator\" class=\"headerlink\" title=\"集成Spring Boot Actuator\"></a>集成Spring Boot Actuator</h4><ul>\n<li><p>修改 pom.xml 文件</p>\n</li>\n<li><p>在 <dependencies> 标签内，添加 Actuator 的 starter 依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改 src&#x2F;main&#x2F;resources&#x2F;application.properties 文件<br>添加以下配置，来暴露所有的监控端点 (endpoints) 以供访问：</p>\n</li>\n</ul>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Spring Boot Actuator 配置</span></span><br><span class=\"line\"><span class=\"comment\"># 暴露所有 Web 端点（在生产环境中应按需暴露，* 是为了开发方便）</span></span><br><span class=\"line\"><span class=\"attr\">management.endpoints.web.exposure.include</span>=<span class=\"string\">*</span></span><br><span class=\"line\"><span class=\"comment\"># (可选) 让 health 端点总是显示详细信息</span></span><br><span class=\"line\"><span class=\"attr\">management.endpoint.health.show-details</span>=<span class=\"string\">always</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"ThreadPoolExecutor-线程池\"><a href=\"#ThreadPoolExecutor-线程池\" class=\"headerlink\" title=\"ThreadPoolExecutor 线程池\"></a>ThreadPoolExecutor 线程池</h4><ul>\n<li>核心作用<ul>\n<li>降低资源消耗：通过复用已创建的线程，避免了频繁创建和销毁线程的巨大开销。</li>\n<li>提高响应速度：任务到达时，可以直接使用池中的线程执行，省去了创建线程的时间。</li>\n<li>提高客观理性：可以对线程进行统一的分配、监控和调优，防止无限制的创建线程耗尽系统资源。</li>\n</ul>\n</li>\n<li>核心参数<ul>\n<li>corePoolSize ：核心线程数，线程池长期维持的线程数量，即使它们处于空闲状态。</li>\n<li>maximumPoolSize ：最大线程数，线程池能够容纳的最大线程数量。当任务队列满了，且当前线程数小于最大线程数时，才会创建新线程。</li>\n<li>KeepAliveTime：空闲线程存活时间，当线程池中的数量大于corePoolSize时，多余的空闲线程在等待新任务时能够存活的最长时间。</li>\n<li>unit：时间单位</li>\n<li>workQueue：任务队列，用于存放等待执行的任务的阻塞队列。</li>\n<li>threadFactory： 线程工厂，用于创建新线程的工厂。</li>\n<li>rejectedExecutionHandler：拒绝策略，当任务队列和线程池都满了，新任务到来时所采取的策略。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"原子化SQL更新\"><a href=\"#原子化SQL更新\" class=\"headerlink\" title=\"原子化SQL更新\"></a>原子化SQL更新</h4><ul>\n<li>核心思想：放弃在 Java 应用层使用锁（如 ReentrantLock）来保证“读-改-写”的原子性，而是将这个职责下推到数据库层面。</li>\n<li>底层原理：数据库的 InnoDB 引擎 会对符合 WHERE 条件的行加上行锁 (Row Lock)，从而天然地保证了该操作的原子性。</li>\n</ul>\n<h4 id=\"Spring-Boot-Actuator\"><a href=\"#Spring-Boot-Actuator\" class=\"headerlink\" title=\"Spring Boot Actuator\"></a>Spring Boot Actuator</h4><ul>\n<li>核心作用：通过一系列的HTTP端点，暴露应用的内部运行情况。</li>\n<li>Actuator 是构建可观测性系统的第一步。通过它暴露的 metrics 端点，可以与 Prometheus (数据采集) 和 Grafana (数据可视化) 等工具链集成，搭建出专业的监控仪表盘，实时监控 JVM 状态、数据库连接池、线程池活跃度等关键指标。</li>\n</ul>\n"},{"title":"1-秒杀项目2.0-Redis机制","poster":{"topic":"标题上方的小字","headline":"大标题","caption":"标题下方的小字","color":"标题颜色"},"date":"2025-10-05T09:59:28.000Z","description":"重新起航版","cover":null,"banner":null,"sticky":null,"mermaid":null,"katex":null,"mathjax":null,"topic":null,"author":null,"references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n### 突破限制：引入Redis机制\n\n**当前系统V1.3 已经具备的功能：**\n- 异步处理：用户的点击会立刻得到响应。\n- 流量控制：保护系统不会因过多线程而崩溃\n- 原子化SQL：数据库操作精准无误\n- 内存标记：售罄后能快速拒绝请求。\n\n**无法回避的“物理上限”：**\n- 用户体验的断崖式下跌：服务器可能在第一秒就收到了数万甚至数十万的 HTTP 请求。而应用内置的 Tomcat 服务器线程池（比如200个）会瞬间被打满。后续的所有请求，都会在操作系统的 TCP 连接队列中排队，最终大量超时。\n  -  99% 的用户刷新页面后，看到的是一个永远在“转圈圈”的加载动画，或是冰冷的 “503 Service Unavailable” 错误。\n- 数据库是最终的性能瓶颈：数据库的磁盘I/O、网络带宽、以及自身的处理能力成为了整个系统性能的天花板。\n  - 数据库通常是多个业务的**共享资源**。秒杀业务对数据库的极限压榨，会导致**整个网站的其他核心功能全部瘫痪**。普通用户无法登录、无法浏览其他商品、无法对购物车里的其他商品下单。**为了一个秒杀活动，导致整个电商平台的交易系统停摆，这是任何公司都无法接受的巨大损失。**\n- 应用服务器是“单点故障”：应用运行在一个实例上，如果这个应用因为任何原因，比如JVM崩溃或服务器宕机，挂掉，那么整个秒杀服务就会彻底中断。\n  - **整个秒杀服务彻底消失**，恢复时间未知。\n- 无法水平扩展：所有基于Java内存的并发控制，在多实例部署时都会失效。\n  - 暴露了架构的僵化和脆弱\n\n**Redis能解决什么问题？**\n- 解决了数据库雪崩和用户体验差的问题\n  - 把高频的库存读写、用户资格判断，从毫秒级的、基于磁盘的MYSQL，转移到了微秒级的、基于内存的Redis。\n  - 99%的读写流量由Redis抗住，每秒可以处理数万甚至数万次请求。\n  - 数据库只负责收尾工作，只有极少数成功抢到资格的用户，它们的订单信息才会异步的、平稳的写入数据库中。\n- 解决了单点故障和无法水平扩展的问题\n  - 通过将所有需要共享的状态统一放在Redis中，本身的Spring Boot应用本身变成了“无状态”的。\n#### 环境准备与集成\n> 在 Spring Boot 项目中成功引入并连接到 Redis\n\n1. 安装并运行Redis\n  - 在电脑上，使用docker在后台启动一个名为seckill-redis的Redis容器，并将其6379端口映射到电脑的6379端口。\n  ```Bash\n  docker run -d --name seckill-redis -p 6379:6379 redis\n  ```\n2. 添加Maven依赖\n  - 在pom.xml文件中，添加新的依赖\n  ```XML\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n  </dependency>\n  ```\n  - 保存并让IDE重新加载依赖\n3. 配置application.properties\n  - 添加 Redis 的连接信息\n  ```Properties\n  # ================== Redis Configuration ==================\n  spring.redis.host=localhost\n  spring.redis.port=6379\n  ```\n4. 验证连接\n  - 可以创建一个简单的测试类来验证应用启动时能否成功连接到Redis\n  ```Java\n  @Component\n  public class RedisConnectionTester implements CommandLineRunner {\n\n      @Autowired\n      private StringRedisTemplate redisTemplate;\n\n      @Override\n      public void run(String... args) throws Exception {\n        try {\n            String result = redisTemplate.getConnectionFactory().getConnection().ping();\n            System.out.println(\"=========================================\");\n            System.out.println(\"Successfully connected to Redis. PING response: \" + result);\n            System.out.println(\"=========================================\");\n        } catch (Exception e) {\n            System.err.println(\"=========================================\");\n            System.err.println(\"Failed to connect to Redis: \" + e.getMessage());\n            System.err.println(\"=========================================\");\n        }\n      }\n  }\n  ```\n  - 启动 Spring Boot 应用。在控制台看到了 Successfully connected to Redis 的信息，表示第一阶段就成功。\n#### 数据预热与缓存“读”操作\n> 将查询库存的流量从 MySQL 转移到 Redis。\n1. 创建数据预热Service\n  - 在秒杀开始之前，把数据从MYSQL加载到Redis。用启动时加载器来模拟。\n  - 创建`RedisPreheatService.java`\n  ```Java\n  @Service\n  public class RedisPreheatService implements CommandLineRunner{\n    public static final String STOCK_KEY = \"seckill:stock:\";\n    public static final String PRODUCT_KEY = \"seckill:product:\";\n    public static final String USER_SET_KEY = \"seckill:users:\";\n\n    @Autowired\n    private ProductRepository productRepository; // 假设你已注入\n\n    @Autowired\n    private RedisTemplate<String, Object> redisTemplate;\n\n    // 应用启动后自动执行\n    @Override\n    public void run(String... args) throws Exception {\n        // 假设我们秒杀的商品ID是 1\n        long productId = 1L;\n        Product product = productRepository.findById(productId).orElse(null);\n\n        if (product != null) {\n            // 1. 清理旧数据（为了可重复测试）\n            redisTemplate.delete(STOCK_KEY + productId);\n            redisTemplate.delete(USER_SET_KEY + productId);\n\n            // 2. 加载库存到 Redis String\n            redisTemplate.opsForValue().set(STOCK_KEY + productId, product.getStock());\n\n            System.out.println(\"=========================================\");\n            System.out.println(\"Product \" + productId + \" stock preheated to Redis: \" + product.getStock());\n            System.out.println(\"=========================================\");\n        }\n    }\n  }\n  ```\n2. 改造SeckillService的checkStock方法\n  - 直接从Redis读数据\n  ```Java\n  // 在 SeckillService.java 中\n  @Autowired\n  private RedisTemplate<String, Object> redisTemplate;\n\n  public Integer checkStock(Long productId) {\n    String stockKey = RedisPreheatService.STOCK_KEY + productId;\n    Object stockObj = redisTemplate.opsForValue().get(stockKey);\n    return stockObj != null ? Integer.parseInt(stockObj.toString()) : -1;\n  }\n  ```\n#### 核心逻辑迁移（Redis + Lua脚本）\n> 将最关键的“判断资格&扣减库存”操作，从Java层的锁+数据库，迁移到Redis的原子化Lua脚本。\n1. 创建Lua脚本文件\n  - 在 src/main/resources/ 目录下，创建一个新文件夹 scripts。\n  - 在 scripts 文件夹里，创建一个新文件 seckill.lua\n  ```Lua\n  -- seckill.lua\n  -- KEYS[1]: 库存的 key (e.g., seckill:stock:1)\n  -- KEYS[2]: 已购买用户集合的 key (e.g., seckill:users:1)\n  -- ARGV[1]: 当前请求的用户 ID\n\n  -- 1. 判断用户是否重复购买\n  if redis.call('sismember', KEYS[2], ARGV[1]) == 1 then\n    return 2 -- 2 代表重复购买\n  end\n\n  -- 2. 获取库存\n  local stock = tonumber(redis.call('get', KEYS[1]))\n  if stock <= 0 then\n    return 1 -- 1 代表库存不足\n  end\n\n  -- 3. 扣减库存\n  redis.call('decr', KEYS[1])\n\n  -- 4. 记录购买用户\n  redis.call('sadd', KEYS[2], ARGV[1])\n\n  return 0 -- 0 代表秒杀成功\n  ```\n2. 配置并加载Lua脚本\n  - 创建一个RedisConfig.java文件。用于管理与Redis相关的Bean。\n  ```Java\n  @Configuration\n  public class RedisConfig {\n\n    /**\n     * 【新增】配置并创建 RedisTemplate Bean\n     * @param connectionFactory Spring Boot 自动配置好的连接工厂\n     * @return RedisTemplate 实例\n     */\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {\n        // 创建 RedisTemplate 对象\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        // 设置连接工厂\n        template.setConnectionFactory(connectionFactory);\n\n        // 创建 JSON 序列化工具\n        GenericJackson2JsonRedisSerializer jsonSerializer = new GenericJackson2JsonRedisSerializer();\n\n        // 设置 Key 的序列化方式为 String\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n\n        // 设置 Value 的序列化方式为 JSON\n        template.setValueSerializer(jsonSerializer);\n        template.setHashValueSerializer(jsonSerializer);\n\n        // 使配置生效\n        template.afterPropertiesSet();\n        \n        return template;\n    }\n\n    @Bean\n    public DefaultRedisScript<Long> seckillScript() {\n        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();\n        redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(\"scripts/seckill.lua\")));\n        redisScript.setResultType(Long.class);\n        return redisScript;\n    }\n  }\n  ```\n3. 重构SeckillService的核心秒杀逻辑\n```Java\n// 在 SeckillService.java 中\n@Autowired\nprivate DefaultRedisScript<Long> seckillScript;\n\n// 我们需要一个内存队列来存放成功秒杀的订单信息\nprivate final BlockingQueue<SeckillOrder> orderQueue = new LinkedBlockingQueue<>(1000);\n\n// 改造异步执行的后台任务\nprivate void executeSeckill(Long productId, Long userId) {\n    List<String> keys = Arrays.asList(\n        RedisPreheatService.STOCK_KEY + productId,\n        RedisPreheatService.USER_SET_KEY + productId\n    );\n\n    // 执行 Lua 脚本\n    Long result = redisTemplate.execute(seckillScript, keys, userId.toString());\n\n    if (result == 0) {\n        log.info(\"用户 {} 秒杀成功！\", userId);\n        // 秒杀成功，生成订单信息并放入内存队列\n        // 此时订单尚未写入数据库\n        Product product = ... // 可以从缓存或数据库获取商品信息\n        SeckillOrder order = new SeckillOrder();\n        order.setProductId(productId);\n        order.setUserId(userId);\n        order.setOrderPrice(product.getPrice());\n        // 将订单放入队列\n        try {\n            orderQueue.put(order);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    } else if (result == 1) {\n        log.warn(\"用户 {} 秒杀失败：库存不足\", userId);\n    } else if (result == 2) {\n        log.warn(\"用户 {} 秒杀失败：重复下单\", userId);\n    } else {\n        log.error(\"用户 {} 秒杀异常\", userId);\n    }\n}\n```\n#### 异步持久化\n> 创建订单消费者Service\n  - 新建一个OrderConsumeService.java\n  ```Java\n  @Service\n  public class OrderConsumerService {\n    \n    // ... 其他注入的属性 ...\n\n    // 应用启动后，开启一个后台线程\n    @PostConstruct\n    private void startConsumer() {\n        new Thread(() -> {\n            while (true) {\n                try {\n                    SeckillOrder order = seckillService.getOrderQueue().take();\n                    // 2. 循环体内部现在只调用这个新的、带事务的方法\n                    createOrderInDb(order);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    log.error(\"订单消费者线程被中断\", e);\n                    break;\n                } catch (Exception e) {\n                    // 捕获所有其他可能的异常，防止线程意外终止\n                    log.error(\"处理订单时发生未知异常\", e);\n                }\n            }\n        }).start();\n    }\n\n    /**\n     * 3. 【新增】一个公开的、带事务注解的方法，专门用于数据库操作\n     * @param order 从队列中取出的订单信息\n     */\n    @Transactional\n    public void createOrderInDb(SeckillOrder order) {\n        log.info(\"正在创建订单并扣减MySQL库存: {}\", order);\n        \n        // 将所有数据库操作都放在这个方法里\n        orderRepository.save(order);\n        \n        int result = productRepository.deductStock(order.getProductId());\n        if (result == 0) {\n            // 这是一个补偿逻辑，理论上在Redis阶段已经保证了库存充足\n            // 但为了数据最终一致性，如果MySQL库存扣减失败，应抛出异常让事务回滚\n            throw new RuntimeException(\"MySQL a's stock deduction failed for order: \" + order);\n        }\n        \n        log.info(\"数据库订单创建成功\");\n    }\n  }\n  ```\n  - 在 SeckillService 中为 orderQueue 提供一个 getter 方法。\n\n### JMeter压测结果分析与改进\n#### 结果分析\n- 结果：日志显示：处理订单时发生未知异常；数据库信息显示：订单正常创建，但是库存数没有减少；存在`TransactionRequiredException`报错。\n- 分析：\n  - 订单正常创建：说明 orderRepository.save(order) 这行代码执行成功了，并且它的结果被提交到了数据库。\n  - 库存数没有减少：说明 productRepository.deductStock(...) 这行代码没有成功，或者它的结果被回滚了。\n  - 存在`TransactionRequiredException`报错：deductStock() 在执行时，没有找到一个正在运行的事务。\n  - 即，orderRepository.save() 在一个事务里成功了（或者在没有事务的情况下自动提交了），而紧接着的 deductStock() 却发现自己不在任何事务里。但是这两个方法在同一个被@Transactional注解的方法里。所以真正的原因应该是，方法上的@Transactional注解没有生效。**因为这个方法是通过this关键字进行的方法自调用，无法触发AOP代理**。当startConsumer方法在 while 循环里调用 createOrderInDb(order) 时，它实际上是在调用 this.createOrderInDb(order)，绕过了AOP代理，所以无人发现@Transactional注解，事务没有被开启。\n\n#### 改进\n- 注入服务自身，通过代理对象来调用方法。\n- 修改`OrderConsumerService.java`\n```Java\n@Service\npublic class OrderConsumerService {\n    \n    // ... 其他注入的属性 ...\n    @Autowired\n    private SeckillService seckillService;\n\n    // 2. 注入自己（代理对象）\n    // 使用 @Lazy 是为了解决循环依赖的潜在问题\n    @Autowired\n    @Lazy\n    private OrderConsumerService self;\n\n    // 应用启动后，开启一个后台线程\n    @PostConstruct\n    private void startConsumer() {\n        new Thread(() -> {\n            while (true) {\n                try {\n                    SeckillOrder order = seckillService.getOrderQueue().take();\n                    // 3. 【关键改动】通过 self 代理对象来调用事务方法\n                    self.createOrderInDb(order);\n                } catch (InterruptedException e) {\n                    // ...\n                } catch (Exception e) {\n                    // ...\n                }\n            }\n        }).start();\n    }\n\n    /**\n     * 这个方法保持不变，但现在它能被正确地代理了\n     */\n    @Transactional\n    public void createOrderInDb(SeckillOrder order) {\n        // ... 之前的数据库操作逻辑完全不变 ...\n        log.info(\"正在创建订单并扣减MySQL库存: {}\", order);\n        orderRepository.save(order);\n        int result = productRepository.deductStock(order.getProductId());\n        if (result == 0) {\n            throw new RuntimeException(\"MySQL stock deduction failed for order: \" + order);\n        }\n        log.info(\"数据库订单创建成功\");\n    }\n}\n```\n- @Autowired private OrderConsumerService self; 注入的 self 变量，不是 this 对象，而是 Spring 创建的、包含了事务处理逻辑的代理对象。\n- 当调用 self.createOrderInDb(order) 时，请求就从`startConsumer`发到了AOP代理那里。\n- AOP代理会正常地开启事务，然后再让真实对象去执行数据库操作。这样，@Transactional 就重新恢复了它的作用。\n\n- 结果：数据库信息显示正常，库存正确减少，订单正确建立。\n\n### 学学八股\n#### Redis\n- Redis是一个开源的、基于内存的、key-value结构的高性能数据库。\n  - 基于内存：是Redis高性能的根本原因。所有数据都存储在内存中，读写速度极快，远超基于磁盘的数据库。\n  - key-value：数据存储方式非常简单，像一个巨大的HashMap，通过一个唯一的Key来存取一个Value。\n  - 不仅仅是缓存：除了被用于缓存外，也被广泛运用于数据库、消息队列等。\n- 核心原理（为什么快）\n  - 纯内存操作：所有的操作都在内存中完成，完全避免了磁盘I/O这个最耗时的环节。\n  - 单线程模型：Redis的核心网络模型和命令处理是由一个单线程来完成的。无线程切换开销、无锁竞争、I/O多路复用。\n- Redis的原子性与Lua脚本\n  - Redis的单个命令是原子性的，但是多个命令组合在一起，就不是原子性的。\n  - 但Redis允许将一段Lua脚本作为一个整体发送给服务器执行，Redis会保证这个脚本在执行期间不会被任何其他命令打断，从而实现了多个命令的原子性组合。\n- Redis的持久化机制\n  - RDB：在指定的时间间隔内，将内存中的数据快照完整的写入到磁盘上的一个二进制文件中。恢复速度快，文件紧凑。但如果Redis在两次快照之间崩溃，会损失一部分数据。\n  - AOF：将每一条接受到的写命令，以追加的方式写入到一个日志文件中，恢复时，重新执行一遍文件中的所有写命令。数据的安全性更高（最多只丢失1秒的数据），单文件体积大，恢复速度相对较慢。\n- Redis的缓存经典问题\n  - 缓存穿透：查询一个数据库中根本不存在的数据，缓存中自然也没有，导致每次请求都直接打到数据库上，失去了缓存的意义。\n    - 缓存空对象：如果数据库查询结果为空，依然在Redis中缓存一个特殊的空值，并设置一个较短的过期时间。\n    - 布隆过滤器：在Redis前再加一道屏障，用布隆过滤器快速判断请求的数据是否存在。\n  - 缓存击穿：一个热点Key在某个瞬间突然失效，导致海量的并发请求同时涌向这个Key，并全部穿透到数据库，导致数据库瞬时压力过大。\n    - 互斥锁：当缓存失效时，第一个查询请求获取一个互斥锁，然后去加载数据并回设缓存。其他线程则等待锁释放后，直接从缓存中获取数据。\n    - 热点数据永不过期：对极热点的数据设置逻辑过期，由后台线程异步更新。\n  - 缓存雪崩：大量的key在同一时间集中失效，导致瞬时大量的请求都穿透到数据库。\n    - 随机化过期时间：在基础过期时间上，增加一个随机值，避免集中失效。\n    - 高可用架构：通过Redis集群、限流降级等操作，保证即使缓存出现问题，数据库也不会被完全冲垮。","source":"_posts/1-秒杀项目2.0-Redis机制.md","raw":"---\ntitle: 1-秒杀项目2.0-Redis机制\ntags: [Spring Boot,高并发,JUC]\ncategories: [项目实战]\nposter:\n  topic: 标题上方的小字\n  headline: 大标题\n  caption: 标题下方的小字\n  color: 标题颜色\ndate: 2025-10-05 17:59:28\ndescription: 重新起航版\ncover:\nbanner:\nsticky:\nmermaid:\nkatex:\nmathjax:\ntopic:\nauthor:\nreferences:\ncomments:\nindexing:\nbreadcrumb:\nleftbar:\nrightbar:\nh1:\ntype: tech\n---\n\n### 突破限制：引入Redis机制\n\n**当前系统V1.3 已经具备的功能：**\n- 异步处理：用户的点击会立刻得到响应。\n- 流量控制：保护系统不会因过多线程而崩溃\n- 原子化SQL：数据库操作精准无误\n- 内存标记：售罄后能快速拒绝请求。\n\n**无法回避的“物理上限”：**\n- 用户体验的断崖式下跌：服务器可能在第一秒就收到了数万甚至数十万的 HTTP 请求。而应用内置的 Tomcat 服务器线程池（比如200个）会瞬间被打满。后续的所有请求，都会在操作系统的 TCP 连接队列中排队，最终大量超时。\n  -  99% 的用户刷新页面后，看到的是一个永远在“转圈圈”的加载动画，或是冰冷的 “503 Service Unavailable” 错误。\n- 数据库是最终的性能瓶颈：数据库的磁盘I/O、网络带宽、以及自身的处理能力成为了整个系统性能的天花板。\n  - 数据库通常是多个业务的**共享资源**。秒杀业务对数据库的极限压榨，会导致**整个网站的其他核心功能全部瘫痪**。普通用户无法登录、无法浏览其他商品、无法对购物车里的其他商品下单。**为了一个秒杀活动，导致整个电商平台的交易系统停摆，这是任何公司都无法接受的巨大损失。**\n- 应用服务器是“单点故障”：应用运行在一个实例上，如果这个应用因为任何原因，比如JVM崩溃或服务器宕机，挂掉，那么整个秒杀服务就会彻底中断。\n  - **整个秒杀服务彻底消失**，恢复时间未知。\n- 无法水平扩展：所有基于Java内存的并发控制，在多实例部署时都会失效。\n  - 暴露了架构的僵化和脆弱\n\n**Redis能解决什么问题？**\n- 解决了数据库雪崩和用户体验差的问题\n  - 把高频的库存读写、用户资格判断，从毫秒级的、基于磁盘的MYSQL，转移到了微秒级的、基于内存的Redis。\n  - 99%的读写流量由Redis抗住，每秒可以处理数万甚至数万次请求。\n  - 数据库只负责收尾工作，只有极少数成功抢到资格的用户，它们的订单信息才会异步的、平稳的写入数据库中。\n- 解决了单点故障和无法水平扩展的问题\n  - 通过将所有需要共享的状态统一放在Redis中，本身的Spring Boot应用本身变成了“无状态”的。\n#### 环境准备与集成\n> 在 Spring Boot 项目中成功引入并连接到 Redis\n\n1. 安装并运行Redis\n  - 在电脑上，使用docker在后台启动一个名为seckill-redis的Redis容器，并将其6379端口映射到电脑的6379端口。\n  ```Bash\n  docker run -d --name seckill-redis -p 6379:6379 redis\n  ```\n2. 添加Maven依赖\n  - 在pom.xml文件中，添加新的依赖\n  ```XML\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n  </dependency>\n  ```\n  - 保存并让IDE重新加载依赖\n3. 配置application.properties\n  - 添加 Redis 的连接信息\n  ```Properties\n  # ================== Redis Configuration ==================\n  spring.redis.host=localhost\n  spring.redis.port=6379\n  ```\n4. 验证连接\n  - 可以创建一个简单的测试类来验证应用启动时能否成功连接到Redis\n  ```Java\n  @Component\n  public class RedisConnectionTester implements CommandLineRunner {\n\n      @Autowired\n      private StringRedisTemplate redisTemplate;\n\n      @Override\n      public void run(String... args) throws Exception {\n        try {\n            String result = redisTemplate.getConnectionFactory().getConnection().ping();\n            System.out.println(\"=========================================\");\n            System.out.println(\"Successfully connected to Redis. PING response: \" + result);\n            System.out.println(\"=========================================\");\n        } catch (Exception e) {\n            System.err.println(\"=========================================\");\n            System.err.println(\"Failed to connect to Redis: \" + e.getMessage());\n            System.err.println(\"=========================================\");\n        }\n      }\n  }\n  ```\n  - 启动 Spring Boot 应用。在控制台看到了 Successfully connected to Redis 的信息，表示第一阶段就成功。\n#### 数据预热与缓存“读”操作\n> 将查询库存的流量从 MySQL 转移到 Redis。\n1. 创建数据预热Service\n  - 在秒杀开始之前，把数据从MYSQL加载到Redis。用启动时加载器来模拟。\n  - 创建`RedisPreheatService.java`\n  ```Java\n  @Service\n  public class RedisPreheatService implements CommandLineRunner{\n    public static final String STOCK_KEY = \"seckill:stock:\";\n    public static final String PRODUCT_KEY = \"seckill:product:\";\n    public static final String USER_SET_KEY = \"seckill:users:\";\n\n    @Autowired\n    private ProductRepository productRepository; // 假设你已注入\n\n    @Autowired\n    private RedisTemplate<String, Object> redisTemplate;\n\n    // 应用启动后自动执行\n    @Override\n    public void run(String... args) throws Exception {\n        // 假设我们秒杀的商品ID是 1\n        long productId = 1L;\n        Product product = productRepository.findById(productId).orElse(null);\n\n        if (product != null) {\n            // 1. 清理旧数据（为了可重复测试）\n            redisTemplate.delete(STOCK_KEY + productId);\n            redisTemplate.delete(USER_SET_KEY + productId);\n\n            // 2. 加载库存到 Redis String\n            redisTemplate.opsForValue().set(STOCK_KEY + productId, product.getStock());\n\n            System.out.println(\"=========================================\");\n            System.out.println(\"Product \" + productId + \" stock preheated to Redis: \" + product.getStock());\n            System.out.println(\"=========================================\");\n        }\n    }\n  }\n  ```\n2. 改造SeckillService的checkStock方法\n  - 直接从Redis读数据\n  ```Java\n  // 在 SeckillService.java 中\n  @Autowired\n  private RedisTemplate<String, Object> redisTemplate;\n\n  public Integer checkStock(Long productId) {\n    String stockKey = RedisPreheatService.STOCK_KEY + productId;\n    Object stockObj = redisTemplate.opsForValue().get(stockKey);\n    return stockObj != null ? Integer.parseInt(stockObj.toString()) : -1;\n  }\n  ```\n#### 核心逻辑迁移（Redis + Lua脚本）\n> 将最关键的“判断资格&扣减库存”操作，从Java层的锁+数据库，迁移到Redis的原子化Lua脚本。\n1. 创建Lua脚本文件\n  - 在 src/main/resources/ 目录下，创建一个新文件夹 scripts。\n  - 在 scripts 文件夹里，创建一个新文件 seckill.lua\n  ```Lua\n  -- seckill.lua\n  -- KEYS[1]: 库存的 key (e.g., seckill:stock:1)\n  -- KEYS[2]: 已购买用户集合的 key (e.g., seckill:users:1)\n  -- ARGV[1]: 当前请求的用户 ID\n\n  -- 1. 判断用户是否重复购买\n  if redis.call('sismember', KEYS[2], ARGV[1]) == 1 then\n    return 2 -- 2 代表重复购买\n  end\n\n  -- 2. 获取库存\n  local stock = tonumber(redis.call('get', KEYS[1]))\n  if stock <= 0 then\n    return 1 -- 1 代表库存不足\n  end\n\n  -- 3. 扣减库存\n  redis.call('decr', KEYS[1])\n\n  -- 4. 记录购买用户\n  redis.call('sadd', KEYS[2], ARGV[1])\n\n  return 0 -- 0 代表秒杀成功\n  ```\n2. 配置并加载Lua脚本\n  - 创建一个RedisConfig.java文件。用于管理与Redis相关的Bean。\n  ```Java\n  @Configuration\n  public class RedisConfig {\n\n    /**\n     * 【新增】配置并创建 RedisTemplate Bean\n     * @param connectionFactory Spring Boot 自动配置好的连接工厂\n     * @return RedisTemplate 实例\n     */\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {\n        // 创建 RedisTemplate 对象\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        // 设置连接工厂\n        template.setConnectionFactory(connectionFactory);\n\n        // 创建 JSON 序列化工具\n        GenericJackson2JsonRedisSerializer jsonSerializer = new GenericJackson2JsonRedisSerializer();\n\n        // 设置 Key 的序列化方式为 String\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n\n        // 设置 Value 的序列化方式为 JSON\n        template.setValueSerializer(jsonSerializer);\n        template.setHashValueSerializer(jsonSerializer);\n\n        // 使配置生效\n        template.afterPropertiesSet();\n        \n        return template;\n    }\n\n    @Bean\n    public DefaultRedisScript<Long> seckillScript() {\n        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();\n        redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(\"scripts/seckill.lua\")));\n        redisScript.setResultType(Long.class);\n        return redisScript;\n    }\n  }\n  ```\n3. 重构SeckillService的核心秒杀逻辑\n```Java\n// 在 SeckillService.java 中\n@Autowired\nprivate DefaultRedisScript<Long> seckillScript;\n\n// 我们需要一个内存队列来存放成功秒杀的订单信息\nprivate final BlockingQueue<SeckillOrder> orderQueue = new LinkedBlockingQueue<>(1000);\n\n// 改造异步执行的后台任务\nprivate void executeSeckill(Long productId, Long userId) {\n    List<String> keys = Arrays.asList(\n        RedisPreheatService.STOCK_KEY + productId,\n        RedisPreheatService.USER_SET_KEY + productId\n    );\n\n    // 执行 Lua 脚本\n    Long result = redisTemplate.execute(seckillScript, keys, userId.toString());\n\n    if (result == 0) {\n        log.info(\"用户 {} 秒杀成功！\", userId);\n        // 秒杀成功，生成订单信息并放入内存队列\n        // 此时订单尚未写入数据库\n        Product product = ... // 可以从缓存或数据库获取商品信息\n        SeckillOrder order = new SeckillOrder();\n        order.setProductId(productId);\n        order.setUserId(userId);\n        order.setOrderPrice(product.getPrice());\n        // 将订单放入队列\n        try {\n            orderQueue.put(order);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    } else if (result == 1) {\n        log.warn(\"用户 {} 秒杀失败：库存不足\", userId);\n    } else if (result == 2) {\n        log.warn(\"用户 {} 秒杀失败：重复下单\", userId);\n    } else {\n        log.error(\"用户 {} 秒杀异常\", userId);\n    }\n}\n```\n#### 异步持久化\n> 创建订单消费者Service\n  - 新建一个OrderConsumeService.java\n  ```Java\n  @Service\n  public class OrderConsumerService {\n    \n    // ... 其他注入的属性 ...\n\n    // 应用启动后，开启一个后台线程\n    @PostConstruct\n    private void startConsumer() {\n        new Thread(() -> {\n            while (true) {\n                try {\n                    SeckillOrder order = seckillService.getOrderQueue().take();\n                    // 2. 循环体内部现在只调用这个新的、带事务的方法\n                    createOrderInDb(order);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    log.error(\"订单消费者线程被中断\", e);\n                    break;\n                } catch (Exception e) {\n                    // 捕获所有其他可能的异常，防止线程意外终止\n                    log.error(\"处理订单时发生未知异常\", e);\n                }\n            }\n        }).start();\n    }\n\n    /**\n     * 3. 【新增】一个公开的、带事务注解的方法，专门用于数据库操作\n     * @param order 从队列中取出的订单信息\n     */\n    @Transactional\n    public void createOrderInDb(SeckillOrder order) {\n        log.info(\"正在创建订单并扣减MySQL库存: {}\", order);\n        \n        // 将所有数据库操作都放在这个方法里\n        orderRepository.save(order);\n        \n        int result = productRepository.deductStock(order.getProductId());\n        if (result == 0) {\n            // 这是一个补偿逻辑，理论上在Redis阶段已经保证了库存充足\n            // 但为了数据最终一致性，如果MySQL库存扣减失败，应抛出异常让事务回滚\n            throw new RuntimeException(\"MySQL a's stock deduction failed for order: \" + order);\n        }\n        \n        log.info(\"数据库订单创建成功\");\n    }\n  }\n  ```\n  - 在 SeckillService 中为 orderQueue 提供一个 getter 方法。\n\n### JMeter压测结果分析与改进\n#### 结果分析\n- 结果：日志显示：处理订单时发生未知异常；数据库信息显示：订单正常创建，但是库存数没有减少；存在`TransactionRequiredException`报错。\n- 分析：\n  - 订单正常创建：说明 orderRepository.save(order) 这行代码执行成功了，并且它的结果被提交到了数据库。\n  - 库存数没有减少：说明 productRepository.deductStock(...) 这行代码没有成功，或者它的结果被回滚了。\n  - 存在`TransactionRequiredException`报错：deductStock() 在执行时，没有找到一个正在运行的事务。\n  - 即，orderRepository.save() 在一个事务里成功了（或者在没有事务的情况下自动提交了），而紧接着的 deductStock() 却发现自己不在任何事务里。但是这两个方法在同一个被@Transactional注解的方法里。所以真正的原因应该是，方法上的@Transactional注解没有生效。**因为这个方法是通过this关键字进行的方法自调用，无法触发AOP代理**。当startConsumer方法在 while 循环里调用 createOrderInDb(order) 时，它实际上是在调用 this.createOrderInDb(order)，绕过了AOP代理，所以无人发现@Transactional注解，事务没有被开启。\n\n#### 改进\n- 注入服务自身，通过代理对象来调用方法。\n- 修改`OrderConsumerService.java`\n```Java\n@Service\npublic class OrderConsumerService {\n    \n    // ... 其他注入的属性 ...\n    @Autowired\n    private SeckillService seckillService;\n\n    // 2. 注入自己（代理对象）\n    // 使用 @Lazy 是为了解决循环依赖的潜在问题\n    @Autowired\n    @Lazy\n    private OrderConsumerService self;\n\n    // 应用启动后，开启一个后台线程\n    @PostConstruct\n    private void startConsumer() {\n        new Thread(() -> {\n            while (true) {\n                try {\n                    SeckillOrder order = seckillService.getOrderQueue().take();\n                    // 3. 【关键改动】通过 self 代理对象来调用事务方法\n                    self.createOrderInDb(order);\n                } catch (InterruptedException e) {\n                    // ...\n                } catch (Exception e) {\n                    // ...\n                }\n            }\n        }).start();\n    }\n\n    /**\n     * 这个方法保持不变，但现在它能被正确地代理了\n     */\n    @Transactional\n    public void createOrderInDb(SeckillOrder order) {\n        // ... 之前的数据库操作逻辑完全不变 ...\n        log.info(\"正在创建订单并扣减MySQL库存: {}\", order);\n        orderRepository.save(order);\n        int result = productRepository.deductStock(order.getProductId());\n        if (result == 0) {\n            throw new RuntimeException(\"MySQL stock deduction failed for order: \" + order);\n        }\n        log.info(\"数据库订单创建成功\");\n    }\n}\n```\n- @Autowired private OrderConsumerService self; 注入的 self 变量，不是 this 对象，而是 Spring 创建的、包含了事务处理逻辑的代理对象。\n- 当调用 self.createOrderInDb(order) 时，请求就从`startConsumer`发到了AOP代理那里。\n- AOP代理会正常地开启事务，然后再让真实对象去执行数据库操作。这样，@Transactional 就重新恢复了它的作用。\n\n- 结果：数据库信息显示正常，库存正确减少，订单正确建立。\n\n### 学学八股\n#### Redis\n- Redis是一个开源的、基于内存的、key-value结构的高性能数据库。\n  - 基于内存：是Redis高性能的根本原因。所有数据都存储在内存中，读写速度极快，远超基于磁盘的数据库。\n  - key-value：数据存储方式非常简单，像一个巨大的HashMap，通过一个唯一的Key来存取一个Value。\n  - 不仅仅是缓存：除了被用于缓存外，也被广泛运用于数据库、消息队列等。\n- 核心原理（为什么快）\n  - 纯内存操作：所有的操作都在内存中完成，完全避免了磁盘I/O这个最耗时的环节。\n  - 单线程模型：Redis的核心网络模型和命令处理是由一个单线程来完成的。无线程切换开销、无锁竞争、I/O多路复用。\n- Redis的原子性与Lua脚本\n  - Redis的单个命令是原子性的，但是多个命令组合在一起，就不是原子性的。\n  - 但Redis允许将一段Lua脚本作为一个整体发送给服务器执行，Redis会保证这个脚本在执行期间不会被任何其他命令打断，从而实现了多个命令的原子性组合。\n- Redis的持久化机制\n  - RDB：在指定的时间间隔内，将内存中的数据快照完整的写入到磁盘上的一个二进制文件中。恢复速度快，文件紧凑。但如果Redis在两次快照之间崩溃，会损失一部分数据。\n  - AOF：将每一条接受到的写命令，以追加的方式写入到一个日志文件中，恢复时，重新执行一遍文件中的所有写命令。数据的安全性更高（最多只丢失1秒的数据），单文件体积大，恢复速度相对较慢。\n- Redis的缓存经典问题\n  - 缓存穿透：查询一个数据库中根本不存在的数据，缓存中自然也没有，导致每次请求都直接打到数据库上，失去了缓存的意义。\n    - 缓存空对象：如果数据库查询结果为空，依然在Redis中缓存一个特殊的空值，并设置一个较短的过期时间。\n    - 布隆过滤器：在Redis前再加一道屏障，用布隆过滤器快速判断请求的数据是否存在。\n  - 缓存击穿：一个热点Key在某个瞬间突然失效，导致海量的并发请求同时涌向这个Key，并全部穿透到数据库，导致数据库瞬时压力过大。\n    - 互斥锁：当缓存失效时，第一个查询请求获取一个互斥锁，然后去加载数据并回设缓存。其他线程则等待锁释放后，直接从缓存中获取数据。\n    - 热点数据永不过期：对极热点的数据设置逻辑过期，由后台线程异步更新。\n  - 缓存雪崩：大量的key在同一时间集中失效，导致瞬时大量的请求都穿透到数据库。\n    - 随机化过期时间：在基础过期时间上，增加一个随机值，避免集中失效。\n    - 高可用架构：通过Redis集群、限流降级等操作，保证即使缓存出现问题，数据库也不会被完全冲垮。","slug":"1-秒杀项目2.0-Redis机制","published":1,"updated":"2025-10-05T11:44:08.779Z","layout":"post","photos":[],"_id":"cmgdn5rh3000b0wuz0a50b21t","content":"<h3 id=\"突破限制：引入Redis机制\"><a href=\"#突破限制：引入Redis机制\" class=\"headerlink\" title=\"突破限制：引入Redis机制\"></a>突破限制：引入Redis机制</h3><p><strong>当前系统V1.3 已经具备的功能：</strong></p>\n<ul>\n<li>异步处理：用户的点击会立刻得到响应。</li>\n<li>流量控制：保护系统不会因过多线程而崩溃</li>\n<li>原子化SQL：数据库操作精准无误</li>\n<li>内存标记：售罄后能快速拒绝请求。</li>\n</ul>\n<p><strong>无法回避的“物理上限”：</strong></p>\n<ul>\n<li>用户体验的断崖式下跌：服务器可能在第一秒就收到了数万甚至数十万的 HTTP 请求。而应用内置的 Tomcat 服务器线程池（比如200个）会瞬间被打满。后续的所有请求，都会在操作系统的 TCP 连接队列中排队，最终大量超时。<ul>\n<li>99% 的用户刷新页面后，看到的是一个永远在“转圈圈”的加载动画，或是冰冷的 “503 Service Unavailable” 错误。</li>\n</ul>\n</li>\n<li>数据库是最终的性能瓶颈：数据库的磁盘I&#x2F;O、网络带宽、以及自身的处理能力成为了整个系统性能的天花板。<ul>\n<li>数据库通常是多个业务的<strong>共享资源</strong>。秒杀业务对数据库的极限压榨，会导致<strong>整个网站的其他核心功能全部瘫痪</strong>。普通用户无法登录、无法浏览其他商品、无法对购物车里的其他商品下单。<strong>为了一个秒杀活动，导致整个电商平台的交易系统停摆，这是任何公司都无法接受的巨大损失。</strong></li>\n</ul>\n</li>\n<li>应用服务器是“单点故障”：应用运行在一个实例上，如果这个应用因为任何原因，比如JVM崩溃或服务器宕机，挂掉，那么整个秒杀服务就会彻底中断。<ul>\n<li><strong>整个秒杀服务彻底消失</strong>，恢复时间未知。</li>\n</ul>\n</li>\n<li>无法水平扩展：所有基于Java内存的并发控制，在多实例部署时都会失效。<ul>\n<li>暴露了架构的僵化和脆弱</li>\n</ul>\n</li>\n</ul>\n<p><strong>Redis能解决什么问题？</strong></p>\n<ul>\n<li>解决了数据库雪崩和用户体验差的问题<ul>\n<li>把高频的库存读写、用户资格判断，从毫秒级的、基于磁盘的MYSQL，转移到了微秒级的、基于内存的Redis。</li>\n<li>99%的读写流量由Redis抗住，每秒可以处理数万甚至数万次请求。</li>\n<li>数据库只负责收尾工作，只有极少数成功抢到资格的用户，它们的订单信息才会异步的、平稳的写入数据库中。</li>\n</ul>\n</li>\n<li>解决了单点故障和无法水平扩展的问题<ul>\n<li>通过将所有需要共享的状态统一放在Redis中，本身的Spring Boot应用本身变成了“无状态”的。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"环境准备与集成\"><a href=\"#环境准备与集成\" class=\"headerlink\" title=\"环境准备与集成\"></a>环境准备与集成</h4><blockquote>\n<p>在 Spring Boot 项目中成功引入并连接到 Redis</p>\n</blockquote>\n<ol>\n<li>安装并运行Redis</li>\n</ol>\n<ul>\n<li>在电脑上，使用docker在后台启动一个名为seckill-redis的Redis容器，并将其6379端口映射到电脑的6379端口。  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d --name seckill-redis -p 6379:6379 redis</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>添加Maven依赖</li>\n</ol>\n<ul>\n<li>在pom.xml文件中，添加新的依赖  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>保存并让IDE重新加载依赖</li>\n</ul>\n<ol start=\"3\">\n<li>配置application.properties</li>\n</ol>\n<ul>\n<li>添加 Redis 的连接信息  <figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ================== Redis Configuration ==================</span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.host</span>=<span class=\"string\">localhost</span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.port</span>=<span class=\"string\">6379</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"4\">\n<li>验证连接</li>\n</ol>\n<ul>\n<li>可以创建一个简单的测试类来验证应用启动时能否成功连接到Redis  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisConnectionTester</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CommandLineRunner</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> StringRedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> redisTemplate.getConnectionFactory().getConnection().ping();</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;Successfully connected to Redis. PING response: &quot;</span> + result);</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">          System.err.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">          System.err.println(<span class=\"string\">&quot;Failed to connect to Redis: &quot;</span> + e.getMessage());</span><br><span class=\"line\">          System.err.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>启动 Spring Boot 应用。在控制台看到了 Successfully connected to Redis 的信息，表示第一阶段就成功。</li>\n</ul>\n<h4 id=\"数据预热与缓存“读”操作\"><a href=\"#数据预热与缓存“读”操作\" class=\"headerlink\" title=\"数据预热与缓存“读”操作\"></a>数据预热与缓存“读”操作</h4><blockquote>\n<p>将查询库存的流量从 MySQL 转移到 Redis。</p>\n</blockquote>\n<ol>\n<li>创建数据预热Service</li>\n</ol>\n<ul>\n<li>在秒杀开始之前，把数据从MYSQL加载到Redis。用启动时加载器来模拟。</li>\n<li>创建<code>RedisPreheatService.java</code>  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisPreheatService</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CommandLineRunner</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">STOCK_KEY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;seckill:stock:&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">PRODUCT_KEY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;seckill:product:&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">USER_SET_KEY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;seckill:users:&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> ProductRepository productRepository; <span class=\"comment\">// 假设你已注入</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 应用启动后自动执行</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 假设我们秒杀的商品ID是 1</span></span><br><span class=\"line\">      <span class=\"type\">long</span> <span class=\"variable\">productId</span> <span class=\"operator\">=</span> <span class=\"number\">1L</span>;</span><br><span class=\"line\">      <span class=\"type\">Product</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> productRepository.findById(productId).orElse(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (product != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 1. 清理旧数据（为了可重复测试）</span></span><br><span class=\"line\">          redisTemplate.delete(STOCK_KEY + productId);</span><br><span class=\"line\">          redisTemplate.delete(USER_SET_KEY + productId);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// 2. 加载库存到 Redis String</span></span><br><span class=\"line\">          redisTemplate.opsForValue().set(STOCK_KEY + productId, product.getStock());</span><br><span class=\"line\"></span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;Product &quot;</span> + productId + <span class=\"string\">&quot; stock preheated to Redis: &quot;</span> + product.getStock());</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>改造SeckillService的checkStock方法</li>\n</ol>\n<ul>\n<li>直接从Redis读数据  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 SeckillService.java 中</span></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> Integer <span class=\"title function_\">checkStock</span><span class=\"params\">(Long productId)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">stockKey</span> <span class=\"operator\">=</span> RedisPreheatService.STOCK_KEY + productId;</span><br><span class=\"line\">  <span class=\"type\">Object</span> <span class=\"variable\">stockObj</span> <span class=\"operator\">=</span> redisTemplate.opsForValue().get(stockKey);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> stockObj != <span class=\"literal\">null</span> ? Integer.parseInt(stockObj.toString()) : -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"核心逻辑迁移（Redis-Lua脚本）\"><a href=\"#核心逻辑迁移（Redis-Lua脚本）\" class=\"headerlink\" title=\"核心逻辑迁移（Redis + Lua脚本）\"></a>核心逻辑迁移（Redis + Lua脚本）</h4><blockquote>\n<p>将最关键的“判断资格&amp;扣减库存”操作，从Java层的锁+数据库，迁移到Redis的原子化Lua脚本。</p>\n</blockquote>\n<ol>\n<li>创建Lua脚本文件</li>\n</ol>\n<ul>\n<li>在 src&#x2F;main&#x2F;resources&#x2F; 目录下，创建一个新文件夹 scripts。</li>\n<li>在 scripts 文件夹里，创建一个新文件 seckill.lua  <figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- seckill.lua</span></span><br><span class=\"line\"><span class=\"comment\">-- KEYS[1]: 库存的 key (e.g., seckill:stock:1)</span></span><br><span class=\"line\"><span class=\"comment\">-- KEYS[2]: 已购买用户集合的 key (e.g., seckill:users:1)</span></span><br><span class=\"line\"><span class=\"comment\">-- ARGV[1]: 当前请求的用户 ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 1. 判断用户是否重复购买</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> redis.call(<span class=\"string\">&#x27;sismember&#x27;</span>, KEYS[<span class=\"number\">2</span>], ARGV[<span class=\"number\">1</span>]) == <span class=\"number\">1</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">2</span> <span class=\"comment\">-- 2 代表重复购买</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 2. 获取库存</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> stock = <span class=\"built_in\">tonumber</span>(redis.call(<span class=\"string\">&#x27;get&#x27;</span>, KEYS[<span class=\"number\">1</span>]))</span><br><span class=\"line\"><span class=\"keyword\">if</span> stock &lt;= <span class=\"number\">0</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span> <span class=\"comment\">-- 1 代表库存不足</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 3. 扣减库存</span></span><br><span class=\"line\">redis.call(<span class=\"string\">&#x27;decr&#x27;</span>, KEYS[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 4. 记录购买用户</span></span><br><span class=\"line\">redis.call(<span class=\"string\">&#x27;sadd&#x27;</span>, KEYS[<span class=\"number\">2</span>], ARGV[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span> <span class=\"comment\">-- 0 代表秒杀成功</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>配置并加载Lua脚本</li>\n</ol>\n<ul>\n<li>创建一个RedisConfig.java文件。用于管理与Redis相关的Bean。  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 【新增】配置并创建 RedisTemplate Bean</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param</span> connectionFactory Spring Boot 自动配置好的连接工厂</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return</span> RedisTemplate 实例</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> RedisTemplate&lt;String, Object&gt; <span class=\"title function_\">redisTemplate</span><span class=\"params\">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 创建 RedisTemplate 对象</span></span><br><span class=\"line\">      RedisTemplate&lt;String, Object&gt; template = <span class=\"keyword\">new</span> <span class=\"title class_\">RedisTemplate</span>&lt;&gt;();</span><br><span class=\"line\">      <span class=\"comment\">// 设置连接工厂</span></span><br><span class=\"line\">      template.setConnectionFactory(connectionFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 创建 JSON 序列化工具</span></span><br><span class=\"line\">      <span class=\"type\">GenericJackson2JsonRedisSerializer</span> <span class=\"variable\">jsonSerializer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">GenericJackson2JsonRedisSerializer</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 设置 Key 的序列化方式为 String</span></span><br><span class=\"line\">      template.setKeySerializer(<span class=\"keyword\">new</span> <span class=\"title class_\">StringRedisSerializer</span>());</span><br><span class=\"line\">      template.setHashKeySerializer(<span class=\"keyword\">new</span> <span class=\"title class_\">StringRedisSerializer</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 设置 Value 的序列化方式为 JSON</span></span><br><span class=\"line\">      template.setValueSerializer(jsonSerializer);</span><br><span class=\"line\">      template.setHashValueSerializer(jsonSerializer);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 使配置生效</span></span><br><span class=\"line\">      template.afterPropertiesSet();</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">return</span> template;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> DefaultRedisScript&lt;Long&gt; <span class=\"title function_\">seckillScript</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      DefaultRedisScript&lt;Long&gt; redisScript = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;();</span><br><span class=\"line\">      redisScript.setScriptSource(<span class=\"keyword\">new</span> <span class=\"title class_\">ResourceScriptSource</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathResource</span>(<span class=\"string\">&quot;scripts/seckill.lua&quot;</span>)));</span><br><span class=\"line\">      redisScript.setResultType(Long.class);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> redisScript;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"3\">\n<li>重构SeckillService的核心秒杀逻辑<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 SeckillService.java 中</span></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> DefaultRedisScript&lt;Long&gt; seckillScript;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们需要一个内存队列来存放成功秒杀的订单信息</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;SeckillOrder&gt; orderQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;(<span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 改造异步执行的后台任务</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">    List&lt;String&gt; keys = Arrays.asList(</span><br><span class=\"line\">        RedisPreheatService.STOCK_KEY + productId,</span><br><span class=\"line\">        RedisPreheatService.USER_SET_KEY + productId</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 Lua 脚本</span></span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> redisTemplate.execute(seckillScript, keys, userId.toString());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;用户 &#123;&#125; 秒杀成功！&quot;</span>, userId);</span><br><span class=\"line\">        <span class=\"comment\">// 秒杀成功，生成订单信息并放入内存队列</span></span><br><span class=\"line\">        <span class=\"comment\">// 此时订单尚未写入数据库</span></span><br><span class=\"line\">        <span class=\"type\">Product</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> ... <span class=\"comment\">// 可以从缓存或数据库获取商品信息</span></span><br><span class=\"line\">        <span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SeckillOrder</span>();</span><br><span class=\"line\">        order.setProductId(productId);</span><br><span class=\"line\">        order.setUserId(userId);</span><br><span class=\"line\">        order.setOrderPrice(product.getPrice());</span><br><span class=\"line\">        <span class=\"comment\">// 将订单放入队列</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            orderQueue.put(order);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            Thread.currentThread().interrupt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (result == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;用户 &#123;&#125; 秒杀失败：库存不足&quot;</span>, userId);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (result == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;用户 &#123;&#125; 秒杀失败：重复下单&quot;</span>, userId);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;用户 &#123;&#125; 秒杀异常&quot;</span>, userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"异步持久化\"><a href=\"#异步持久化\" class=\"headerlink\" title=\"异步持久化\"></a>异步持久化</h4><blockquote>\n<p>创建订单消费者Service</p>\n</blockquote>\n<ul>\n<li>新建一个OrderConsumeService.java  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderConsumerService</span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// ... 其他注入的属性 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 应用启动后，开启一个后台线程</span></span><br><span class=\"line\">  <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startConsumer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                  <span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> seckillService.getOrderQueue().take();</span><br><span class=\"line\">                  <span class=\"comment\">// 2. 循环体内部现在只调用这个新的、带事务的方法</span></span><br><span class=\"line\">                  createOrderInDb(order);</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                  Thread.currentThread().interrupt();</span><br><span class=\"line\">                  log.error(<span class=\"string\">&quot;订单消费者线程被中断&quot;</span>, e);</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// 捕获所有其他可能的异常，防止线程意外终止</span></span><br><span class=\"line\">                  log.error(<span class=\"string\">&quot;处理订单时发生未知异常&quot;</span>, e);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;).start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 3. 【新增】一个公开的、带事务注解的方法，专门用于数据库操作</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param</span> order 从队列中取出的订单信息</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createOrderInDb</span><span class=\"params\">(SeckillOrder order)</span> &#123;</span><br><span class=\"line\">      log.info(<span class=\"string\">&quot;正在创建订单并扣减MySQL库存: &#123;&#125;&quot;</span>, order);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 将所有数据库操作都放在这个方法里</span></span><br><span class=\"line\">      orderRepository.save(order);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> productRepository.deductStock(order.getProductId());</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 这是一个补偿逻辑，理论上在Redis阶段已经保证了库存充足</span></span><br><span class=\"line\">          <span class=\"comment\">// 但为了数据最终一致性，如果MySQL库存扣减失败，应抛出异常让事务回滚</span></span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;MySQL a&#x27;s stock deduction failed for order: &quot;</span> + order);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      log.info(<span class=\"string\">&quot;数据库订单创建成功&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>在 SeckillService 中为 orderQueue 提供一个 getter 方法。</li>\n</ul>\n<h3 id=\"JMeter压测结果分析与改进\"><a href=\"#JMeter压测结果分析与改进\" class=\"headerlink\" title=\"JMeter压测结果分析与改进\"></a>JMeter压测结果分析与改进</h3><h4 id=\"结果分析\"><a href=\"#结果分析\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h4><ul>\n<li>结果：日志显示：处理订单时发生未知异常；数据库信息显示：订单正常创建，但是库存数没有减少；存在<code>TransactionRequiredException</code>报错。</li>\n<li>分析：<ul>\n<li>订单正常创建：说明 orderRepository.save(order) 这行代码执行成功了，并且它的结果被提交到了数据库。</li>\n<li>库存数没有减少：说明 productRepository.deductStock(…) 这行代码没有成功，或者它的结果被回滚了。</li>\n<li>存在<code>TransactionRequiredException</code>报错：deductStock() 在执行时，没有找到一个正在运行的事务。</li>\n<li>即，orderRepository.save() 在一个事务里成功了（或者在没有事务的情况下自动提交了），而紧接着的 deductStock() 却发现自己不在任何事务里。但是这两个方法在同一个被@Transactional注解的方法里。所以真正的原因应该是，方法上的@Transactional注解没有生效。<strong>因为这个方法是通过this关键字进行的方法自调用，无法触发AOP代理</strong>。当startConsumer方法在 while 循环里调用 createOrderInDb(order) 时，它实际上是在调用 this.createOrderInDb(order)，绕过了AOP代理，所以无人发现@Transactional注解，事务没有被开启。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h4><ul>\n<li><p>注入服务自身，通过代理对象来调用方法。</p>\n</li>\n<li><p>修改<code>OrderConsumerService.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderConsumerService</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// ... 其他注入的属性 ...</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SeckillService seckillService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 注入自己（代理对象）</span></span><br><span class=\"line\">    <span class=\"comment\">// 使用 @Lazy 是为了解决循环依赖的潜在问题</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Lazy</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> OrderConsumerService self;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 应用启动后，开启一个后台线程</span></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startConsumer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> seckillService.getOrderQueue().take();</span><br><span class=\"line\">                    <span class=\"comment\">// 3. 【关键改动】通过 self 代理对象来调用事务方法</span></span><br><span class=\"line\">                    self.createOrderInDb(order);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// ...</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// ...</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个方法保持不变，但现在它能被正确地代理了</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createOrderInDb</span><span class=\"params\">(SeckillOrder order)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... 之前的数据库操作逻辑完全不变 ...</span></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;正在创建订单并扣减MySQL库存: &#123;&#125;&quot;</span>, order);</span><br><span class=\"line\">        orderRepository.save(order);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> productRepository.deductStock(order.getProductId());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;MySQL stock deduction failed for order: &quot;</span> + order);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;数据库订单创建成功&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>@Autowired private OrderConsumerService self; 注入的 self 变量，不是 this 对象，而是 Spring 创建的、包含了事务处理逻辑的代理对象。</p>\n</li>\n<li><p>当调用 self.createOrderInDb(order) 时，请求就从<code>startConsumer</code>发到了AOP代理那里。</p>\n</li>\n<li><p>AOP代理会正常地开启事务，然后再让真实对象去执行数据库操作。这样，@Transactional 就重新恢复了它的作用。</p>\n</li>\n<li><p>结果：数据库信息显示正常，库存正确减少，订单正确建立。</p>\n</li>\n</ul>\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h4><ul>\n<li>Redis是一个开源的、基于内存的、key-value结构的高性能数据库。<ul>\n<li>基于内存：是Redis高性能的根本原因。所有数据都存储在内存中，读写速度极快，远超基于磁盘的数据库。</li>\n<li>key-value：数据存储方式非常简单，像一个巨大的HashMap，通过一个唯一的Key来存取一个Value。</li>\n<li>不仅仅是缓存：除了被用于缓存外，也被广泛运用于数据库、消息队列等。</li>\n</ul>\n</li>\n<li>核心原理（为什么快）<ul>\n<li>纯内存操作：所有的操作都在内存中完成，完全避免了磁盘I&#x2F;O这个最耗时的环节。</li>\n<li>单线程模型：Redis的核心网络模型和命令处理是由一个单线程来完成的。无线程切换开销、无锁竞争、I&#x2F;O多路复用。</li>\n</ul>\n</li>\n<li>Redis的原子性与Lua脚本<ul>\n<li>Redis的单个命令是原子性的，但是多个命令组合在一起，就不是原子性的。</li>\n<li>但Redis允许将一段Lua脚本作为一个整体发送给服务器执行，Redis会保证这个脚本在执行期间不会被任何其他命令打断，从而实现了多个命令的原子性组合。</li>\n</ul>\n</li>\n<li>Redis的持久化机制<ul>\n<li>RDB：在指定的时间间隔内，将内存中的数据快照完整的写入到磁盘上的一个二进制文件中。恢复速度快，文件紧凑。但如果Redis在两次快照之间崩溃，会损失一部分数据。</li>\n<li>AOF：将每一条接受到的写命令，以追加的方式写入到一个日志文件中，恢复时，重新执行一遍文件中的所有写命令。数据的安全性更高（最多只丢失1秒的数据），单文件体积大，恢复速度相对较慢。</li>\n</ul>\n</li>\n<li>Redis的缓存经典问题<ul>\n<li>缓存穿透：查询一个数据库中根本不存在的数据，缓存中自然也没有，导致每次请求都直接打到数据库上，失去了缓存的意义。<ul>\n<li>缓存空对象：如果数据库查询结果为空，依然在Redis中缓存一个特殊的空值，并设置一个较短的过期时间。</li>\n<li>布隆过滤器：在Redis前再加一道屏障，用布隆过滤器快速判断请求的数据是否存在。</li>\n</ul>\n</li>\n<li>缓存击穿：一个热点Key在某个瞬间突然失效，导致海量的并发请求同时涌向这个Key，并全部穿透到数据库，导致数据库瞬时压力过大。<ul>\n<li>互斥锁：当缓存失效时，第一个查询请求获取一个互斥锁，然后去加载数据并回设缓存。其他线程则等待锁释放后，直接从缓存中获取数据。</li>\n<li>热点数据永不过期：对极热点的数据设置逻辑过期，由后台线程异步更新。</li>\n</ul>\n</li>\n<li>缓存雪崩：大量的key在同一时间集中失效，导致瞬时大量的请求都穿透到数据库。<ul>\n<li>随机化过期时间：在基础过期时间上，增加一个随机值，避免集中失效。</li>\n<li>高可用架构：通过Redis集群、限流降级等操作，保证即使缓存出现问题，数据库也不会被完全冲垮。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"突破限制：引入Redis机制\"><a href=\"#突破限制：引入Redis机制\" class=\"headerlink\" title=\"突破限制：引入Redis机制\"></a>突破限制：引入Redis机制</h3><p><strong>当前系统V1.3 已经具备的功能：</strong></p>\n<ul>\n<li>异步处理：用户的点击会立刻得到响应。</li>\n<li>流量控制：保护系统不会因过多线程而崩溃</li>\n<li>原子化SQL：数据库操作精准无误</li>\n<li>内存标记：售罄后能快速拒绝请求。</li>\n</ul>\n<p><strong>无法回避的“物理上限”：</strong></p>\n<ul>\n<li>用户体验的断崖式下跌：服务器可能在第一秒就收到了数万甚至数十万的 HTTP 请求。而应用内置的 Tomcat 服务器线程池（比如200个）会瞬间被打满。后续的所有请求，都会在操作系统的 TCP 连接队列中排队，最终大量超时。<ul>\n<li>99% 的用户刷新页面后，看到的是一个永远在“转圈圈”的加载动画，或是冰冷的 “503 Service Unavailable” 错误。</li>\n</ul>\n</li>\n<li>数据库是最终的性能瓶颈：数据库的磁盘I&#x2F;O、网络带宽、以及自身的处理能力成为了整个系统性能的天花板。<ul>\n<li>数据库通常是多个业务的<strong>共享资源</strong>。秒杀业务对数据库的极限压榨，会导致<strong>整个网站的其他核心功能全部瘫痪</strong>。普通用户无法登录、无法浏览其他商品、无法对购物车里的其他商品下单。<strong>为了一个秒杀活动，导致整个电商平台的交易系统停摆，这是任何公司都无法接受的巨大损失。</strong></li>\n</ul>\n</li>\n<li>应用服务器是“单点故障”：应用运行在一个实例上，如果这个应用因为任何原因，比如JVM崩溃或服务器宕机，挂掉，那么整个秒杀服务就会彻底中断。<ul>\n<li><strong>整个秒杀服务彻底消失</strong>，恢复时间未知。</li>\n</ul>\n</li>\n<li>无法水平扩展：所有基于Java内存的并发控制，在多实例部署时都会失效。<ul>\n<li>暴露了架构的僵化和脆弱</li>\n</ul>\n</li>\n</ul>\n<p><strong>Redis能解决什么问题？</strong></p>\n<ul>\n<li>解决了数据库雪崩和用户体验差的问题<ul>\n<li>把高频的库存读写、用户资格判断，从毫秒级的、基于磁盘的MYSQL，转移到了微秒级的、基于内存的Redis。</li>\n<li>99%的读写流量由Redis抗住，每秒可以处理数万甚至数万次请求。</li>\n<li>数据库只负责收尾工作，只有极少数成功抢到资格的用户，它们的订单信息才会异步的、平稳的写入数据库中。</li>\n</ul>\n</li>\n<li>解决了单点故障和无法水平扩展的问题<ul>\n<li>通过将所有需要共享的状态统一放在Redis中，本身的Spring Boot应用本身变成了“无状态”的。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"环境准备与集成\"><a href=\"#环境准备与集成\" class=\"headerlink\" title=\"环境准备与集成\"></a>环境准备与集成</h4><blockquote>\n<p>在 Spring Boot 项目中成功引入并连接到 Redis</p>\n</blockquote>\n<ol>\n<li>安装并运行Redis</li>\n</ol>\n<ul>\n<li>在电脑上，使用docker在后台启动一个名为seckill-redis的Redis容器，并将其6379端口映射到电脑的6379端口。  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d --name seckill-redis -p 6379:6379 redis</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>添加Maven依赖</li>\n</ol>\n<ul>\n<li>在pom.xml文件中，添加新的依赖  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>保存并让IDE重新加载依赖</li>\n</ul>\n<ol start=\"3\">\n<li>配置application.properties</li>\n</ol>\n<ul>\n<li>添加 Redis 的连接信息  <figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ================== Redis Configuration ==================</span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.host</span>=<span class=\"string\">localhost</span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.port</span>=<span class=\"string\">6379</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"4\">\n<li>验证连接</li>\n</ol>\n<ul>\n<li>可以创建一个简单的测试类来验证应用启动时能否成功连接到Redis  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisConnectionTester</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CommandLineRunner</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> StringRedisTemplate redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> redisTemplate.getConnectionFactory().getConnection().ping();</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;Successfully connected to Redis. PING response: &quot;</span> + result);</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">          System.err.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">          System.err.println(<span class=\"string\">&quot;Failed to connect to Redis: &quot;</span> + e.getMessage());</span><br><span class=\"line\">          System.err.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>启动 Spring Boot 应用。在控制台看到了 Successfully connected to Redis 的信息，表示第一阶段就成功。</li>\n</ul>\n<h4 id=\"数据预热与缓存“读”操作\"><a href=\"#数据预热与缓存“读”操作\" class=\"headerlink\" title=\"数据预热与缓存“读”操作\"></a>数据预热与缓存“读”操作</h4><blockquote>\n<p>将查询库存的流量从 MySQL 转移到 Redis。</p>\n</blockquote>\n<ol>\n<li>创建数据预热Service</li>\n</ol>\n<ul>\n<li>在秒杀开始之前，把数据从MYSQL加载到Redis。用启动时加载器来模拟。</li>\n<li>创建<code>RedisPreheatService.java</code>  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisPreheatService</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CommandLineRunner</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">STOCK_KEY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;seckill:stock:&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">PRODUCT_KEY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;seckill:product:&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">USER_SET_KEY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;seckill:users:&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> ProductRepository productRepository; <span class=\"comment\">// 假设你已注入</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 应用启动后自动执行</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">(String... args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 假设我们秒杀的商品ID是 1</span></span><br><span class=\"line\">      <span class=\"type\">long</span> <span class=\"variable\">productId</span> <span class=\"operator\">=</span> <span class=\"number\">1L</span>;</span><br><span class=\"line\">      <span class=\"type\">Product</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> productRepository.findById(productId).orElse(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (product != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 1. 清理旧数据（为了可重复测试）</span></span><br><span class=\"line\">          redisTemplate.delete(STOCK_KEY + productId);</span><br><span class=\"line\">          redisTemplate.delete(USER_SET_KEY + productId);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// 2. 加载库存到 Redis String</span></span><br><span class=\"line\">          redisTemplate.opsForValue().set(STOCK_KEY + productId, product.getStock());</span><br><span class=\"line\"></span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;Product &quot;</span> + productId + <span class=\"string\">&quot; stock preheated to Redis: &quot;</span> + product.getStock());</span><br><span class=\"line\">          System.out.println(<span class=\"string\">&quot;=========================================&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>改造SeckillService的checkStock方法</li>\n</ol>\n<ul>\n<li>直接从Redis读数据  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 SeckillService.java 中</span></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> Integer <span class=\"title function_\">checkStock</span><span class=\"params\">(Long productId)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">stockKey</span> <span class=\"operator\">=</span> RedisPreheatService.STOCK_KEY + productId;</span><br><span class=\"line\">  <span class=\"type\">Object</span> <span class=\"variable\">stockObj</span> <span class=\"operator\">=</span> redisTemplate.opsForValue().get(stockKey);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> stockObj != <span class=\"literal\">null</span> ? Integer.parseInt(stockObj.toString()) : -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"核心逻辑迁移（Redis-Lua脚本）\"><a href=\"#核心逻辑迁移（Redis-Lua脚本）\" class=\"headerlink\" title=\"核心逻辑迁移（Redis + Lua脚本）\"></a>核心逻辑迁移（Redis + Lua脚本）</h4><blockquote>\n<p>将最关键的“判断资格&amp;扣减库存”操作，从Java层的锁+数据库，迁移到Redis的原子化Lua脚本。</p>\n</blockquote>\n<ol>\n<li>创建Lua脚本文件</li>\n</ol>\n<ul>\n<li>在 src&#x2F;main&#x2F;resources&#x2F; 目录下，创建一个新文件夹 scripts。</li>\n<li>在 scripts 文件夹里，创建一个新文件 seckill.lua  <figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- seckill.lua</span></span><br><span class=\"line\"><span class=\"comment\">-- KEYS[1]: 库存的 key (e.g., seckill:stock:1)</span></span><br><span class=\"line\"><span class=\"comment\">-- KEYS[2]: 已购买用户集合的 key (e.g., seckill:users:1)</span></span><br><span class=\"line\"><span class=\"comment\">-- ARGV[1]: 当前请求的用户 ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 1. 判断用户是否重复购买</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> redis.call(<span class=\"string\">&#x27;sismember&#x27;</span>, KEYS[<span class=\"number\">2</span>], ARGV[<span class=\"number\">1</span>]) == <span class=\"number\">1</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">2</span> <span class=\"comment\">-- 2 代表重复购买</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 2. 获取库存</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> stock = <span class=\"built_in\">tonumber</span>(redis.call(<span class=\"string\">&#x27;get&#x27;</span>, KEYS[<span class=\"number\">1</span>]))</span><br><span class=\"line\"><span class=\"keyword\">if</span> stock &lt;= <span class=\"number\">0</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span> <span class=\"comment\">-- 1 代表库存不足</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 3. 扣减库存</span></span><br><span class=\"line\">redis.call(<span class=\"string\">&#x27;decr&#x27;</span>, KEYS[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 4. 记录购买用户</span></span><br><span class=\"line\">redis.call(<span class=\"string\">&#x27;sadd&#x27;</span>, KEYS[<span class=\"number\">2</span>], ARGV[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span> <span class=\"comment\">-- 0 代表秒杀成功</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>配置并加载Lua脚本</li>\n</ol>\n<ul>\n<li>创建一个RedisConfig.java文件。用于管理与Redis相关的Bean。  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 【新增】配置并创建 RedisTemplate Bean</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param</span> connectionFactory Spring Boot 自动配置好的连接工厂</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return</span> RedisTemplate 实例</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> RedisTemplate&lt;String, Object&gt; <span class=\"title function_\">redisTemplate</span><span class=\"params\">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 创建 RedisTemplate 对象</span></span><br><span class=\"line\">      RedisTemplate&lt;String, Object&gt; template = <span class=\"keyword\">new</span> <span class=\"title class_\">RedisTemplate</span>&lt;&gt;();</span><br><span class=\"line\">      <span class=\"comment\">// 设置连接工厂</span></span><br><span class=\"line\">      template.setConnectionFactory(connectionFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 创建 JSON 序列化工具</span></span><br><span class=\"line\">      <span class=\"type\">GenericJackson2JsonRedisSerializer</span> <span class=\"variable\">jsonSerializer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">GenericJackson2JsonRedisSerializer</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 设置 Key 的序列化方式为 String</span></span><br><span class=\"line\">      template.setKeySerializer(<span class=\"keyword\">new</span> <span class=\"title class_\">StringRedisSerializer</span>());</span><br><span class=\"line\">      template.setHashKeySerializer(<span class=\"keyword\">new</span> <span class=\"title class_\">StringRedisSerializer</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 设置 Value 的序列化方式为 JSON</span></span><br><span class=\"line\">      template.setValueSerializer(jsonSerializer);</span><br><span class=\"line\">      template.setHashValueSerializer(jsonSerializer);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 使配置生效</span></span><br><span class=\"line\">      template.afterPropertiesSet();</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">return</span> template;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> DefaultRedisScript&lt;Long&gt; <span class=\"title function_\">seckillScript</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      DefaultRedisScript&lt;Long&gt; redisScript = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultRedisScript</span>&lt;&gt;();</span><br><span class=\"line\">      redisScript.setScriptSource(<span class=\"keyword\">new</span> <span class=\"title class_\">ResourceScriptSource</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathResource</span>(<span class=\"string\">&quot;scripts/seckill.lua&quot;</span>)));</span><br><span class=\"line\">      redisScript.setResultType(Long.class);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> redisScript;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"3\">\n<li>重构SeckillService的核心秒杀逻辑<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 SeckillService.java 中</span></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> DefaultRedisScript&lt;Long&gt; seckillScript;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们需要一个内存队列来存放成功秒杀的订单信息</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;SeckillOrder&gt; orderQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;(<span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 改造异步执行的后台任务</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeSeckill</span><span class=\"params\">(Long productId, Long userId)</span> &#123;</span><br><span class=\"line\">    List&lt;String&gt; keys = Arrays.asList(</span><br><span class=\"line\">        RedisPreheatService.STOCK_KEY + productId,</span><br><span class=\"line\">        RedisPreheatService.USER_SET_KEY + productId</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 执行 Lua 脚本</span></span><br><span class=\"line\">    <span class=\"type\">Long</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> redisTemplate.execute(seckillScript, keys, userId.toString());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;用户 &#123;&#125; 秒杀成功！&quot;</span>, userId);</span><br><span class=\"line\">        <span class=\"comment\">// 秒杀成功，生成订单信息并放入内存队列</span></span><br><span class=\"line\">        <span class=\"comment\">// 此时订单尚未写入数据库</span></span><br><span class=\"line\">        <span class=\"type\">Product</span> <span class=\"variable\">product</span> <span class=\"operator\">=</span> ... <span class=\"comment\">// 可以从缓存或数据库获取商品信息</span></span><br><span class=\"line\">        <span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SeckillOrder</span>();</span><br><span class=\"line\">        order.setProductId(productId);</span><br><span class=\"line\">        order.setUserId(userId);</span><br><span class=\"line\">        order.setOrderPrice(product.getPrice());</span><br><span class=\"line\">        <span class=\"comment\">// 将订单放入队列</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            orderQueue.put(order);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            Thread.currentThread().interrupt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (result == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;用户 &#123;&#125; 秒杀失败：库存不足&quot;</span>, userId);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (result == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;用户 &#123;&#125; 秒杀失败：重复下单&quot;</span>, userId);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;用户 &#123;&#125; 秒杀异常&quot;</span>, userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"异步持久化\"><a href=\"#异步持久化\" class=\"headerlink\" title=\"异步持久化\"></a>异步持久化</h4><blockquote>\n<p>创建订单消费者Service</p>\n</blockquote>\n<ul>\n<li>新建一个OrderConsumeService.java  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderConsumerService</span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// ... 其他注入的属性 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 应用启动后，开启一个后台线程</span></span><br><span class=\"line\">  <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startConsumer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                  <span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> seckillService.getOrderQueue().take();</span><br><span class=\"line\">                  <span class=\"comment\">// 2. 循环体内部现在只调用这个新的、带事务的方法</span></span><br><span class=\"line\">                  createOrderInDb(order);</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                  Thread.currentThread().interrupt();</span><br><span class=\"line\">                  log.error(<span class=\"string\">&quot;订单消费者线程被中断&quot;</span>, e);</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// 捕获所有其他可能的异常，防止线程意外终止</span></span><br><span class=\"line\">                  log.error(<span class=\"string\">&quot;处理订单时发生未知异常&quot;</span>, e);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;).start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 3. 【新增】一个公开的、带事务注解的方法，专门用于数据库操作</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param</span> order 从队列中取出的订单信息</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createOrderInDb</span><span class=\"params\">(SeckillOrder order)</span> &#123;</span><br><span class=\"line\">      log.info(<span class=\"string\">&quot;正在创建订单并扣减MySQL库存: &#123;&#125;&quot;</span>, order);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">// 将所有数据库操作都放在这个方法里</span></span><br><span class=\"line\">      orderRepository.save(order);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> productRepository.deductStock(order.getProductId());</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 这是一个补偿逻辑，理论上在Redis阶段已经保证了库存充足</span></span><br><span class=\"line\">          <span class=\"comment\">// 但为了数据最终一致性，如果MySQL库存扣减失败，应抛出异常让事务回滚</span></span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;MySQL a&#x27;s stock deduction failed for order: &quot;</span> + order);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      log.info(<span class=\"string\">&quot;数据库订单创建成功&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>在 SeckillService 中为 orderQueue 提供一个 getter 方法。</li>\n</ul>\n<h3 id=\"JMeter压测结果分析与改进\"><a href=\"#JMeter压测结果分析与改进\" class=\"headerlink\" title=\"JMeter压测结果分析与改进\"></a>JMeter压测结果分析与改进</h3><h4 id=\"结果分析\"><a href=\"#结果分析\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h4><ul>\n<li>结果：日志显示：处理订单时发生未知异常；数据库信息显示：订单正常创建，但是库存数没有减少；存在<code>TransactionRequiredException</code>报错。</li>\n<li>分析：<ul>\n<li>订单正常创建：说明 orderRepository.save(order) 这行代码执行成功了，并且它的结果被提交到了数据库。</li>\n<li>库存数没有减少：说明 productRepository.deductStock(…) 这行代码没有成功，或者它的结果被回滚了。</li>\n<li>存在<code>TransactionRequiredException</code>报错：deductStock() 在执行时，没有找到一个正在运行的事务。</li>\n<li>即，orderRepository.save() 在一个事务里成功了（或者在没有事务的情况下自动提交了），而紧接着的 deductStock() 却发现自己不在任何事务里。但是这两个方法在同一个被@Transactional注解的方法里。所以真正的原因应该是，方法上的@Transactional注解没有生效。<strong>因为这个方法是通过this关键字进行的方法自调用，无法触发AOP代理</strong>。当startConsumer方法在 while 循环里调用 createOrderInDb(order) 时，它实际上是在调用 this.createOrderInDb(order)，绕过了AOP代理，所以无人发现@Transactional注解，事务没有被开启。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h4><ul>\n<li><p>注入服务自身，通过代理对象来调用方法。</p>\n</li>\n<li><p>修改<code>OrderConsumerService.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderConsumerService</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// ... 其他注入的属性 ...</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SeckillService seckillService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 注入自己（代理对象）</span></span><br><span class=\"line\">    <span class=\"comment\">// 使用 @Lazy 是为了解决循环依赖的潜在问题</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Lazy</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> OrderConsumerService self;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 应用启动后，开启一个后台线程</span></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startConsumer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">SeckillOrder</span> <span class=\"variable\">order</span> <span class=\"operator\">=</span> seckillService.getOrderQueue().take();</span><br><span class=\"line\">                    <span class=\"comment\">// 3. 【关键改动】通过 self 代理对象来调用事务方法</span></span><br><span class=\"line\">                    self.createOrderInDb(order);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// ...</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// ...</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个方法保持不变，但现在它能被正确地代理了</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createOrderInDb</span><span class=\"params\">(SeckillOrder order)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ... 之前的数据库操作逻辑完全不变 ...</span></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;正在创建订单并扣减MySQL库存: &#123;&#125;&quot;</span>, order);</span><br><span class=\"line\">        orderRepository.save(order);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> productRepository.deductStock(order.getProductId());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;MySQL stock deduction failed for order: &quot;</span> + order);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;数据库订单创建成功&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>@Autowired private OrderConsumerService self; 注入的 self 变量，不是 this 对象，而是 Spring 创建的、包含了事务处理逻辑的代理对象。</p>\n</li>\n<li><p>当调用 self.createOrderInDb(order) 时，请求就从<code>startConsumer</code>发到了AOP代理那里。</p>\n</li>\n<li><p>AOP代理会正常地开启事务，然后再让真实对象去执行数据库操作。这样，@Transactional 就重新恢复了它的作用。</p>\n</li>\n<li><p>结果：数据库信息显示正常，库存正确减少，订单正确建立。</p>\n</li>\n</ul>\n<h3 id=\"学学八股\"><a href=\"#学学八股\" class=\"headerlink\" title=\"学学八股\"></a>学学八股</h3><h4 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h4><ul>\n<li>Redis是一个开源的、基于内存的、key-value结构的高性能数据库。<ul>\n<li>基于内存：是Redis高性能的根本原因。所有数据都存储在内存中，读写速度极快，远超基于磁盘的数据库。</li>\n<li>key-value：数据存储方式非常简单，像一个巨大的HashMap，通过一个唯一的Key来存取一个Value。</li>\n<li>不仅仅是缓存：除了被用于缓存外，也被广泛运用于数据库、消息队列等。</li>\n</ul>\n</li>\n<li>核心原理（为什么快）<ul>\n<li>纯内存操作：所有的操作都在内存中完成，完全避免了磁盘I&#x2F;O这个最耗时的环节。</li>\n<li>单线程模型：Redis的核心网络模型和命令处理是由一个单线程来完成的。无线程切换开销、无锁竞争、I&#x2F;O多路复用。</li>\n</ul>\n</li>\n<li>Redis的原子性与Lua脚本<ul>\n<li>Redis的单个命令是原子性的，但是多个命令组合在一起，就不是原子性的。</li>\n<li>但Redis允许将一段Lua脚本作为一个整体发送给服务器执行，Redis会保证这个脚本在执行期间不会被任何其他命令打断，从而实现了多个命令的原子性组合。</li>\n</ul>\n</li>\n<li>Redis的持久化机制<ul>\n<li>RDB：在指定的时间间隔内，将内存中的数据快照完整的写入到磁盘上的一个二进制文件中。恢复速度快，文件紧凑。但如果Redis在两次快照之间崩溃，会损失一部分数据。</li>\n<li>AOF：将每一条接受到的写命令，以追加的方式写入到一个日志文件中，恢复时，重新执行一遍文件中的所有写命令。数据的安全性更高（最多只丢失1秒的数据），单文件体积大，恢复速度相对较慢。</li>\n</ul>\n</li>\n<li>Redis的缓存经典问题<ul>\n<li>缓存穿透：查询一个数据库中根本不存在的数据，缓存中自然也没有，导致每次请求都直接打到数据库上，失去了缓存的意义。<ul>\n<li>缓存空对象：如果数据库查询结果为空，依然在Redis中缓存一个特殊的空值，并设置一个较短的过期时间。</li>\n<li>布隆过滤器：在Redis前再加一道屏障，用布隆过滤器快速判断请求的数据是否存在。</li>\n</ul>\n</li>\n<li>缓存击穿：一个热点Key在某个瞬间突然失效，导致海量的并发请求同时涌向这个Key，并全部穿透到数据库，导致数据库瞬时压力过大。<ul>\n<li>互斥锁：当缓存失效时，第一个查询请求获取一个互斥锁，然后去加载数据并回设缓存。其他线程则等待锁释放后，直接从缓存中获取数据。</li>\n<li>热点数据永不过期：对极热点的数据设置逻辑过期，由后台线程异步更新。</li>\n</ul>\n</li>\n<li>缓存雪崩：大量的key在同一时间集中失效，导致瞬时大量的请求都穿透到数据库。<ul>\n<li>随机化过期时间：在基础过期时间上，增加一个随机值，避免集中失效。</li>\n<li>高可用架构：通过Redis集群、限流降级等操作，保证即使缓存出现问题，数据库也不会被完全冲垮。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"建站要闻","poster":{"topic":"标题上方的小字","headline":"大标题","caption":"标题下方的小字","color":"标题颜色"},"date":"2025-05-30T16:54:49.000Z","description":null,"cover":null,"banner":null,"sticky":null,"mermaid":null,"katex":null,"mathjax":null,"topic":null,"author":null,"references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n### 一、为什么要搭建个人博客？\n\n- 技术成长的记录工具\n- 让输入变输出，提高思维表达\n\n------\n\n### 二、搭建流程\n\n#### 1. 环境准备&初始化博客项目\n\n环境准备和初始化博客比较简单，我当时参考这个文章，非常顺利。\n\n{% link https://blog.csdn.net/2401_83582688/article/details/144380760 %}\n\n#### 2. 更换主题\n\n可以在hexo主题页面选择自己喜欢的主题：\n\n{% link https://hexo.io/themes/ %}\n\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202505312013126.png hexo的主题 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202505312013126.png%}\n\n我选择了第一眼就非常喜欢的stellar主题，这个主题有非常完整的文档说明，使用这个主题的博客也很多，所以大多数问题都可以通过文档和教程解决。\n\n{% link https://xaoxuu.com/wiki/stellar %}\n\n#### 3. 遇到的问题以及解决方法\n\n1. ##### 部署&域名\n\n   在初始化博客和更换主题后，个人博客还是由本地服务器模拟的，即通过hexo s 命令启动，浏览器显示的URL为https://localhost:4000，所以后面进行了部署，关于部署，我参考了这位博主的文章：\n\n   {% link https://www.panoshu.top/blog/fbbe79ce/ %}\n\n   一开始选择的是hexo+GitHub Pages +vercel的方案，这个方案完全免费，上手部署起来也很顺利。但是由于在更新到GitHub时总是timeout，遂放弃这个方案，转而hexo+vercel，也是免费+顺利的。强烈推荐第二种方案！\n\n   关于域名，只需要去合适的域名购买网站上购买一个域名，然后绑定到vercel的project上就可以。\n\n2. ##### 页脚设计\n\n   在原有主题的基础上参考教程加入了访客统计和运行天数统计。\n\n   {% link https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/ %}\n\n3. ##### 字体\n\n   更改字体。\n\n   {% link https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/ %}\n\n\n\n\n","source":"_posts/从零开始搭建个人博客.md","raw":"---\ntitle: 建站要闻\ntags: [hexo,stellar,vercel]\ncategories: [blog搭建]\nposter:\n  topic: 标题上方的小字\n  headline: 大标题\n  caption: 标题下方的小字\n  color: 标题颜色\ndate: 2025-05-31 00:54:49\ndescription:\ncover:\nbanner:\nsticky:\nmermaid:\nkatex:\nmathjax:\ntopic:\nauthor:\nreferences:\ncomments:\nindexing:\nbreadcrumb:\nleftbar:\nrightbar:\nh1:\ntype: tech\n---\n\n### 一、为什么要搭建个人博客？\n\n- 技术成长的记录工具\n- 让输入变输出，提高思维表达\n\n------\n\n### 二、搭建流程\n\n#### 1. 环境准备&初始化博客项目\n\n环境准备和初始化博客比较简单，我当时参考这个文章，非常顺利。\n\n{% link https://blog.csdn.net/2401_83582688/article/details/144380760 %}\n\n#### 2. 更换主题\n\n可以在hexo主题页面选择自己喜欢的主题：\n\n{% link https://hexo.io/themes/ %}\n\n{% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202505312013126.png hexo的主题 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202505312013126.png%}\n\n我选择了第一眼就非常喜欢的stellar主题，这个主题有非常完整的文档说明，使用这个主题的博客也很多，所以大多数问题都可以通过文档和教程解决。\n\n{% link https://xaoxuu.com/wiki/stellar %}\n\n#### 3. 遇到的问题以及解决方法\n\n1. ##### 部署&域名\n\n   在初始化博客和更换主题后，个人博客还是由本地服务器模拟的，即通过hexo s 命令启动，浏览器显示的URL为https://localhost:4000，所以后面进行了部署，关于部署，我参考了这位博主的文章：\n\n   {% link https://www.panoshu.top/blog/fbbe79ce/ %}\n\n   一开始选择的是hexo+GitHub Pages +vercel的方案，这个方案完全免费，上手部署起来也很顺利。但是由于在更新到GitHub时总是timeout，遂放弃这个方案，转而hexo+vercel，也是免费+顺利的。强烈推荐第二种方案！\n\n   关于域名，只需要去合适的域名购买网站上购买一个域名，然后绑定到vercel的project上就可以。\n\n2. ##### 页脚设计\n\n   在原有主题的基础上参考教程加入了访客统计和运行天数统计。\n\n   {% link https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/ %}\n\n3. ##### 字体\n\n   更改字体。\n\n   {% link https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/ %}\n\n\n\n\n","slug":"从零开始搭建个人博客","published":1,"updated":"2025-09-25T01:09:14.444Z","layout":"post","photos":[],"_id":"cmgdn5rh5000f0wuz89xtbedd","content":"<h3 id=\"一、为什么要搭建个人博客？\"><a href=\"#一、为什么要搭建个人博客？\" class=\"headerlink\" title=\"一、为什么要搭建个人博客？\"></a>一、为什么要搭建个人博客？</h3><ul>\n<li>技术成长的记录工具</li>\n<li>让输入变输出，提高思维表达</li>\n</ul>\n<hr>\n<h3 id=\"二、搭建流程\"><a href=\"#二、搭建流程\" class=\"headerlink\" title=\"二、搭建流程\"></a>二、搭建流程</h3><h4 id=\"1-环境准备-初始化博客项目\"><a href=\"#1-环境准备-初始化博客项目\" class=\"headerlink\" title=\"1. 环境准备&amp;初始化博客项目\"></a>1. 环境准备&amp;初始化博客项目</h4><p>环境准备和初始化博客比较简单，我当时参考这个文章，非常顺利。</p>\n<div class=\"tag-plugin link dis-select\"><a class=\"link-card plain\" title=\"\" href=\"https://blog.csdn.net/2401_83582688/article/details/144380760\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" cardlink api=\"https://site-info-api-beta.vercel.app/api/v1?url=https://blog.csdn.net/2401_83582688/article/details/144380760\" autofill=\"title,icon\"><div class=\"left\"><span class=\"title\">https://blog.csdn.net/2401_83582688/article/details/144380760</span><span class=\"cap link footnote\">https://blog.csdn.net/2401_83582688/article/details/144380760</span></div><div class=\"right\"><div class=\"lazy img\" data-bg=\"https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg\"></div></div></a></div>\n\n<h4 id=\"2-更换主题\"><a href=\"#2-更换主题\" class=\"headerlink\" title=\"2. 更换主题\"></a>2. 更换主题</h4><p>可以在hexo主题页面选择自己喜欢的主题：</p>\n<div class=\"tag-plugin link dis-select\"><a class=\"link-card plain\" title=\"\" href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" cardlink api=\"https://site-info-api-beta.vercel.app/api/v1?url=https://hexo.io/themes/\" autofill=\"title,icon\"><div class=\"left\"><span class=\"title\">https://hexo.io/themes/</span><span class=\"cap link footnote\">https://hexo.io/themes/</span></div><div class=\"right\"><div class=\"lazy img\" data-bg=\"https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg\"></div></div></a></div>\n\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202505312013126.png\" alt=\"hexo的主题\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"hexo的主题\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202505312013126.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">hexo的主题</span></div></div>\n\n<p>我选择了第一眼就非常喜欢的stellar主题，这个主题有非常完整的文档说明，使用这个主题的博客也很多，所以大多数问题都可以通过文档和教程解决。</p>\n<div class=\"tag-plugin link dis-select\"><a class=\"link-card plain\" title=\"\" href=\"https://xaoxuu.com/wiki/stellar\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" cardlink api=\"https://site-info-api-beta.vercel.app/api/v1?url=https://xaoxuu.com/wiki/stellar\" autofill=\"title,icon\"><div class=\"left\"><span class=\"title\">https://xaoxuu.com/wiki/stellar</span><span class=\"cap link footnote\">https://xaoxuu.com/wiki/stellar</span></div><div class=\"right\"><div class=\"lazy img\" data-bg=\"https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg\"></div></div></a></div>\n\n<h4 id=\"3-遇到的问题以及解决方法\"><a href=\"#3-遇到的问题以及解决方法\" class=\"headerlink\" title=\"3. 遇到的问题以及解决方法\"></a>3. 遇到的问题以及解决方法</h4><ol>\n<li><h5 id=\"部署-域名\"><a href=\"#部署-域名\" class=\"headerlink\" title=\"部署&amp;域名\"></a>部署&amp;域名</h5><p>在初始化博客和更换主题后，个人博客还是由本地服务器模拟的，即通过hexo s 命令启动，浏览器显示的URL为<a href=\"https://localhost:4000，所以后面进行了部署，关于部署，我参考了这位博主的文章：\">https://localhost:4000，所以后面进行了部署，关于部署，我参考了这位博主的文章：</a></p>\n<div class=\"tag-plugin link dis-select\"><a class=\"link-card plain\" title=\"\" href=\"https://www.panoshu.top/blog/fbbe79ce/\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" cardlink api=\"https://site-info-api-beta.vercel.app/api/v1?url=https://www.panoshu.top/blog/fbbe79ce/\" autofill=\"title,icon\"><div class=\"left\"><span class=\"title\">https://www.panoshu.top/blog/fbbe79ce/</span><span class=\"cap link footnote\">https://www.panoshu.top/blog/fbbe79ce/</span></div><div class=\"right\"><div class=\"lazy img\" data-bg=\"https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg\"></div></div></a></div>\n\n<p>一开始选择的是hexo+GitHub Pages +vercel的方案，这个方案完全免费，上手部署起来也很顺利。但是由于在更新到GitHub时总是timeout，遂放弃这个方案，转而hexo+vercel，也是免费+顺利的。强烈推荐第二种方案！</p>\n<p>关于域名，只需要去合适的域名购买网站上购买一个域名，然后绑定到vercel的project上就可以。</p>\n</li>\n<li><h5 id=\"页脚设计\"><a href=\"#页脚设计\" class=\"headerlink\" title=\"页脚设计\"></a>页脚设计</h5><p>在原有主题的基础上参考教程加入了访客统计和运行天数统计。</p>\n<div class=\"tag-plugin link dis-select\"><a class=\"link-card plain\" title=\"\" href=\"https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" cardlink api=\"https://site-info-api-beta.vercel.app/api/v1?url=https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/\" autofill=\"title,icon\"><div class=\"left\"><span class=\"title\">https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/</span><span class=\"cap link footnote\">https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/</span></div><div class=\"right\"><div class=\"lazy img\" data-bg=\"https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg\"></div></div></a></div>\n</li>\n<li><h5 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h5><p>更改字体。</p>\n<div class=\"tag-plugin link dis-select\"><a class=\"link-card plain\" title=\"\" href=\"https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" cardlink api=\"https://site-info-api-beta.vercel.app/api/v1?url=https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/\" autofill=\"title,icon\"><div class=\"left\"><span class=\"title\">https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/</span><span class=\"cap link footnote\">https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/</span></div><div class=\"right\"><div class=\"lazy img\" data-bg=\"https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg\"></div></div></a></div></li>\n</ol>\n","excerpt":"","more":"<h3 id=\"一、为什么要搭建个人博客？\"><a href=\"#一、为什么要搭建个人博客？\" class=\"headerlink\" title=\"一、为什么要搭建个人博客？\"></a>一、为什么要搭建个人博客？</h3><ul>\n<li>技术成长的记录工具</li>\n<li>让输入变输出，提高思维表达</li>\n</ul>\n<hr>\n<h3 id=\"二、搭建流程\"><a href=\"#二、搭建流程\" class=\"headerlink\" title=\"二、搭建流程\"></a>二、搭建流程</h3><h4 id=\"1-环境准备-初始化博客项目\"><a href=\"#1-环境准备-初始化博客项目\" class=\"headerlink\" title=\"1. 环境准备&amp;初始化博客项目\"></a>1. 环境准备&amp;初始化博客项目</h4><p>环境准备和初始化博客比较简单，我当时参考这个文章，非常顺利。</p>\n<div class=\"tag-plugin link dis-select\"><a class=\"link-card plain\" title=\"\" href=\"https://blog.csdn.net/2401_83582688/article/details/144380760\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" cardlink api=\"https://site-info-api-beta.vercel.app/api/v1?url=https://blog.csdn.net/2401_83582688/article/details/144380760\" autofill=\"title,icon\"><div class=\"left\"><span class=\"title\">https://blog.csdn.net/2401_83582688/article/details/144380760</span><span class=\"cap link footnote\">https://blog.csdn.net/2401_83582688/article/details/144380760</span></div><div class=\"right\"><div class=\"lazy img\" data-bg=\"https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg\"></div></div></a></div>\n\n<h4 id=\"2-更换主题\"><a href=\"#2-更换主题\" class=\"headerlink\" title=\"2. 更换主题\"></a>2. 更换主题</h4><p>可以在hexo主题页面选择自己喜欢的主题：</p>\n<div class=\"tag-plugin link dis-select\"><a class=\"link-card plain\" title=\"\" href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" cardlink api=\"https://site-info-api-beta.vercel.app/api/v1?url=https://hexo.io/themes/\" autofill=\"title,icon\"><div class=\"left\"><span class=\"title\">https://hexo.io/themes/</span><span class=\"cap link footnote\">https://hexo.io/themes/</span></div><div class=\"right\"><div class=\"lazy img\" data-bg=\"https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg\"></div></div></a></div>\n\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202505312013126.png\" alt=\"hexo的主题\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"hexo的主题\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202505312013126.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">hexo的主题</span></div></div>\n\n<p>我选择了第一眼就非常喜欢的stellar主题，这个主题有非常完整的文档说明，使用这个主题的博客也很多，所以大多数问题都可以通过文档和教程解决。</p>\n<div class=\"tag-plugin link dis-select\"><a class=\"link-card plain\" title=\"\" href=\"https://xaoxuu.com/wiki/stellar\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" cardlink api=\"https://site-info-api-beta.vercel.app/api/v1?url=https://xaoxuu.com/wiki/stellar\" autofill=\"title,icon\"><div class=\"left\"><span class=\"title\">https://xaoxuu.com/wiki/stellar</span><span class=\"cap link footnote\">https://xaoxuu.com/wiki/stellar</span></div><div class=\"right\"><div class=\"lazy img\" data-bg=\"https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg\"></div></div></a></div>\n\n<h4 id=\"3-遇到的问题以及解决方法\"><a href=\"#3-遇到的问题以及解决方法\" class=\"headerlink\" title=\"3. 遇到的问题以及解决方法\"></a>3. 遇到的问题以及解决方法</h4><ol>\n<li><h5 id=\"部署-域名\"><a href=\"#部署-域名\" class=\"headerlink\" title=\"部署&amp;域名\"></a>部署&amp;域名</h5><p>在初始化博客和更换主题后，个人博客还是由本地服务器模拟的，即通过hexo s 命令启动，浏览器显示的URL为<a href=\"https://localhost:4000，所以后面进行了部署，关于部署，我参考了这位博主的文章：\">https://localhost:4000，所以后面进行了部署，关于部署，我参考了这位博主的文章：</a></p>\n<div class=\"tag-plugin link dis-select\"><a class=\"link-card plain\" title=\"\" href=\"https://www.panoshu.top/blog/fbbe79ce/\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" cardlink api=\"https://site-info-api-beta.vercel.app/api/v1?url=https://www.panoshu.top/blog/fbbe79ce/\" autofill=\"title,icon\"><div class=\"left\"><span class=\"title\">https://www.panoshu.top/blog/fbbe79ce/</span><span class=\"cap link footnote\">https://www.panoshu.top/blog/fbbe79ce/</span></div><div class=\"right\"><div class=\"lazy img\" data-bg=\"https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg\"></div></div></a></div>\n\n<p>一开始选择的是hexo+GitHub Pages +vercel的方案，这个方案完全免费，上手部署起来也很顺利。但是由于在更新到GitHub时总是timeout，遂放弃这个方案，转而hexo+vercel，也是免费+顺利的。强烈推荐第二种方案！</p>\n<p>关于域名，只需要去合适的域名购买网站上购买一个域名，然后绑定到vercel的project上就可以。</p>\n</li>\n<li><h5 id=\"页脚设计\"><a href=\"#页脚设计\" class=\"headerlink\" title=\"页脚设计\"></a>页脚设计</h5><p>在原有主题的基础上参考教程加入了访客统计和运行天数统计。</p>\n<div class=\"tag-plugin link dis-select\"><a class=\"link-card plain\" title=\"\" href=\"https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" cardlink api=\"https://site-info-api-beta.vercel.app/api/v1?url=https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/\" autofill=\"title,icon\"><div class=\"left\"><span class=\"title\">https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/</span><span class=\"cap link footnote\">https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/</span></div><div class=\"right\"><div class=\"lazy img\" data-bg=\"https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg\"></div></div></a></div>\n</li>\n<li><h5 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h5><p>更改字体。</p>\n<div class=\"tag-plugin link dis-select\"><a class=\"link-card plain\" title=\"\" href=\"https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" cardlink api=\"https://site-info-api-beta.vercel.app/api/v1?url=https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/\" autofill=\"title,icon\"><div class=\"left\"><span class=\"title\">https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/</span><span class=\"cap link footnote\">https://blog.bxzdyg.cn/p/使用Hexo和Stellar搭建个人博客网站/</span></div><div class=\"right\"><div class=\"lazy img\" data-bg=\"https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg\"></div></div></a></div></li>\n</ol>\n"},{"title":"论文阅读-A Survey on Long-Video Storytelling Generation:Architectures, Consistency, and Cinematic Quality","poster":{"topic":"标题上方的小字","headline":"大标题","caption":"标题下方的小字","color":"标题颜色"},"date":"2025-09-12T05:34:02.000Z","description":"老师任务：“连接你的课题，读一下这篇综述，并沿着参考文献好好追踪一下视频aigc的技术，写一篇读后文（最好配合一些复现数据），结合这些，寻找一个点，开学前写一篇小论文的初稿出来，有没有问题。”","cover":null,"banner":null,"sticky":null,"mermaid":null,"katex":null,"mathjax":null,"topic":null,"author":null,"references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n\n### 一、论文内容\n  详细调研了32篇关于视频生成的论文，以确定决定AIGC视频生成质量的关键架构组件和训练策略。\n  #### 1. 长视频生成方法的架构分类\n  {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121404717.png 长视频生成方法的架构分类 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121404717.png%}\n  ##### 1.1 关键帧生成+插帧\n  技术核心： 解耦“内容”与“运动”。\n  \n  阶段一：关键帧生成 \n  技术： 使用强大的文本到图像模型 (如 Stable Diffusion, DALL-E) 或 低频采样的文本到视频模型，生成在时间上稀疏但内容上关键的画面。这些帧定义了场景的主要布局、主体和语义。此阶段专注于空间域的质量和语义准确性。\n\n  阶段二：帧插值/运动生成\n  技术： 使用视频帧插值模型或运动填充模型。这些模型通常是轻量的，专注于学习两个帧之间的光流或潜在运动表示，以生成中间帧。此阶段专注于时间域的连贯性和平滑性。\n\n  优： 突破了生成长视频的长度限制；可利用最先进的文生图模型保证画面质量。\n\n  劣： 流程串行，总生成时间变长；两个阶段若使用独立模型，可能导致风格、外观不一致；插值错误会引入不自然的运动。\n\n  ##### 1.2 分块生成与拼接\n  技术核心： 分治，将长视频分解为可并行处理的独立短片段。\n\n  将长序列划分为多个不重叠的时间块。每个块由一个共享权重的视频生成模型独立生成。所有块生成后，在时间维度上进行拼接。\n\n  优： 大幅降低峰值显存占用，是生成长视频最实用的方法之一；天然支持并行生成，加快速度。\n\n  劣： 块间一致性仍是核心挑战，即便采用高级训练技巧，也难以达到端到端模型的完美流畅度。\n  \n  ##### 1.3 潜在空间高压缩\n  技术核心： 降维，在高度压缩的潜在空间中操作，极大减少处理序列的Token数量。\n\n  编码：使用如VAE、VQ-VAE或VQ-GAN的编码器，将图像/视频帧压缩到一个高度抽象的潜在表示。压缩比可以非常高（例如，将256px图像压缩为32x32的潜在编码，空间上压缩8倍）。\n\n  在潜在空间中生成： 扩散或自回归过程不是在像素空间，而是在这个压缩后的潜在空间中进行。要处理的数据量减少了数十至数百倍。\n\n  解码： 最后通过解码器将潜在表示转换回像素空间。\n\n  优： 效率的革命性提升，使得在消费级GPU上运行视频生成成为可能。\n\n  劣： 压缩必然伴随信息损失。高压缩会丢失细节，导致纹理模糊、高频信息（如精细边缘、文字）失真，以及快速运动中的伪影。\n  ##### 1.4 端到端时空建模\n  技术核心： 统一建模，将时间视为一个统一的维度，用3D卷积/注意力共同建模时空信息。\n\n  3D U-Net / DiT： 模型 backbone 使用 3D U-Net / DiT。patch不再是2D的图像块，而是3D的时空立方体。模型一次性看到一个小的时间片段，从而能够联合理解空间外观和时间运动。\n\n  位置编码： 使用3D RoPE等高级位置编码，同时编码空间位置和时间位置。\n\n  代表： Sora 的技术报告表明其属于此类范式。它通过将视频转换为时空patch的序列，然后用类似GPT的Transformer进行生成。\n\n  优： 理论上质量最高的方法。能产生最连贯、物理最合理的运动，因为它能直接对时空联合分布进行建模。\n\n  劣： 计算和内存开销巨大。序列长度是 帧数 × 高度 × 宽度，这限制了其直接生成的视频长度和分辨率。是“梦想架构”，但目前对算力要求极高。\n\n  ##### 1.5 自回归Token预测\n  技术核心：范式转换，将视频生成视为“下一个token预测”问题，统一文本和视频的生成范式。\n\n  Token化： 使用强大的视觉分词器（如MAGVIT-v2, VQ-GAN）将每帧图像转换为一系列离散的token。\n\n  序列建模： 将文本token和视频token拼接成一个长的多模态序列。\n\n  自回归生成： 使用一个Decoder-Only的大型Transformer（如GPT）来按顺序预测下一个视觉token。\n\n  代表： Google 的 VideoPoet 是典型代表。\n\n  优： 架构极其简洁统一；可轻松利用来自LLM的 scaling law 和优化技巧；理论上可生成无限长视频。\n\n  劣： 自回归生成速度慢（无法并行解码）；错误会累积；对分词器的质量依赖极高。\n\n  #### 2. 长视频生成方法的关键架构组件\n  {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121415048.png AIGC视频生成流程 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121415048.png%}\n\n  {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121417143.png 输入处理层 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121417143.png%}\n  \n  Text-Visual Tower ：\n  负责理解和处理条件输入（文本、图像、音频）的组件集合\n\n  从“T5系列+CLIP”组合转向“多模态大语言模型 (MLLM)”。\n\n  旧范式 ： 使用 T5/T5-XXL/umT5 等强大文本编码器与 CLIP 结合。T5负责深度语义理解，CLIP负责图文对齐。\n\n  趋势： 使用 MLLM（如 LLaVA, Qwen2-VL）单一模型替代上述组合。MLLM不仅能理解复杂语义，还能更好地理解空间指令（如“左边的猫”），实现更精细的视觉-文本特征对齐，减少语义漂移。HunyuanVideo 是这一趋势的代表。\n\n  {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121418882.png 核心生成层 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121418882.png%}\n\n  Backbone：\n  3D U-Net  ----->  DiT  ----> MM-DiT ----> Flux-MM-DiT\n  Decoder-only Transformer LLM\n  像GPT那样的纯自回归Transformer，代表模型（如VideoPoet）将视频生成视为“下一个token预测”问题。\n  Positional Encodings：\n  Sinusoidal/RoPE        -------->        3DRoPE \n\n  {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121418904.png 输出优化层 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121418904.png%}\n  Visual-Video Tower ：\n  负责将内部表示转换为最终视频的组件\n\n  SD 2D VAE                -------------->           3D VAE / Video VAE\n  从Stable Diffusion继承的2D编码器                前沿模型专用，能更好地压缩和重建时间信息，生成更连贯的视频。\n\n  MAGVIT-v2: 视频Tokenize模型，用于自回归方案。\n\n  双VAE 架构成为新趋势。使用两个独立的编码器分别处理静态外观特征和时序动态特征。\n  解耦外观与运动，使模型学习更专注。显著降低训练成本（如Open-Sora 2.0降低5-10倍）。更好地保持多主体身份一致性（如VideoAlchemist）。\n\n  #### 3. 前沿AIGC视频生成工具\n\n  {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429586.png AIGC视频生成工具-1 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429586.png%}\n  HunyuanVideo (腾讯)：使用 Flux-MM-DiT 架构。其最大特点是使用自研的 Hunyuan MLLM 作为文本编码器，在理解中文语境和复杂指令方面表现出色。也采用了3D VAE和3D RoPE。参数量13B，能生成720p的高清视频。\n  Sora (OpenAI)：尽管细节未完全公开，但已知其使用 Diffusion Transformer (DiT) 作为核心架构。它的一大革命性能力是支持可变分辨率、持续时间和宽高比的生成，这与之前固定尺寸的模型截然不同。能生成长达1分钟的1080p高清视频，具有惊人的长程连贯性和世界模拟能力（如物体符合物理规律运动）。\n  Stable Video Diffusion (SVD) (Stability AI)：目前最流行、应用最广的开源视频生成模型之一。它是Stable Diffusion的图像到视频专门化版本。基于3D U-Net架构，是一个图像到视频的模型，这意味着你需要先有一张图片，它才能生成一段视频。它采用了帧间插值技术来生成长视频。支持生成14或25帧的576x1024分辨率视频。虽然在绝对质量上不如Sora，但其生成速度和质量在开源模型中非常均衡。\n\n  {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429653.png AIGC视频生成工具-2 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429653.png%}\n  Veo 3 (Google DeepMind)：基于DiT架构，并集成了多种先进的编码技术和训练目标。它旨在生成高质量的1080p视频，并同样支持长视频生成。官方演示显示其能生成超过一分钟的高质量、连贯视频。它特别强调了对复杂文本指令的精确理解和 cinematic 质量。\n  Open-Sora ：复现Sora。旨在通过完全开源的方式，逐步实现与Sora类似的能力。采用了最先进的Flux-MM-DiT作为主干网络，并使用了双VAE设计（Hunyuan 3DVAE + 自编码器）来处理外观和运动。它代表了开源社区的顶尖技术水平。支持生成256p 到 768p 分辨率的视频，参数量达到11B。其目标是不断追赶闭源模型的性能。\n\n  {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429900.png AIGC视频生成工具-3 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429900.png%}\n  AnimateDiff：基于3D U-Net，它可以被注入到任何基于Stable Diffusion的图像模型中，从而让静态图像模型“动起来”。不直接决定分辨率，而是依赖于底层图像模型的能力。极大地扩展了现有图像模型的能力，用户可以使用自己喜欢的任何图像模型来创建视频，降低了视频生成的门槛。\n  VideoPoet (Google)：非扩散模型路径。它证明了自回归方案在视频生成上同样有效。使用纯Transformer架构（Decoder-Only LLM），将视频和音频都转换为离散的token，像生成文本一样生成视频。支持生成多种分辨率和长宽比的视频，并能完成视频风格化、修复等多种任务。提供了一种与扩散模型截然不同的技术思路，架构非常简洁统一，潜力巨大。\n\n### 二、延伸学习\n深度学习基础都忘光了\n#### 1. backbone -> 图像扩散模型 -> 3D U-Net -> CNN -> DiT -> Transformer\n\n#### 2. VAE\n\n#### 3. T5/CLIP/MLLM\n\n### 三、AIGC视频检测点\n现代视频生成模型的技术特点，恰恰决定了其输出结果的“指纹”和可检测的漏洞。\n\n| **漏洞类别**          | **技术根源**                                       | **具体表现与取证线索**                                       |\n| :-------------------- | :------------------------------------------------- | :----------------------------------------------------------- |\n| **1. 物理不合理性**   | 模型对复杂物理规律的**理解不完全**或**近似错误**。 | • **光影不一致**： 光源方向、物体阴影在帧间发生跳变或不匹配。 • **流体与碰撞异常**： 水、火、烟雾的运动违反物理规律；物体碰撞后的运动轨迹不自然。 • **相机模型违背**： 生成的相机运动（如晃动、变焦）与真实相机拍摄的动力学特征不符。 |\n| **2. 压缩与重构伪影** | **高压缩VAE** 导致的高频信息丢失和重建误差。       | • **高频细节缺失**： 极细的线条、远处文字、密集纹理出现**模糊或混淆**。 • **色带与色块**： 在平滑的颜色渐变区域出现不自然的**色带（Color Banding）**。 • **运动模糊失真**： 动态模糊效果在整个画面上不一致，或与运动速度不匹配。 |\n| **3. 时空不一致性**   | 模型在生成长序列时**长程依赖建模失败**。           | • **帧间闪烁**： 物体表面纹理、亮度或颜色出现高频**闪烁（Flickering）**。 • **物体突变**： 物体或人物在序列中**突然出现、消失或形态剧变**。 • **身份漂移**： 生成的人脸身份特征在视频中**无法保持完全一致**。 |\n| **4. 模型指纹溯源**   | 不同模型架构和训练数据留下的**独特“风格”印记**。   | • **VAE解码特征**： 不同VAE解码器重建的图像在**局部纹理、边缘处理方式**上存在差异。 • **位置编码模式**： 使用3D RoPE的模型与使用正弦编码的模型，其**时空关联模式**可能不同。 • **纹理风格**： 模型训练数据集的偏向会导致生成内容具有特定的**纹理或色彩风格**。 |\n\n------\n\n\n","source":"_posts/论文阅读-1.md","raw":"---\ntitle: 论文阅读-A Survey on Long-Video Storytelling Generation:Architectures, Consistency, and Cinematic Quality\ntags: [thesis,academic]\ncategories: [论文阅读]\nposter:\n  topic: 标题上方的小字\n  headline: 大标题\n  caption: 标题下方的小字\n  color: 标题颜色\ndate: 2025-09-12 13:34:02\ndescription: 老师任务：“连接你的课题，读一下这篇综述，并沿着参考文献好好追踪一下视频aigc的技术，写一篇读后文（最好配合一些复现数据），结合这些，寻找一个点，开学前写一篇小论文的初稿出来，有没有问题。”\ncover:\nbanner:\nsticky:\nmermaid:\nkatex:\nmathjax:\ntopic:\nauthor:\nreferences:\ncomments:\nindexing:\nbreadcrumb:\nleftbar:\nrightbar:\nh1:\ntype: tech\n---\n\n\n### 一、论文内容\n  详细调研了32篇关于视频生成的论文，以确定决定AIGC视频生成质量的关键架构组件和训练策略。\n  #### 1. 长视频生成方法的架构分类\n  {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121404717.png 长视频生成方法的架构分类 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121404717.png%}\n  ##### 1.1 关键帧生成+插帧\n  技术核心： 解耦“内容”与“运动”。\n  \n  阶段一：关键帧生成 \n  技术： 使用强大的文本到图像模型 (如 Stable Diffusion, DALL-E) 或 低频采样的文本到视频模型，生成在时间上稀疏但内容上关键的画面。这些帧定义了场景的主要布局、主体和语义。此阶段专注于空间域的质量和语义准确性。\n\n  阶段二：帧插值/运动生成\n  技术： 使用视频帧插值模型或运动填充模型。这些模型通常是轻量的，专注于学习两个帧之间的光流或潜在运动表示，以生成中间帧。此阶段专注于时间域的连贯性和平滑性。\n\n  优： 突破了生成长视频的长度限制；可利用最先进的文生图模型保证画面质量。\n\n  劣： 流程串行，总生成时间变长；两个阶段若使用独立模型，可能导致风格、外观不一致；插值错误会引入不自然的运动。\n\n  ##### 1.2 分块生成与拼接\n  技术核心： 分治，将长视频分解为可并行处理的独立短片段。\n\n  将长序列划分为多个不重叠的时间块。每个块由一个共享权重的视频生成模型独立生成。所有块生成后，在时间维度上进行拼接。\n\n  优： 大幅降低峰值显存占用，是生成长视频最实用的方法之一；天然支持并行生成，加快速度。\n\n  劣： 块间一致性仍是核心挑战，即便采用高级训练技巧，也难以达到端到端模型的完美流畅度。\n  \n  ##### 1.3 潜在空间高压缩\n  技术核心： 降维，在高度压缩的潜在空间中操作，极大减少处理序列的Token数量。\n\n  编码：使用如VAE、VQ-VAE或VQ-GAN的编码器，将图像/视频帧压缩到一个高度抽象的潜在表示。压缩比可以非常高（例如，将256px图像压缩为32x32的潜在编码，空间上压缩8倍）。\n\n  在潜在空间中生成： 扩散或自回归过程不是在像素空间，而是在这个压缩后的潜在空间中进行。要处理的数据量减少了数十至数百倍。\n\n  解码： 最后通过解码器将潜在表示转换回像素空间。\n\n  优： 效率的革命性提升，使得在消费级GPU上运行视频生成成为可能。\n\n  劣： 压缩必然伴随信息损失。高压缩会丢失细节，导致纹理模糊、高频信息（如精细边缘、文字）失真，以及快速运动中的伪影。\n  ##### 1.4 端到端时空建模\n  技术核心： 统一建模，将时间视为一个统一的维度，用3D卷积/注意力共同建模时空信息。\n\n  3D U-Net / DiT： 模型 backbone 使用 3D U-Net / DiT。patch不再是2D的图像块，而是3D的时空立方体。模型一次性看到一个小的时间片段，从而能够联合理解空间外观和时间运动。\n\n  位置编码： 使用3D RoPE等高级位置编码，同时编码空间位置和时间位置。\n\n  代表： Sora 的技术报告表明其属于此类范式。它通过将视频转换为时空patch的序列，然后用类似GPT的Transformer进行生成。\n\n  优： 理论上质量最高的方法。能产生最连贯、物理最合理的运动，因为它能直接对时空联合分布进行建模。\n\n  劣： 计算和内存开销巨大。序列长度是 帧数 × 高度 × 宽度，这限制了其直接生成的视频长度和分辨率。是“梦想架构”，但目前对算力要求极高。\n\n  ##### 1.5 自回归Token预测\n  技术核心：范式转换，将视频生成视为“下一个token预测”问题，统一文本和视频的生成范式。\n\n  Token化： 使用强大的视觉分词器（如MAGVIT-v2, VQ-GAN）将每帧图像转换为一系列离散的token。\n\n  序列建模： 将文本token和视频token拼接成一个长的多模态序列。\n\n  自回归生成： 使用一个Decoder-Only的大型Transformer（如GPT）来按顺序预测下一个视觉token。\n\n  代表： Google 的 VideoPoet 是典型代表。\n\n  优： 架构极其简洁统一；可轻松利用来自LLM的 scaling law 和优化技巧；理论上可生成无限长视频。\n\n  劣： 自回归生成速度慢（无法并行解码）；错误会累积；对分词器的质量依赖极高。\n\n  #### 2. 长视频生成方法的关键架构组件\n  {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121415048.png AIGC视频生成流程 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121415048.png%}\n\n  {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121417143.png 输入处理层 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121417143.png%}\n  \n  Text-Visual Tower ：\n  负责理解和处理条件输入（文本、图像、音频）的组件集合\n\n  从“T5系列+CLIP”组合转向“多模态大语言模型 (MLLM)”。\n\n  旧范式 ： 使用 T5/T5-XXL/umT5 等强大文本编码器与 CLIP 结合。T5负责深度语义理解，CLIP负责图文对齐。\n\n  趋势： 使用 MLLM（如 LLaVA, Qwen2-VL）单一模型替代上述组合。MLLM不仅能理解复杂语义，还能更好地理解空间指令（如“左边的猫”），实现更精细的视觉-文本特征对齐，减少语义漂移。HunyuanVideo 是这一趋势的代表。\n\n  {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121418882.png 核心生成层 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121418882.png%}\n\n  Backbone：\n  3D U-Net  ----->  DiT  ----> MM-DiT ----> Flux-MM-DiT\n  Decoder-only Transformer LLM\n  像GPT那样的纯自回归Transformer，代表模型（如VideoPoet）将视频生成视为“下一个token预测”问题。\n  Positional Encodings：\n  Sinusoidal/RoPE        -------->        3DRoPE \n\n  {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121418904.png 输出优化层 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121418904.png%}\n  Visual-Video Tower ：\n  负责将内部表示转换为最终视频的组件\n\n  SD 2D VAE                -------------->           3D VAE / Video VAE\n  从Stable Diffusion继承的2D编码器                前沿模型专用，能更好地压缩和重建时间信息，生成更连贯的视频。\n\n  MAGVIT-v2: 视频Tokenize模型，用于自回归方案。\n\n  双VAE 架构成为新趋势。使用两个独立的编码器分别处理静态外观特征和时序动态特征。\n  解耦外观与运动，使模型学习更专注。显著降低训练成本（如Open-Sora 2.0降低5-10倍）。更好地保持多主体身份一致性（如VideoAlchemist）。\n\n  #### 3. 前沿AIGC视频生成工具\n\n  {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429586.png AIGC视频生成工具-1 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429586.png%}\n  HunyuanVideo (腾讯)：使用 Flux-MM-DiT 架构。其最大特点是使用自研的 Hunyuan MLLM 作为文本编码器，在理解中文语境和复杂指令方面表现出色。也采用了3D VAE和3D RoPE。参数量13B，能生成720p的高清视频。\n  Sora (OpenAI)：尽管细节未完全公开，但已知其使用 Diffusion Transformer (DiT) 作为核心架构。它的一大革命性能力是支持可变分辨率、持续时间和宽高比的生成，这与之前固定尺寸的模型截然不同。能生成长达1分钟的1080p高清视频，具有惊人的长程连贯性和世界模拟能力（如物体符合物理规律运动）。\n  Stable Video Diffusion (SVD) (Stability AI)：目前最流行、应用最广的开源视频生成模型之一。它是Stable Diffusion的图像到视频专门化版本。基于3D U-Net架构，是一个图像到视频的模型，这意味着你需要先有一张图片，它才能生成一段视频。它采用了帧间插值技术来生成长视频。支持生成14或25帧的576x1024分辨率视频。虽然在绝对质量上不如Sora，但其生成速度和质量在开源模型中非常均衡。\n\n  {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429653.png AIGC视频生成工具-2 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429653.png%}\n  Veo 3 (Google DeepMind)：基于DiT架构，并集成了多种先进的编码技术和训练目标。它旨在生成高质量的1080p视频，并同样支持长视频生成。官方演示显示其能生成超过一分钟的高质量、连贯视频。它特别强调了对复杂文本指令的精确理解和 cinematic 质量。\n  Open-Sora ：复现Sora。旨在通过完全开源的方式，逐步实现与Sora类似的能力。采用了最先进的Flux-MM-DiT作为主干网络，并使用了双VAE设计（Hunyuan 3DVAE + 自编码器）来处理外观和运动。它代表了开源社区的顶尖技术水平。支持生成256p 到 768p 分辨率的视频，参数量达到11B。其目标是不断追赶闭源模型的性能。\n\n  {% image https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429900.png AIGC视频生成工具-3 download:https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429900.png%}\n  AnimateDiff：基于3D U-Net，它可以被注入到任何基于Stable Diffusion的图像模型中，从而让静态图像模型“动起来”。不直接决定分辨率，而是依赖于底层图像模型的能力。极大地扩展了现有图像模型的能力，用户可以使用自己喜欢的任何图像模型来创建视频，降低了视频生成的门槛。\n  VideoPoet (Google)：非扩散模型路径。它证明了自回归方案在视频生成上同样有效。使用纯Transformer架构（Decoder-Only LLM），将视频和音频都转换为离散的token，像生成文本一样生成视频。支持生成多种分辨率和长宽比的视频，并能完成视频风格化、修复等多种任务。提供了一种与扩散模型截然不同的技术思路，架构非常简洁统一，潜力巨大。\n\n### 二、延伸学习\n深度学习基础都忘光了\n#### 1. backbone -> 图像扩散模型 -> 3D U-Net -> CNN -> DiT -> Transformer\n\n#### 2. VAE\n\n#### 3. T5/CLIP/MLLM\n\n### 三、AIGC视频检测点\n现代视频生成模型的技术特点，恰恰决定了其输出结果的“指纹”和可检测的漏洞。\n\n| **漏洞类别**          | **技术根源**                                       | **具体表现与取证线索**                                       |\n| :-------------------- | :------------------------------------------------- | :----------------------------------------------------------- |\n| **1. 物理不合理性**   | 模型对复杂物理规律的**理解不完全**或**近似错误**。 | • **光影不一致**： 光源方向、物体阴影在帧间发生跳变或不匹配。 • **流体与碰撞异常**： 水、火、烟雾的运动违反物理规律；物体碰撞后的运动轨迹不自然。 • **相机模型违背**： 生成的相机运动（如晃动、变焦）与真实相机拍摄的动力学特征不符。 |\n| **2. 压缩与重构伪影** | **高压缩VAE** 导致的高频信息丢失和重建误差。       | • **高频细节缺失**： 极细的线条、远处文字、密集纹理出现**模糊或混淆**。 • **色带与色块**： 在平滑的颜色渐变区域出现不自然的**色带（Color Banding）**。 • **运动模糊失真**： 动态模糊效果在整个画面上不一致，或与运动速度不匹配。 |\n| **3. 时空不一致性**   | 模型在生成长序列时**长程依赖建模失败**。           | • **帧间闪烁**： 物体表面纹理、亮度或颜色出现高频**闪烁（Flickering）**。 • **物体突变**： 物体或人物在序列中**突然出现、消失或形态剧变**。 • **身份漂移**： 生成的人脸身份特征在视频中**无法保持完全一致**。 |\n| **4. 模型指纹溯源**   | 不同模型架构和训练数据留下的**独特“风格”印记**。   | • **VAE解码特征**： 不同VAE解码器重建的图像在**局部纹理、边缘处理方式**上存在差异。 • **位置编码模式**： 使用3D RoPE的模型与使用正弦编码的模型，其**时空关联模式**可能不同。 • **纹理风格**： 模型训练数据集的偏向会导致生成内容具有特定的**纹理或色彩风格**。 |\n\n------\n\n\n","slug":"论文阅读-1","published":1,"updated":"2025-09-12T07:05:11.214Z","layout":"post","photos":[],"_id":"cmgdn5rh6000h0wuz71ze1poi","content":"<h3 id=\"一、论文内容\"><a href=\"#一、论文内容\" class=\"headerlink\" title=\"一、论文内容\"></a>一、论文内容</h3><p>  详细调研了32篇关于视频生成的论文，以确定决定AIGC视频生成质量的关键架构组件和训练策略。</p>\n<h4 id=\"1-长视频生成方法的架构分类\"><a href=\"#1-长视频生成方法的架构分类\" class=\"headerlink\" title=\"1. 长视频生成方法的架构分类\"></a>1. 长视频生成方法的架构分类</h4>  <div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121404717.png\" alt=\"长视频生成方法的架构分类\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"长视频生成方法的架构分类\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121404717.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">长视频生成方法的架构分类</span></div></div>\n<h5 id=\"1-1-关键帧生成-插帧\"><a href=\"#1-1-关键帧生成-插帧\" class=\"headerlink\" title=\"1.1 关键帧生成+插帧\"></a>1.1 关键帧生成+插帧</h5><p>  技术核心： 解耦“内容”与“运动”。</p>\n<p>  阶段一：关键帧生成<br>  技术： 使用强大的文本到图像模型 (如 Stable Diffusion, DALL-E) 或 低频采样的文本到视频模型，生成在时间上稀疏但内容上关键的画面。这些帧定义了场景的主要布局、主体和语义。此阶段专注于空间域的质量和语义准确性。</p>\n<p>  阶段二：帧插值&#x2F;运动生成<br>  技术： 使用视频帧插值模型或运动填充模型。这些模型通常是轻量的，专注于学习两个帧之间的光流或潜在运动表示，以生成中间帧。此阶段专注于时间域的连贯性和平滑性。</p>\n<p>  优： 突破了生成长视频的长度限制；可利用最先进的文生图模型保证画面质量。</p>\n<p>  劣： 流程串行，总生成时间变长；两个阶段若使用独立模型，可能导致风格、外观不一致；插值错误会引入不自然的运动。</p>\n<h5 id=\"1-2-分块生成与拼接\"><a href=\"#1-2-分块生成与拼接\" class=\"headerlink\" title=\"1.2 分块生成与拼接\"></a>1.2 分块生成与拼接</h5><p>  技术核心： 分治，将长视频分解为可并行处理的独立短片段。</p>\n<p>  将长序列划分为多个不重叠的时间块。每个块由一个共享权重的视频生成模型独立生成。所有块生成后，在时间维度上进行拼接。</p>\n<p>  优： 大幅降低峰值显存占用，是生成长视频最实用的方法之一；天然支持并行生成，加快速度。</p>\n<p>  劣： 块间一致性仍是核心挑战，即便采用高级训练技巧，也难以达到端到端模型的完美流畅度。</p>\n<h5 id=\"1-3-潜在空间高压缩\"><a href=\"#1-3-潜在空间高压缩\" class=\"headerlink\" title=\"1.3 潜在空间高压缩\"></a>1.3 潜在空间高压缩</h5><p>  技术核心： 降维，在高度压缩的潜在空间中操作，极大减少处理序列的Token数量。</p>\n<p>  编码：使用如VAE、VQ-VAE或VQ-GAN的编码器，将图像&#x2F;视频帧压缩到一个高度抽象的潜在表示。压缩比可以非常高（例如，将256px图像压缩为32x32的潜在编码，空间上压缩8倍）。</p>\n<p>  在潜在空间中生成： 扩散或自回归过程不是在像素空间，而是在这个压缩后的潜在空间中进行。要处理的数据量减少了数十至数百倍。</p>\n<p>  解码： 最后通过解码器将潜在表示转换回像素空间。</p>\n<p>  优： 效率的革命性提升，使得在消费级GPU上运行视频生成成为可能。</p>\n<p>  劣： 压缩必然伴随信息损失。高压缩会丢失细节，导致纹理模糊、高频信息（如精细边缘、文字）失真，以及快速运动中的伪影。</p>\n<h5 id=\"1-4-端到端时空建模\"><a href=\"#1-4-端到端时空建模\" class=\"headerlink\" title=\"1.4 端到端时空建模\"></a>1.4 端到端时空建模</h5><p>  技术核心： 统一建模，将时间视为一个统一的维度，用3D卷积&#x2F;注意力共同建模时空信息。</p>\n<p>  3D U-Net &#x2F; DiT： 模型 backbone 使用 3D U-Net &#x2F; DiT。patch不再是2D的图像块，而是3D的时空立方体。模型一次性看到一个小的时间片段，从而能够联合理解空间外观和时间运动。</p>\n<p>  位置编码： 使用3D RoPE等高级位置编码，同时编码空间位置和时间位置。</p>\n<p>  代表： Sora 的技术报告表明其属于此类范式。它通过将视频转换为时空patch的序列，然后用类似GPT的Transformer进行生成。</p>\n<p>  优： 理论上质量最高的方法。能产生最连贯、物理最合理的运动，因为它能直接对时空联合分布进行建模。</p>\n<p>  劣： 计算和内存开销巨大。序列长度是 帧数 × 高度 × 宽度，这限制了其直接生成的视频长度和分辨率。是“梦想架构”，但目前对算力要求极高。</p>\n<h5 id=\"1-5-自回归Token预测\"><a href=\"#1-5-自回归Token预测\" class=\"headerlink\" title=\"1.5 自回归Token预测\"></a>1.5 自回归Token预测</h5><p>  技术核心：范式转换，将视频生成视为“下一个token预测”问题，统一文本和视频的生成范式。</p>\n<p>  Token化： 使用强大的视觉分词器（如MAGVIT-v2, VQ-GAN）将每帧图像转换为一系列离散的token。</p>\n<p>  序列建模： 将文本token和视频token拼接成一个长的多模态序列。</p>\n<p>  自回归生成： 使用一个Decoder-Only的大型Transformer（如GPT）来按顺序预测下一个视觉token。</p>\n<p>  代表： Google 的 VideoPoet 是典型代表。</p>\n<p>  优： 架构极其简洁统一；可轻松利用来自LLM的 scaling law 和优化技巧；理论上可生成无限长视频。</p>\n<p>  劣： 自回归生成速度慢（无法并行解码）；错误会累积；对分词器的质量依赖极高。</p>\n<h4 id=\"2-长视频生成方法的关键架构组件\"><a href=\"#2-长视频生成方法的关键架构组件\" class=\"headerlink\" title=\"2. 长视频生成方法的关键架构组件\"></a>2. 长视频生成方法的关键架构组件</h4>  <div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121415048.png\" alt=\"AIGC视频生成流程\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"AIGC视频生成流程\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121415048.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">AIGC视频生成流程</span></div></div>\n\n  <div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121417143.png\" alt=\"输入处理层\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"输入处理层\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121417143.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">输入处理层</span></div></div>\n<p>  Text-Visual Tower ：<br>  负责理解和处理条件输入（文本、图像、音频）的组件集合</p>\n<p>  从“T5系列+CLIP”组合转向“多模态大语言模型 (MLLM)”。</p>\n<p>  旧范式 ： 使用 T5&#x2F;T5-XXL&#x2F;umT5 等强大文本编码器与 CLIP 结合。T5负责深度语义理解，CLIP负责图文对齐。</p>\n<p>  趋势： 使用 MLLM（如 LLaVA, Qwen2-VL）单一模型替代上述组合。MLLM不仅能理解复杂语义，还能更好地理解空间指令（如“左边的猫”），实现更精细的视觉-文本特征对齐，减少语义漂移。HunyuanVideo 是这一趋势的代表。</p>\n  <div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121418882.png\" alt=\"核心生成层\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"核心生成层\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121418882.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">核心生成层</span></div></div>\n\n<p>  Backbone：<br>  3D U-Net  —–&gt;  DiT  —-&gt; MM-DiT —-&gt; Flux-MM-DiT<br>  Decoder-only Transformer LLM<br>  像GPT那样的纯自回归Transformer，代表模型（如VideoPoet）将视频生成视为“下一个token预测”问题。<br>  Positional Encodings：<br>  Sinusoidal&#x2F;RoPE        ——–&gt;        3DRoPE </p>\n  <div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121418904.png\" alt=\"输出优化层\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"输出优化层\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121418904.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">输出优化层</span></div></div>\n<p>  Visual-Video Tower ：<br>  负责将内部表示转换为最终视频的组件</p>\n<p>  SD 2D VAE                ————–&gt;           3D VAE &#x2F; Video VAE<br>  从Stable Diffusion继承的2D编码器                前沿模型专用，能更好地压缩和重建时间信息，生成更连贯的视频。</p>\n<p>  MAGVIT-v2: 视频Tokenize模型，用于自回归方案。</p>\n<p>  双VAE 架构成为新趋势。使用两个独立的编码器分别处理静态外观特征和时序动态特征。<br>  解耦外观与运动，使模型学习更专注。显著降低训练成本（如Open-Sora 2.0降低5-10倍）。更好地保持多主体身份一致性（如VideoAlchemist）。</p>\n<h4 id=\"3-前沿AIGC视频生成工具\"><a href=\"#3-前沿AIGC视频生成工具\" class=\"headerlink\" title=\"3. 前沿AIGC视频生成工具\"></a>3. 前沿AIGC视频生成工具</h4>  <div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429586.png\" alt=\"AIGC视频生成工具-1\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"AIGC视频生成工具-1\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429586.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">AIGC视频生成工具-1</span></div></div>\n<p>  HunyuanVideo (腾讯)：使用 Flux-MM-DiT 架构。其最大特点是使用自研的 Hunyuan MLLM 作为文本编码器，在理解中文语境和复杂指令方面表现出色。也采用了3D VAE和3D RoPE。参数量13B，能生成720p的高清视频。<br>  Sora (OpenAI)：尽管细节未完全公开，但已知其使用 Diffusion Transformer (DiT) 作为核心架构。它的一大革命性能力是支持可变分辨率、持续时间和宽高比的生成，这与之前固定尺寸的模型截然不同。能生成长达1分钟的1080p高清视频，具有惊人的长程连贯性和世界模拟能力（如物体符合物理规律运动）。<br>  Stable Video Diffusion (SVD) (Stability AI)：目前最流行、应用最广的开源视频生成模型之一。它是Stable Diffusion的图像到视频专门化版本。基于3D U-Net架构，是一个图像到视频的模型，这意味着你需要先有一张图片，它才能生成一段视频。它采用了帧间插值技术来生成长视频。支持生成14或25帧的576x1024分辨率视频。虽然在绝对质量上不如Sora，但其生成速度和质量在开源模型中非常均衡。</p>\n  <div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429653.png\" alt=\"AIGC视频生成工具-2\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"AIGC视频生成工具-2\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429653.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">AIGC视频生成工具-2</span></div></div>\n<p>  Veo 3 (Google DeepMind)：基于DiT架构，并集成了多种先进的编码技术和训练目标。它旨在生成高质量的1080p视频，并同样支持长视频生成。官方演示显示其能生成超过一分钟的高质量、连贯视频。它特别强调了对复杂文本指令的精确理解和 cinematic 质量。<br>  Open-Sora ：复现Sora。旨在通过完全开源的方式，逐步实现与Sora类似的能力。采用了最先进的Flux-MM-DiT作为主干网络，并使用了双VAE设计（Hunyuan 3DVAE + 自编码器）来处理外观和运动。它代表了开源社区的顶尖技术水平。支持生成256p 到 768p 分辨率的视频，参数量达到11B。其目标是不断追赶闭源模型的性能。</p>\n  <div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429900.png\" alt=\"AIGC视频生成工具-3\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"AIGC视频生成工具-3\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429900.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">AIGC视频生成工具-3</span></div></div>\n<p>  AnimateDiff：基于3D U-Net，它可以被注入到任何基于Stable Diffusion的图像模型中，从而让静态图像模型“动起来”。不直接决定分辨率，而是依赖于底层图像模型的能力。极大地扩展了现有图像模型的能力，用户可以使用自己喜欢的任何图像模型来创建视频，降低了视频生成的门槛。<br>  VideoPoet (Google)：非扩散模型路径。它证明了自回归方案在视频生成上同样有效。使用纯Transformer架构（Decoder-Only LLM），将视频和音频都转换为离散的token，像生成文本一样生成视频。支持生成多种分辨率和长宽比的视频，并能完成视频风格化、修复等多种任务。提供了一种与扩散模型截然不同的技术思路，架构非常简洁统一，潜力巨大。</p>\n<h3 id=\"二、延伸学习\"><a href=\"#二、延伸学习\" class=\"headerlink\" title=\"二、延伸学习\"></a>二、延伸学习</h3><p>深度学习基础都忘光了</p>\n<h4 id=\"1-backbone-图像扩散模型-3D-U-Net-CNN-DiT-Transformer\"><a href=\"#1-backbone-图像扩散模型-3D-U-Net-CNN-DiT-Transformer\" class=\"headerlink\" title=\"1. backbone -&gt; 图像扩散模型 -&gt; 3D U-Net -&gt; CNN -&gt; DiT -&gt; Transformer\"></a>1. backbone -&gt; 图像扩散模型 -&gt; 3D U-Net -&gt; CNN -&gt; DiT -&gt; Transformer</h4><h4 id=\"2-VAE\"><a href=\"#2-VAE\" class=\"headerlink\" title=\"2. VAE\"></a>2. VAE</h4><h4 id=\"3-T5-CLIP-MLLM\"><a href=\"#3-T5-CLIP-MLLM\" class=\"headerlink\" title=\"3. T5&#x2F;CLIP&#x2F;MLLM\"></a>3. T5&#x2F;CLIP&#x2F;MLLM</h4><h3 id=\"三、AIGC视频检测点\"><a href=\"#三、AIGC视频检测点\" class=\"headerlink\" title=\"三、AIGC视频检测点\"></a>三、AIGC视频检测点</h3><p>现代视频生成模型的技术特点，恰恰决定了其输出结果的“指纹”和可检测的漏洞。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>漏洞类别</strong></th>\n<th align=\"left\"><strong>技术根源</strong></th>\n<th align=\"left\"><strong>具体表现与取证线索</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>1. 物理不合理性</strong></td>\n<td align=\"left\">模型对复杂物理规律的<strong>理解不完全</strong>或<strong>近似错误</strong>。</td>\n<td align=\"left\">• <strong>光影不一致</strong>： 光源方向、物体阴影在帧间发生跳变或不匹配。 • <strong>流体与碰撞异常</strong>： 水、火、烟雾的运动违反物理规律；物体碰撞后的运动轨迹不自然。 • <strong>相机模型违背</strong>： 生成的相机运动（如晃动、变焦）与真实相机拍摄的动力学特征不符。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>2. 压缩与重构伪影</strong></td>\n<td align=\"left\"><strong>高压缩VAE</strong> 导致的高频信息丢失和重建误差。</td>\n<td align=\"left\">• <strong>高频细节缺失</strong>： 极细的线条、远处文字、密集纹理出现<strong>模糊或混淆</strong>。 • <strong>色带与色块</strong>： 在平滑的颜色渐变区域出现不自然的<strong>色带（Color Banding）</strong>。 • <strong>运动模糊失真</strong>： 动态模糊效果在整个画面上不一致，或与运动速度不匹配。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>3. 时空不一致性</strong></td>\n<td align=\"left\">模型在生成长序列时<strong>长程依赖建模失败</strong>。</td>\n<td align=\"left\">• <strong>帧间闪烁</strong>： 物体表面纹理、亮度或颜色出现高频<strong>闪烁（Flickering）</strong>。 • <strong>物体突变</strong>： 物体或人物在序列中<strong>突然出现、消失或形态剧变</strong>。 • <strong>身份漂移</strong>： 生成的人脸身份特征在视频中<strong>无法保持完全一致</strong>。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>4. 模型指纹溯源</strong></td>\n<td align=\"left\">不同模型架构和训练数据留下的<strong>独特“风格”印记</strong>。</td>\n<td align=\"left\">• <strong>VAE解码特征</strong>： 不同VAE解码器重建的图像在<strong>局部纹理、边缘处理方式</strong>上存在差异。 • <strong>位置编码模式</strong>： 使用3D RoPE的模型与使用正弦编码的模型，其<strong>时空关联模式</strong>可能不同。 • <strong>纹理风格</strong>： 模型训练数据集的偏向会导致生成内容具有特定的<strong>纹理或色彩风格</strong>。</td>\n</tr>\n</tbody></table>\n<hr>\n","excerpt":"","more":"<h3 id=\"一、论文内容\"><a href=\"#一、论文内容\" class=\"headerlink\" title=\"一、论文内容\"></a>一、论文内容</h3><p>  详细调研了32篇关于视频生成的论文，以确定决定AIGC视频生成质量的关键架构组件和训练策略。</p>\n<h4 id=\"1-长视频生成方法的架构分类\"><a href=\"#1-长视频生成方法的架构分类\" class=\"headerlink\" title=\"1. 长视频生成方法的架构分类\"></a>1. 长视频生成方法的架构分类</h4>  <div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121404717.png\" alt=\"长视频生成方法的架构分类\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"长视频生成方法的架构分类\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121404717.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">长视频生成方法的架构分类</span></div></div>\n<h5 id=\"1-1-关键帧生成-插帧\"><a href=\"#1-1-关键帧生成-插帧\" class=\"headerlink\" title=\"1.1 关键帧生成+插帧\"></a>1.1 关键帧生成+插帧</h5><p>  技术核心： 解耦“内容”与“运动”。</p>\n<p>  阶段一：关键帧生成<br>  技术： 使用强大的文本到图像模型 (如 Stable Diffusion, DALL-E) 或 低频采样的文本到视频模型，生成在时间上稀疏但内容上关键的画面。这些帧定义了场景的主要布局、主体和语义。此阶段专注于空间域的质量和语义准确性。</p>\n<p>  阶段二：帧插值&#x2F;运动生成<br>  技术： 使用视频帧插值模型或运动填充模型。这些模型通常是轻量的，专注于学习两个帧之间的光流或潜在运动表示，以生成中间帧。此阶段专注于时间域的连贯性和平滑性。</p>\n<p>  优： 突破了生成长视频的长度限制；可利用最先进的文生图模型保证画面质量。</p>\n<p>  劣： 流程串行，总生成时间变长；两个阶段若使用独立模型，可能导致风格、外观不一致；插值错误会引入不自然的运动。</p>\n<h5 id=\"1-2-分块生成与拼接\"><a href=\"#1-2-分块生成与拼接\" class=\"headerlink\" title=\"1.2 分块生成与拼接\"></a>1.2 分块生成与拼接</h5><p>  技术核心： 分治，将长视频分解为可并行处理的独立短片段。</p>\n<p>  将长序列划分为多个不重叠的时间块。每个块由一个共享权重的视频生成模型独立生成。所有块生成后，在时间维度上进行拼接。</p>\n<p>  优： 大幅降低峰值显存占用，是生成长视频最实用的方法之一；天然支持并行生成，加快速度。</p>\n<p>  劣： 块间一致性仍是核心挑战，即便采用高级训练技巧，也难以达到端到端模型的完美流畅度。</p>\n<h5 id=\"1-3-潜在空间高压缩\"><a href=\"#1-3-潜在空间高压缩\" class=\"headerlink\" title=\"1.3 潜在空间高压缩\"></a>1.3 潜在空间高压缩</h5><p>  技术核心： 降维，在高度压缩的潜在空间中操作，极大减少处理序列的Token数量。</p>\n<p>  编码：使用如VAE、VQ-VAE或VQ-GAN的编码器，将图像&#x2F;视频帧压缩到一个高度抽象的潜在表示。压缩比可以非常高（例如，将256px图像压缩为32x32的潜在编码，空间上压缩8倍）。</p>\n<p>  在潜在空间中生成： 扩散或自回归过程不是在像素空间，而是在这个压缩后的潜在空间中进行。要处理的数据量减少了数十至数百倍。</p>\n<p>  解码： 最后通过解码器将潜在表示转换回像素空间。</p>\n<p>  优： 效率的革命性提升，使得在消费级GPU上运行视频生成成为可能。</p>\n<p>  劣： 压缩必然伴随信息损失。高压缩会丢失细节，导致纹理模糊、高频信息（如精细边缘、文字）失真，以及快速运动中的伪影。</p>\n<h5 id=\"1-4-端到端时空建模\"><a href=\"#1-4-端到端时空建模\" class=\"headerlink\" title=\"1.4 端到端时空建模\"></a>1.4 端到端时空建模</h5><p>  技术核心： 统一建模，将时间视为一个统一的维度，用3D卷积&#x2F;注意力共同建模时空信息。</p>\n<p>  3D U-Net &#x2F; DiT： 模型 backbone 使用 3D U-Net &#x2F; DiT。patch不再是2D的图像块，而是3D的时空立方体。模型一次性看到一个小的时间片段，从而能够联合理解空间外观和时间运动。</p>\n<p>  位置编码： 使用3D RoPE等高级位置编码，同时编码空间位置和时间位置。</p>\n<p>  代表： Sora 的技术报告表明其属于此类范式。它通过将视频转换为时空patch的序列，然后用类似GPT的Transformer进行生成。</p>\n<p>  优： 理论上质量最高的方法。能产生最连贯、物理最合理的运动，因为它能直接对时空联合分布进行建模。</p>\n<p>  劣： 计算和内存开销巨大。序列长度是 帧数 × 高度 × 宽度，这限制了其直接生成的视频长度和分辨率。是“梦想架构”，但目前对算力要求极高。</p>\n<h5 id=\"1-5-自回归Token预测\"><a href=\"#1-5-自回归Token预测\" class=\"headerlink\" title=\"1.5 自回归Token预测\"></a>1.5 自回归Token预测</h5><p>  技术核心：范式转换，将视频生成视为“下一个token预测”问题，统一文本和视频的生成范式。</p>\n<p>  Token化： 使用强大的视觉分词器（如MAGVIT-v2, VQ-GAN）将每帧图像转换为一系列离散的token。</p>\n<p>  序列建模： 将文本token和视频token拼接成一个长的多模态序列。</p>\n<p>  自回归生成： 使用一个Decoder-Only的大型Transformer（如GPT）来按顺序预测下一个视觉token。</p>\n<p>  代表： Google 的 VideoPoet 是典型代表。</p>\n<p>  优： 架构极其简洁统一；可轻松利用来自LLM的 scaling law 和优化技巧；理论上可生成无限长视频。</p>\n<p>  劣： 自回归生成速度慢（无法并行解码）；错误会累积；对分词器的质量依赖极高。</p>\n<h4 id=\"2-长视频生成方法的关键架构组件\"><a href=\"#2-长视频生成方法的关键架构组件\" class=\"headerlink\" title=\"2. 长视频生成方法的关键架构组件\"></a>2. 长视频生成方法的关键架构组件</h4>  <div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121415048.png\" alt=\"AIGC视频生成流程\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"AIGC视频生成流程\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121415048.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">AIGC视频生成流程</span></div></div>\n\n  <div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121417143.png\" alt=\"输入处理层\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"输入处理层\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121417143.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">输入处理层</span></div></div>\n<p>  Text-Visual Tower ：<br>  负责理解和处理条件输入（文本、图像、音频）的组件集合</p>\n<p>  从“T5系列+CLIP”组合转向“多模态大语言模型 (MLLM)”。</p>\n<p>  旧范式 ： 使用 T5&#x2F;T5-XXL&#x2F;umT5 等强大文本编码器与 CLIP 结合。T5负责深度语义理解，CLIP负责图文对齐。</p>\n<p>  趋势： 使用 MLLM（如 LLaVA, Qwen2-VL）单一模型替代上述组合。MLLM不仅能理解复杂语义，还能更好地理解空间指令（如“左边的猫”），实现更精细的视觉-文本特征对齐，减少语义漂移。HunyuanVideo 是这一趋势的代表。</p>\n  <div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121418882.png\" alt=\"核心生成层\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"核心生成层\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121418882.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">核心生成层</span></div></div>\n\n<p>  Backbone：<br>  3D U-Net  —–&gt;  DiT  —-&gt; MM-DiT —-&gt; Flux-MM-DiT<br>  Decoder-only Transformer LLM<br>  像GPT那样的纯自回归Transformer，代表模型（如VideoPoet）将视频生成视为“下一个token预测”问题。<br>  Positional Encodings：<br>  Sinusoidal&#x2F;RoPE        ——–&gt;        3DRoPE </p>\n  <div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121418904.png\" alt=\"输出优化层\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"输出优化层\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121418904.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">输出优化层</span></div></div>\n<p>  Visual-Video Tower ：<br>  负责将内部表示转换为最终视频的组件</p>\n<p>  SD 2D VAE                ————–&gt;           3D VAE &#x2F; Video VAE<br>  从Stable Diffusion继承的2D编码器                前沿模型专用，能更好地压缩和重建时间信息，生成更连贯的视频。</p>\n<p>  MAGVIT-v2: 视频Tokenize模型，用于自回归方案。</p>\n<p>  双VAE 架构成为新趋势。使用两个独立的编码器分别处理静态外观特征和时序动态特征。<br>  解耦外观与运动，使模型学习更专注。显著降低训练成本（如Open-Sora 2.0降低5-10倍）。更好地保持多主体身份一致性（如VideoAlchemist）。</p>\n<h4 id=\"3-前沿AIGC视频生成工具\"><a href=\"#3-前沿AIGC视频生成工具\" class=\"headerlink\" title=\"3. 前沿AIGC视频生成工具\"></a>3. 前沿AIGC视频生成工具</h4>  <div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429586.png\" alt=\"AIGC视频生成工具-1\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"AIGC视频生成工具-1\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429586.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">AIGC视频生成工具-1</span></div></div>\n<p>  HunyuanVideo (腾讯)：使用 Flux-MM-DiT 架构。其最大特点是使用自研的 Hunyuan MLLM 作为文本编码器，在理解中文语境和复杂指令方面表现出色。也采用了3D VAE和3D RoPE。参数量13B，能生成720p的高清视频。<br>  Sora (OpenAI)：尽管细节未完全公开，但已知其使用 Diffusion Transformer (DiT) 作为核心架构。它的一大革命性能力是支持可变分辨率、持续时间和宽高比的生成，这与之前固定尺寸的模型截然不同。能生成长达1分钟的1080p高清视频，具有惊人的长程连贯性和世界模拟能力（如物体符合物理规律运动）。<br>  Stable Video Diffusion (SVD) (Stability AI)：目前最流行、应用最广的开源视频生成模型之一。它是Stable Diffusion的图像到视频专门化版本。基于3D U-Net架构，是一个图像到视频的模型，这意味着你需要先有一张图片，它才能生成一段视频。它采用了帧间插值技术来生成长视频。支持生成14或25帧的576x1024分辨率视频。虽然在绝对质量上不如Sora，但其生成速度和质量在开源模型中非常均衡。</p>\n  <div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429653.png\" alt=\"AIGC视频生成工具-2\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"AIGC视频生成工具-2\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429653.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">AIGC视频生成工具-2</span></div></div>\n<p>  Veo 3 (Google DeepMind)：基于DiT架构，并集成了多种先进的编码技术和训练目标。它旨在生成高质量的1080p视频，并同样支持长视频生成。官方演示显示其能生成超过一分钟的高质量、连贯视频。它特别强调了对复杂文本指令的精确理解和 cinematic 质量。<br>  Open-Sora ：复现Sora。旨在通过完全开源的方式，逐步实现与Sora类似的能力。采用了最先进的Flux-MM-DiT作为主干网络，并使用了双VAE设计（Hunyuan 3DVAE + 自编码器）来处理外观和运动。它代表了开源社区的顶尖技术水平。支持生成256p 到 768p 分辨率的视频，参数量达到11B。其目标是不断追赶闭源模型的性能。</p>\n  <div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429900.png\" alt=\"AIGC视频生成工具-3\"/><a class=\"image-download blur\" style=\"opacity:0\" target=\"_blank\" download=\"AIGC视频生成工具-3\" href=\"https://xylumina.oss-cn-beijing.aliyuncs.com/img/202509121429900.png\"><svg class=\"icon\" style=\"width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"3734\"><path d=\"M561.00682908 685.55838913a111.03077546 111.03077546 0 0 1-106.8895062 0L256.23182837 487.72885783a55.96309219 55.96309219 0 0 1 79.13181253-79.18777574L450.70357448 523.88101491V181.55477937a55.96309219 55.96309219 0 0 1 111.92618438 0v344.06109173l117.07478902-117.07478901a55.96309219 55.96309219 0 0 1 79.13181252 79.18777574zM282.81429711 797.1487951h447.70473912a55.96309219 55.96309219 0 0 1 0 111.92618438H282.81429711a55.96309219 55.96309219 0 0 1 0-111.92618438z\" p-id=\"3735\"></path></svg></a></div><div class=\"image-meta\"><span class=\"image-caption center\">AIGC视频生成工具-3</span></div></div>\n<p>  AnimateDiff：基于3D U-Net，它可以被注入到任何基于Stable Diffusion的图像模型中，从而让静态图像模型“动起来”。不直接决定分辨率，而是依赖于底层图像模型的能力。极大地扩展了现有图像模型的能力，用户可以使用自己喜欢的任何图像模型来创建视频，降低了视频生成的门槛。<br>  VideoPoet (Google)：非扩散模型路径。它证明了自回归方案在视频生成上同样有效。使用纯Transformer架构（Decoder-Only LLM），将视频和音频都转换为离散的token，像生成文本一样生成视频。支持生成多种分辨率和长宽比的视频，并能完成视频风格化、修复等多种任务。提供了一种与扩散模型截然不同的技术思路，架构非常简洁统一，潜力巨大。</p>\n<h3 id=\"二、延伸学习\"><a href=\"#二、延伸学习\" class=\"headerlink\" title=\"二、延伸学习\"></a>二、延伸学习</h3><p>深度学习基础都忘光了</p>\n<h4 id=\"1-backbone-图像扩散模型-3D-U-Net-CNN-DiT-Transformer\"><a href=\"#1-backbone-图像扩散模型-3D-U-Net-CNN-DiT-Transformer\" class=\"headerlink\" title=\"1. backbone -&gt; 图像扩散模型 -&gt; 3D U-Net -&gt; CNN -&gt; DiT -&gt; Transformer\"></a>1. backbone -&gt; 图像扩散模型 -&gt; 3D U-Net -&gt; CNN -&gt; DiT -&gt; Transformer</h4><h4 id=\"2-VAE\"><a href=\"#2-VAE\" class=\"headerlink\" title=\"2. VAE\"></a>2. VAE</h4><h4 id=\"3-T5-CLIP-MLLM\"><a href=\"#3-T5-CLIP-MLLM\" class=\"headerlink\" title=\"3. T5&#x2F;CLIP&#x2F;MLLM\"></a>3. T5&#x2F;CLIP&#x2F;MLLM</h4><h3 id=\"三、AIGC视频检测点\"><a href=\"#三、AIGC视频检测点\" class=\"headerlink\" title=\"三、AIGC视频检测点\"></a>三、AIGC视频检测点</h3><p>现代视频生成模型的技术特点，恰恰决定了其输出结果的“指纹”和可检测的漏洞。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>漏洞类别</strong></th>\n<th align=\"left\"><strong>技术根源</strong></th>\n<th align=\"left\"><strong>具体表现与取证线索</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>1. 物理不合理性</strong></td>\n<td align=\"left\">模型对复杂物理规律的<strong>理解不完全</strong>或<strong>近似错误</strong>。</td>\n<td align=\"left\">• <strong>光影不一致</strong>： 光源方向、物体阴影在帧间发生跳变或不匹配。 • <strong>流体与碰撞异常</strong>： 水、火、烟雾的运动违反物理规律；物体碰撞后的运动轨迹不自然。 • <strong>相机模型违背</strong>： 生成的相机运动（如晃动、变焦）与真实相机拍摄的动力学特征不符。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>2. 压缩与重构伪影</strong></td>\n<td align=\"left\"><strong>高压缩VAE</strong> 导致的高频信息丢失和重建误差。</td>\n<td align=\"left\">• <strong>高频细节缺失</strong>： 极细的线条、远处文字、密集纹理出现<strong>模糊或混淆</strong>。 • <strong>色带与色块</strong>： 在平滑的颜色渐变区域出现不自然的<strong>色带（Color Banding）</strong>。 • <strong>运动模糊失真</strong>： 动态模糊效果在整个画面上不一致，或与运动速度不匹配。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>3. 时空不一致性</strong></td>\n<td align=\"left\">模型在生成长序列时<strong>长程依赖建模失败</strong>。</td>\n<td align=\"left\">• <strong>帧间闪烁</strong>： 物体表面纹理、亮度或颜色出现高频<strong>闪烁（Flickering）</strong>。 • <strong>物体突变</strong>： 物体或人物在序列中<strong>突然出现、消失或形态剧变</strong>。 • <strong>身份漂移</strong>： 生成的人脸身份特征在视频中<strong>无法保持完全一致</strong>。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>4. 模型指纹溯源</strong></td>\n<td align=\"left\">不同模型架构和训练数据留下的<strong>独特“风格”印记</strong>。</td>\n<td align=\"left\">• <strong>VAE解码特征</strong>： 不同VAE解码器重建的图像在<strong>局部纹理、边缘处理方式</strong>上存在差异。 • <strong>位置编码模式</strong>： 使用3D RoPE的模型与使用正弦编码的模型，其<strong>时空关联模式</strong>可能不同。 • <strong>纹理风格</strong>： 模型训练数据集的偏向会导致生成内容具有特定的<strong>纹理或色彩风格</strong>。</td>\n</tr>\n</tbody></table>\n<hr>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmgdn5rh200090wuz55woc9bg","category_id":"cmgdn5rh000040wuzg0p0cgre","_id":"cmgdn5rh6000i0wuzdwbhebhh"},{"post_id":"cmgdn5rgu00010wuz3dp5f2gk","category_id":"cmgdn5rh000040wuzg0p0cgre","_id":"cmgdn5rh7000m0wuzfilndez0"},{"post_id":"cmgdn5rh3000b0wuz0a50b21t","category_id":"cmgdn5rh000040wuzg0p0cgre","_id":"cmgdn5rh7000n0wuz8dh0fjtd"},{"post_id":"cmgdn5rgy00030wuzg5ph6qm6","category_id":"cmgdn5rh000040wuzg0p0cgre","_id":"cmgdn5rh8000q0wuz1nv01n8z"},{"post_id":"cmgdn5rh100070wuzdsb4ef7s","category_id":"cmgdn5rh000040wuzg0p0cgre","_id":"cmgdn5rh8000s0wuzbbb37owq"},{"post_id":"cmgdn5rh5000f0wuz89xtbedd","category_id":"cmgdn5rh7000o0wuzc36k90tm","_id":"cmgdn5rh8000x0wuz4taj6e5h"},{"post_id":"cmgdn5rh6000h0wuz71ze1poi","category_id":"cmgdn5rh8000t0wuz3v3b4ktb","_id":"cmgdn5rh9000z0wuz54jrdskl"}],"PostTag":[{"post_id":"cmgdn5rgu00010wuz3dp5f2gk","tag_id":"cmgdn5rh100050wuzgu2a5qk2","_id":"cmgdn5rh8000r0wuz1d666dck"},{"post_id":"cmgdn5rgu00010wuz3dp5f2gk","tag_id":"cmgdn5rh4000d0wuz1gp04fce","_id":"cmgdn5rh8000u0wuzfh24736b"},{"post_id":"cmgdn5rgu00010wuz3dp5f2gk","tag_id":"cmgdn5rh6000k0wuz0exad5hn","_id":"cmgdn5rh8000w0wuz661cgrn9"},{"post_id":"cmgdn5rgy00030wuzg5ph6qm6","tag_id":"cmgdn5rh100050wuzgu2a5qk2","_id":"cmgdn5rh900110wuz4c7tecw6"},{"post_id":"cmgdn5rgy00030wuzg5ph6qm6","tag_id":"cmgdn5rh4000d0wuz1gp04fce","_id":"cmgdn5rh900120wuz7q4mbzqo"},{"post_id":"cmgdn5rgy00030wuzg5ph6qm6","tag_id":"cmgdn5rh6000k0wuz0exad5hn","_id":"cmgdn5rh900140wuzgkbcfcnd"},{"post_id":"cmgdn5rh100070wuzdsb4ef7s","tag_id":"cmgdn5rh100050wuzgu2a5qk2","_id":"cmgdn5rha00170wuz718791ps"},{"post_id":"cmgdn5rh100070wuzdsb4ef7s","tag_id":"cmgdn5rh4000d0wuz1gp04fce","_id":"cmgdn5rha00180wuz9vdbezsw"},{"post_id":"cmgdn5rh100070wuzdsb4ef7s","tag_id":"cmgdn5rh6000k0wuz0exad5hn","_id":"cmgdn5rha001a0wuz7a0d8jad"},{"post_id":"cmgdn5rh200090wuz55woc9bg","tag_id":"cmgdn5rh100050wuzgu2a5qk2","_id":"cmgdn5rha001c0wuzde0k0zuz"},{"post_id":"cmgdn5rh200090wuz55woc9bg","tag_id":"cmgdn5rh4000d0wuz1gp04fce","_id":"cmgdn5rha001d0wuz9ehrb19q"},{"post_id":"cmgdn5rh200090wuz55woc9bg","tag_id":"cmgdn5rh6000k0wuz0exad5hn","_id":"cmgdn5rhb001f0wuz8ud56irc"},{"post_id":"cmgdn5rh3000b0wuz0a50b21t","tag_id":"cmgdn5rh100050wuzgu2a5qk2","_id":"cmgdn5rhb001h0wuz86ep123p"},{"post_id":"cmgdn5rh3000b0wuz0a50b21t","tag_id":"cmgdn5rh4000d0wuz1gp04fce","_id":"cmgdn5rhb001i0wuz20ok4410"},{"post_id":"cmgdn5rh3000b0wuz0a50b21t","tag_id":"cmgdn5rh6000k0wuz0exad5hn","_id":"cmgdn5rhb001k0wuz1wtdg3ll"},{"post_id":"cmgdn5rh5000f0wuz89xtbedd","tag_id":"cmgdn5rhb001g0wuz6xs66kcd","_id":"cmgdn5rhb001n0wuzadpn8j3r"},{"post_id":"cmgdn5rh5000f0wuz89xtbedd","tag_id":"cmgdn5rhb001j0wuz2j5x9fc1","_id":"cmgdn5rhc001o0wuz8x9occ7w"},{"post_id":"cmgdn5rh5000f0wuz89xtbedd","tag_id":"cmgdn5rhb001l0wuzhjy08hem","_id":"cmgdn5rhc001q0wuzg7z98itc"},{"post_id":"cmgdn5rh6000h0wuz71ze1poi","tag_id":"cmgdn5rhb001m0wuz465q4um6","_id":"cmgdn5rhc001r0wuzfftc94f8"},{"post_id":"cmgdn5rh6000h0wuz71ze1poi","tag_id":"cmgdn5rhc001p0wuzhnb0dpp8","_id":"cmgdn5rhc001s0wuz9hdc91re"}],"Tag":[{"name":"Spring Boot","_id":"cmgdn5rh100050wuzgu2a5qk2"},{"name":"高并发","_id":"cmgdn5rh4000d0wuz1gp04fce"},{"name":"JUC","_id":"cmgdn5rh6000k0wuz0exad5hn"},{"name":"hexo","_id":"cmgdn5rhb001g0wuz6xs66kcd"},{"name":"stellar","_id":"cmgdn5rhb001j0wuz2j5x9fc1"},{"name":"vercel","_id":"cmgdn5rhb001l0wuzhjy08hem"},{"name":"thesis","_id":"cmgdn5rhb001m0wuz465q4um6"},{"name":"academic","_id":"cmgdn5rhc001p0wuzhnb0dpp8"}]}}